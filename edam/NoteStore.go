// Code generated by Thrift Compiler (0.16.0). DO NOT EDIT.

package edam

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

//Privilege levels for accessing shared notebooks.
//
//READ_NOTEBOOK: Recipient is able to read the contents of the shared notebook
//  but does not have access to information about other recipients of the
//  notebook or the activity stream information.
//
//READ_NOTEBOOK_PLUS_ACTIVITY: Recipient has READ_NOTEBOOK rights and can also
//  access information about other recipients and the activity stream.
//
//MODIFY_NOTEBOOK_PLUS_ACTIVITY: Recipient has rights to read and modify the contents
//  of the shared notebook, including the right to move notes to the trash and to create
//  notes in the notebook.  The recipient can also access information about other
//  recipients and the activity stream.
//
//FULL_ACCESS: Recipient has full rights to the shared notebook and recipient lists,
//  including privilege to revoke and create invitations and to change privilege
//  levels on invitations for individuals. If the user is a member of the same group,
//  (e.g. the same business) as the shared notebook, they will additionally be granted
//  permissions to update the publishing status of the notebook.
type ShareRelationshipPrivilegeLevel int64
const (
  ShareRelationshipPrivilegeLevel_READ_NOTEBOOK ShareRelationshipPrivilegeLevel = 0
  ShareRelationshipPrivilegeLevel_READ_NOTEBOOK_PLUS_ACTIVITY ShareRelationshipPrivilegeLevel = 10
  ShareRelationshipPrivilegeLevel_MODIFY_NOTEBOOK_PLUS_ACTIVITY ShareRelationshipPrivilegeLevel = 20
  ShareRelationshipPrivilegeLevel_FULL_ACCESS ShareRelationshipPrivilegeLevel = 30
)

func (p ShareRelationshipPrivilegeLevel) String() string {
  switch p {
  case ShareRelationshipPrivilegeLevel_READ_NOTEBOOK: return "READ_NOTEBOOK"
  case ShareRelationshipPrivilegeLevel_READ_NOTEBOOK_PLUS_ACTIVITY: return "READ_NOTEBOOK_PLUS_ACTIVITY"
  case ShareRelationshipPrivilegeLevel_MODIFY_NOTEBOOK_PLUS_ACTIVITY: return "MODIFY_NOTEBOOK_PLUS_ACTIVITY"
  case ShareRelationshipPrivilegeLevel_FULL_ACCESS: return "FULL_ACCESS"
  }
  return "<UNSET>"
}

func ShareRelationshipPrivilegeLevelFromString(s string) (ShareRelationshipPrivilegeLevel, error) {
  switch s {
  case "READ_NOTEBOOK": return ShareRelationshipPrivilegeLevel_READ_NOTEBOOK, nil 
  case "READ_NOTEBOOK_PLUS_ACTIVITY": return ShareRelationshipPrivilegeLevel_READ_NOTEBOOK_PLUS_ACTIVITY, nil 
  case "MODIFY_NOTEBOOK_PLUS_ACTIVITY": return ShareRelationshipPrivilegeLevel_MODIFY_NOTEBOOK_PLUS_ACTIVITY, nil 
  case "FULL_ACCESS": return ShareRelationshipPrivilegeLevel_FULL_ACCESS, nil 
  }
  return ShareRelationshipPrivilegeLevel(0), fmt.Errorf("not a valid ShareRelationshipPrivilegeLevel string")
}


func ShareRelationshipPrivilegeLevelPtr(v ShareRelationshipPrivilegeLevel) *ShareRelationshipPrivilegeLevel { return &v }

func (p ShareRelationshipPrivilegeLevel) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ShareRelationshipPrivilegeLevel) UnmarshalText(text []byte) error {
q, err := ShareRelationshipPrivilegeLevelFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ShareRelationshipPrivilegeLevel) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ShareRelationshipPrivilegeLevel(v)
return nil
}

func (p * ShareRelationshipPrivilegeLevel) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// This structure encapsulates the information about the state of the
// user's account for the purpose of "state based" synchronization.
// <dl>
// <dt>currentTime</dt>
//   <dd>
//   The server's current date and time.
//   </dd>
// <dt>fullSyncBefore</dt>
//   <dd>
//   The cutoff date and time for client caches to be
//   updated via incremental synchronization.  Any clients that were last
//   synched with the server before this date/time must do a full resync of all
//   objects.  This cutoff point will change over time as archival data is
//   deleted or special circumstances on the service require resynchronization.
//   </dd>
// <dt>updateCount</dt>
//   <dd>
//   Indicates the total number of transactions that have
//   been committed within the account.  This reflects (for example) the
//   number of discrete additions or modifications that have been made to
//   the data in this account (tags, notes, resources, etc.).
//   This number is the "high water mark" for Update Sequence Numbers (USN)
//   within the account.
//   </dd>
// <dt>uploaded</dt>
//   <dd>
//   The total number of bytes that have been uploaded to
//   this account in the current monthly period.  This can be compared against
//   Accounting.uploadLimit (from the UserStore) to determine how close the user
//   is to their monthly upload limit.
//   This value may not be present if the SyncState has been retrieved by
//   a caller that only has read access to the account.
//   </dd>
// <dt>userLastUpdated</dt>
//   <dd>
//   The last time when a user's account level information was changed. This value
//   is the latest time when a modification was made to any of the following:
//   accounting information (billing, quota, premium status, etc.), user attributes
//   and business user information (business name, business user attributes, etc.) if
//   the user is in a business.
//   Clients who need to maintain account information about a User should watch this
//   field for updates rather than polling UserStore.getUser for updates. Here is the
//   basic flow that clients should follow:
//   <ol>
//     <li>Call NoteStore.getSyncState to retrieve the SyncState object</li>
//     <li>Compare SyncState.userLastUpdated to previously stored value:
//         if (SyncState.userLastUpdated > previousValue)
//           call UserStore.getUser to get the latest User object;
//         else
//           do nothing;</li>
//     <li>Update previousValue = SyncState.userLastUpdated</li>
//   </ol>
//   </dd>
// <dt>userMaxMessageEventId</dt>
//   <dd>
//   The greatest MessageEventID for this user's account. Clients that do a full
//   sync should store this value locally and compare their local copy to the
//   value returned by getSyncState to determine if they need to sync with
//   MessageStore. This value will be omitted if the user has never sent or
//   received a message.
//   </dd>
// </dl>
// 
// Attributes:
//  - CurrentTime
//  - FullSyncBefore
//  - UpdateCount
//  - Uploaded
//  - UserLastUpdated
//  - UserMaxMessageEventId
type SyncState struct {
  CurrentTime Timestamp `thrift:"currentTime,1,required" db:"currentTime" json:"currentTime"`
  FullSyncBefore Timestamp `thrift:"fullSyncBefore,2,required" db:"fullSyncBefore" json:"fullSyncBefore"`
  UpdateCount int32 `thrift:"updateCount,3,required" db:"updateCount" json:"updateCount"`
  Uploaded *int64 `thrift:"uploaded,4" db:"uploaded" json:"uploaded,omitempty"`
  UserLastUpdated *Timestamp `thrift:"userLastUpdated,5" db:"userLastUpdated" json:"userLastUpdated,omitempty"`
  UserMaxMessageEventId *MessageEventID `thrift:"userMaxMessageEventId,6" db:"userMaxMessageEventId" json:"userMaxMessageEventId,omitempty"`
}

func NewSyncState() *SyncState {
  return &SyncState{}
}


func (p *SyncState) GetCurrentTime() Timestamp {
  return p.CurrentTime
}

func (p *SyncState) GetFullSyncBefore() Timestamp {
  return p.FullSyncBefore
}

func (p *SyncState) GetUpdateCount() int32 {
  return p.UpdateCount
}
var SyncState_Uploaded_DEFAULT int64
func (p *SyncState) GetUploaded() int64 {
  if !p.IsSetUploaded() {
    return SyncState_Uploaded_DEFAULT
  }
return *p.Uploaded
}
var SyncState_UserLastUpdated_DEFAULT Timestamp
func (p *SyncState) GetUserLastUpdated() Timestamp {
  if !p.IsSetUserLastUpdated() {
    return SyncState_UserLastUpdated_DEFAULT
  }
return *p.UserLastUpdated
}
var SyncState_UserMaxMessageEventId_DEFAULT MessageEventID
func (p *SyncState) GetUserMaxMessageEventId() MessageEventID {
  if !p.IsSetUserMaxMessageEventId() {
    return SyncState_UserMaxMessageEventId_DEFAULT
  }
return *p.UserMaxMessageEventId
}
func (p *SyncState) IsSetUploaded() bool {
  return p.Uploaded != nil
}

func (p *SyncState) IsSetUserLastUpdated() bool {
  return p.UserLastUpdated != nil
}

func (p *SyncState) IsSetUserMaxMessageEventId() bool {
  return p.UserMaxMessageEventId != nil
}

func (p *SyncState) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCurrentTime bool = false;
  var issetFullSyncBefore bool = false;
  var issetUpdateCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetCurrentTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetFullSyncBefore = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetUpdateCount = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCurrentTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CurrentTime is not set"));
  }
  if !issetFullSyncBefore{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field FullSyncBefore is not set"));
  }
  if !issetUpdateCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UpdateCount is not set"));
  }
  return nil
}

func (p *SyncState)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Timestamp(v)
  p.CurrentTime = temp
}
  return nil
}

func (p *SyncState)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Timestamp(v)
  p.FullSyncBefore = temp
}
  return nil
}

func (p *SyncState)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.UpdateCount = v
}
  return nil
}

func (p *SyncState)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Uploaded = &v
}
  return nil
}

func (p *SyncState)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := Timestamp(v)
  p.UserLastUpdated = &temp
}
  return nil
}

func (p *SyncState)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := MessageEventID(v)
  p.UserMaxMessageEventId = &temp
}
  return nil
}

func (p *SyncState) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SyncState"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SyncState) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "currentTime", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:currentTime: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CurrentTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.currentTime (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:currentTime: ", p), err) }
  return err
}

func (p *SyncState) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "fullSyncBefore", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:fullSyncBefore: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.FullSyncBefore)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.fullSyncBefore (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:fullSyncBefore: ", p), err) }
  return err
}

func (p *SyncState) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateCount", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:updateCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UpdateCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updateCount (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:updateCount: ", p), err) }
  return err
}

func (p *SyncState) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUploaded() {
    if err := oprot.WriteFieldBegin(ctx, "uploaded", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:uploaded: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Uploaded)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.uploaded (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:uploaded: ", p), err) }
  }
  return err
}

func (p *SyncState) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserLastUpdated() {
    if err := oprot.WriteFieldBegin(ctx, "userLastUpdated", thrift.I64, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:userLastUpdated: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.UserLastUpdated)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.userLastUpdated (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:userLastUpdated: ", p), err) }
  }
  return err
}

func (p *SyncState) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserMaxMessageEventId() {
    if err := oprot.WriteFieldBegin(ctx, "userMaxMessageEventId", thrift.I64, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:userMaxMessageEventId: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.UserMaxMessageEventId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.userMaxMessageEventId (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:userMaxMessageEventId: ", p), err) }
  }
  return err
}

func (p *SyncState) Equals(other *SyncState) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.CurrentTime != other.CurrentTime { return false }
  if p.FullSyncBefore != other.FullSyncBefore { return false }
  if p.UpdateCount != other.UpdateCount { return false }
  if p.Uploaded != other.Uploaded {
    if p.Uploaded == nil || other.Uploaded == nil {
      return false
    }
    if (*p.Uploaded) != (*other.Uploaded) { return false }
  }
  if p.UserLastUpdated != other.UserLastUpdated {
    if p.UserLastUpdated == nil || other.UserLastUpdated == nil {
      return false
    }
    if (*p.UserLastUpdated) != (*other.UserLastUpdated) { return false }
  }
  if p.UserMaxMessageEventId != other.UserMaxMessageEventId {
    if p.UserMaxMessageEventId == nil || other.UserMaxMessageEventId == nil {
      return false
    }
    if (*p.UserMaxMessageEventId) != (*other.UserMaxMessageEventId) { return false }
  }
  return true
}

func (p *SyncState) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SyncState(%+v)", *p)
}

//  This structure is given out by the NoteStore when a client asks to
//  receive the current state of an account.  The client asks for the server's
//  state one chunk at a time in order to allow clients to retrieve the state
//  of a large account without needing to transfer the entire account in
//  a single message.
// 
//  The server always gives SyncChunks using an ascending series of Update
//  Sequence Numbers (USNs).
// 
// <dl>
//  <dt>currentTime</dt>
//    <dd>
//    The server's current date and time.
//    </dd>
// 
//  <dt>chunkHighUSN</dt>
//    <dd>
//    The highest USN for any of the data objects represented
//    in this sync chunk.  If there are no objects in the chunk, this will not be
//    set.
//    </dd>
// 
//  <dt>updateCount</dt>
//    <dd>
//    The total number of updates that have been performed in
//    the service for this account.  This is equal to the highest USN within the
//    account at the point that this SyncChunk was generated.  If updateCount
//    and chunkHighUSN are identical, that means that this is the last chunk
//    in the account ... there is no more recent information.
//    </dd>
// 
//  <dt>notes</dt>
//    <dd>
//    If present, this is a list of non-expunged notes that
//    have a USN in this chunk.  This will include notes that are "deleted"
//    but not expunged (i.e. in the trash).  The notes will include their list
//    of tags and resources, but the note content, resource content, resource
//    recognition data and resource alternate data will not be supplied.
//    </dd>
// 
//  <dt>notebooks</dt>
//    <dd>
//    If present, this is a list of non-expunged notebooks that
//    have a USN in this chunk.
//    </dd>
// 
//  <dt>tags</dt>
//    <dd>
//    If present, this is a list of the non-expunged tags that have a
//    USN in this chunk.
//    </dd>
// 
//  <dt>searches</dt>
//    <dd>
//    If present, this is a list of non-expunged searches that
//    have a USN in this chunk.
//    </dd>
// 
//  <dt>resources</dt>
//    <dd>
//    If present, this is a list of the non-expunged resources
//    that have a USN in this chunk.  This will include the metadata for each
//    resource, but not its binary contents or recognition data, which must be
//    retrieved separately.
//    </dd>
// 
//  <dt>expungedNotes</dt>
//    <dd>
//    If present, the GUIDs of all of the notes that were
//    permanently expunged in this chunk.
//    </dd>
// 
//  <dt>expungedNotebooks</dt>
//    <dd>
//    If present, the GUIDs of all of the notebooks that
//    were permanently expunged in this chunk.  When a notebook is expunged,
//    this implies that all of its child notes (and their resources) were
//    also expunged.
//    </dd>
// 
//  <dt>expungedTags</dt>
//    <dd>
//    If present, the GUIDs of all of the tags that were
//    permanently expunged in this chunk.
//    </dd>
// 
//  <dt>expungedSearches</dt>
//    <dd>
//    If present, the GUIDs of all of the saved searches
//    that were permanently expunged in this chunk.
//    </dd>
// 
//  <dt>linkedNotebooks</dt>
//    <dd>
//    If present, this is a list of non-expunged LinkedNotebooks that
//    have a USN in this chunk.
//    </dd>
// 
//  <dt>expungedLinkedNotebooks</dt>
//    <dd>
//    If present, the GUIDs of all of the LinkedNotebooks
//    that were permanently expunged in this chunk.
//    </dd>
// 
// Attributes:
//  - CurrentTime
//  - ChunkHighUSN
//  - UpdateCount
//  - Notes
//  - Notebooks
//  - Tags
//  - Searches
//  - Resources
//  - ExpungedNotes
//  - ExpungedNotebooks
//  - ExpungedTags
//  - ExpungedSearches
//  - LinkedNotebooks
//  - ExpungedLinkedNotebooks
type SyncChunk struct {
  CurrentTime Timestamp `thrift:"currentTime,1,required" db:"currentTime" json:"currentTime"`
  ChunkHighUSN *int32 `thrift:"chunkHighUSN,2" db:"chunkHighUSN" json:"chunkHighUSN,omitempty"`
  UpdateCount int32 `thrift:"updateCount,3,required" db:"updateCount" json:"updateCount"`
  Notes []*Note `thrift:"notes,4" db:"notes" json:"notes,omitempty"`
  Notebooks []*Notebook `thrift:"notebooks,5" db:"notebooks" json:"notebooks,omitempty"`
  Tags []*Tag `thrift:"tags,6" db:"tags" json:"tags,omitempty"`
  Searches []*SavedSearch `thrift:"searches,7" db:"searches" json:"searches,omitempty"`
  Resources []*Resource `thrift:"resources,8" db:"resources" json:"resources,omitempty"`
  ExpungedNotes []GUID `thrift:"expungedNotes,9" db:"expungedNotes" json:"expungedNotes,omitempty"`
  ExpungedNotebooks []GUID `thrift:"expungedNotebooks,10" db:"expungedNotebooks" json:"expungedNotebooks,omitempty"`
  ExpungedTags []GUID `thrift:"expungedTags,11" db:"expungedTags" json:"expungedTags,omitempty"`
  ExpungedSearches []GUID `thrift:"expungedSearches,12" db:"expungedSearches" json:"expungedSearches,omitempty"`
  LinkedNotebooks []*LinkedNotebook `thrift:"linkedNotebooks,13" db:"linkedNotebooks" json:"linkedNotebooks,omitempty"`
  ExpungedLinkedNotebooks []GUID `thrift:"expungedLinkedNotebooks,14" db:"expungedLinkedNotebooks" json:"expungedLinkedNotebooks,omitempty"`
}

func NewSyncChunk() *SyncChunk {
  return &SyncChunk{}
}


func (p *SyncChunk) GetCurrentTime() Timestamp {
  return p.CurrentTime
}
var SyncChunk_ChunkHighUSN_DEFAULT int32
func (p *SyncChunk) GetChunkHighUSN() int32 {
  if !p.IsSetChunkHighUSN() {
    return SyncChunk_ChunkHighUSN_DEFAULT
  }
return *p.ChunkHighUSN
}

func (p *SyncChunk) GetUpdateCount() int32 {
  return p.UpdateCount
}
var SyncChunk_Notes_DEFAULT []*Note

func (p *SyncChunk) GetNotes() []*Note {
  return p.Notes
}
var SyncChunk_Notebooks_DEFAULT []*Notebook

func (p *SyncChunk) GetNotebooks() []*Notebook {
  return p.Notebooks
}
var SyncChunk_Tags_DEFAULT []*Tag

func (p *SyncChunk) GetTags() []*Tag {
  return p.Tags
}
var SyncChunk_Searches_DEFAULT []*SavedSearch

func (p *SyncChunk) GetSearches() []*SavedSearch {
  return p.Searches
}
var SyncChunk_Resources_DEFAULT []*Resource

func (p *SyncChunk) GetResources() []*Resource {
  return p.Resources
}
var SyncChunk_ExpungedNotes_DEFAULT []GUID

func (p *SyncChunk) GetExpungedNotes() []GUID {
  return p.ExpungedNotes
}
var SyncChunk_ExpungedNotebooks_DEFAULT []GUID

func (p *SyncChunk) GetExpungedNotebooks() []GUID {
  return p.ExpungedNotebooks
}
var SyncChunk_ExpungedTags_DEFAULT []GUID

func (p *SyncChunk) GetExpungedTags() []GUID {
  return p.ExpungedTags
}
var SyncChunk_ExpungedSearches_DEFAULT []GUID

func (p *SyncChunk) GetExpungedSearches() []GUID {
  return p.ExpungedSearches
}
var SyncChunk_LinkedNotebooks_DEFAULT []*LinkedNotebook

func (p *SyncChunk) GetLinkedNotebooks() []*LinkedNotebook {
  return p.LinkedNotebooks
}
var SyncChunk_ExpungedLinkedNotebooks_DEFAULT []GUID

func (p *SyncChunk) GetExpungedLinkedNotebooks() []GUID {
  return p.ExpungedLinkedNotebooks
}
func (p *SyncChunk) IsSetChunkHighUSN() bool {
  return p.ChunkHighUSN != nil
}

func (p *SyncChunk) IsSetNotes() bool {
  return p.Notes != nil
}

func (p *SyncChunk) IsSetNotebooks() bool {
  return p.Notebooks != nil
}

func (p *SyncChunk) IsSetTags() bool {
  return p.Tags != nil
}

func (p *SyncChunk) IsSetSearches() bool {
  return p.Searches != nil
}

func (p *SyncChunk) IsSetResources() bool {
  return p.Resources != nil
}

func (p *SyncChunk) IsSetExpungedNotes() bool {
  return p.ExpungedNotes != nil
}

func (p *SyncChunk) IsSetExpungedNotebooks() bool {
  return p.ExpungedNotebooks != nil
}

func (p *SyncChunk) IsSetExpungedTags() bool {
  return p.ExpungedTags != nil
}

func (p *SyncChunk) IsSetExpungedSearches() bool {
  return p.ExpungedSearches != nil
}

func (p *SyncChunk) IsSetLinkedNotebooks() bool {
  return p.LinkedNotebooks != nil
}

func (p *SyncChunk) IsSetExpungedLinkedNotebooks() bool {
  return p.ExpungedLinkedNotebooks != nil
}

func (p *SyncChunk) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCurrentTime bool = false;
  var issetUpdateCount bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetCurrentTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetUpdateCount = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCurrentTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CurrentTime is not set"));
  }
  if !issetUpdateCount{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UpdateCount is not set"));
  }
  return nil
}

func (p *SyncChunk)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Timestamp(v)
  p.CurrentTime = temp
}
  return nil
}

func (p *SyncChunk)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ChunkHighUSN = &v
}
  return nil
}

func (p *SyncChunk)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.UpdateCount = v
}
  return nil
}

func (p *SyncChunk)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Note, 0, size)
  p.Notes =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &Note{}
    if err := _elem0.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.Notes = append(p.Notes, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Notebook, 0, size)
  p.Notebooks =  tSlice
  for i := 0; i < size; i ++ {
    _elem1 := &Notebook{}
    if err := _elem1.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem1), err)
    }
    p.Notebooks = append(p.Notebooks, _elem1)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Tag, 0, size)
  p.Tags =  tSlice
  for i := 0; i < size; i ++ {
    _elem2 := &Tag{}
    if err := _elem2.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
    }
    p.Tags = append(p.Tags, _elem2)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SavedSearch, 0, size)
  p.Searches =  tSlice
  for i := 0; i < size; i ++ {
    _elem3 := &SavedSearch{}
    if err := _elem3.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem3), err)
    }
    p.Searches = append(p.Searches, _elem3)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Resource, 0, size)
  p.Resources =  tSlice
  for i := 0; i < size; i ++ {
    _elem4 := &Resource{}
    if err := _elem4.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
    }
    p.Resources = append(p.Resources, _elem4)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.ExpungedNotes =  tSlice
  for i := 0; i < size; i ++ {
var _elem5 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem5 = temp
}
    p.ExpungedNotes = append(p.ExpungedNotes, _elem5)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.ExpungedNotebooks =  tSlice
  for i := 0; i < size; i ++ {
var _elem6 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem6 = temp
}
    p.ExpungedNotebooks = append(p.ExpungedNotebooks, _elem6)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.ExpungedTags =  tSlice
  for i := 0; i < size; i ++ {
var _elem7 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem7 = temp
}
    p.ExpungedTags = append(p.ExpungedTags, _elem7)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.ExpungedSearches =  tSlice
  for i := 0; i < size; i ++ {
var _elem8 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem8 = temp
}
    p.ExpungedSearches = append(p.ExpungedSearches, _elem8)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*LinkedNotebook, 0, size)
  p.LinkedNotebooks =  tSlice
  for i := 0; i < size; i ++ {
    _elem9 := &LinkedNotebook{}
    if err := _elem9.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
    }
    p.LinkedNotebooks = append(p.LinkedNotebooks, _elem9)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.ExpungedLinkedNotebooks =  tSlice
  for i := 0; i < size; i ++ {
var _elem10 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem10 = temp
}
    p.ExpungedLinkedNotebooks = append(p.ExpungedLinkedNotebooks, _elem10)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SyncChunk) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SyncChunk"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SyncChunk) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "currentTime", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:currentTime: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CurrentTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.currentTime (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:currentTime: ", p), err) }
  return err
}

func (p *SyncChunk) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetChunkHighUSN() {
    if err := oprot.WriteFieldBegin(ctx, "chunkHighUSN", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:chunkHighUSN: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ChunkHighUSN)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.chunkHighUSN (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:chunkHighUSN: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateCount", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:updateCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UpdateCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updateCount (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:updateCount: ", p), err) }
  return err
}

func (p *SyncChunk) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotes() {
    if err := oprot.WriteFieldBegin(ctx, "notes", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:notes: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Notes)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Notes {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:notes: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "notebooks", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:notebooks: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Notebooks)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Notebooks {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:notebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTags() {
    if err := oprot.WriteFieldBegin(ctx, "tags", thrift.LIST, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tags: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tags)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Tags {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tags: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSearches() {
    if err := oprot.WriteFieldBegin(ctx, "searches", thrift.LIST, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:searches: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Searches)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Searches {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:searches: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetResources() {
    if err := oprot.WriteFieldBegin(ctx, "resources", thrift.LIST, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:resources: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Resources)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Resources {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:resources: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpungedNotes() {
    if err := oprot.WriteFieldBegin(ctx, "expungedNotes", thrift.LIST, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:expungedNotes: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ExpungedNotes)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ExpungedNotes {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:expungedNotes: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpungedNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "expungedNotebooks", thrift.LIST, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:expungedNotebooks: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ExpungedNotebooks)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ExpungedNotebooks {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:expungedNotebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpungedTags() {
    if err := oprot.WriteFieldBegin(ctx, "expungedTags", thrift.LIST, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:expungedTags: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ExpungedTags)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ExpungedTags {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:expungedTags: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpungedSearches() {
    if err := oprot.WriteFieldBegin(ctx, "expungedSearches", thrift.LIST, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:expungedSearches: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ExpungedSearches)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ExpungedSearches {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:expungedSearches: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLinkedNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "linkedNotebooks", thrift.LIST, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:linkedNotebooks: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.LinkedNotebooks)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.LinkedNotebooks {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:linkedNotebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunk) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExpungedLinkedNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "expungedLinkedNotebooks", thrift.LIST, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:expungedLinkedNotebooks: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ExpungedLinkedNotebooks)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ExpungedLinkedNotebooks {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:expungedLinkedNotebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunk) Equals(other *SyncChunk) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.CurrentTime != other.CurrentTime { return false }
  if p.ChunkHighUSN != other.ChunkHighUSN {
    if p.ChunkHighUSN == nil || other.ChunkHighUSN == nil {
      return false
    }
    if (*p.ChunkHighUSN) != (*other.ChunkHighUSN) { return false }
  }
  if p.UpdateCount != other.UpdateCount { return false }
  if len(p.Notes) != len(other.Notes) { return false }
  for i, _tgt := range p.Notes {
    _src11 := other.Notes[i]
    if !_tgt.Equals(_src11) { return false }
  }
  if len(p.Notebooks) != len(other.Notebooks) { return false }
  for i, _tgt := range p.Notebooks {
    _src12 := other.Notebooks[i]
    if !_tgt.Equals(_src12) { return false }
  }
  if len(p.Tags) != len(other.Tags) { return false }
  for i, _tgt := range p.Tags {
    _src13 := other.Tags[i]
    if !_tgt.Equals(_src13) { return false }
  }
  if len(p.Searches) != len(other.Searches) { return false }
  for i, _tgt := range p.Searches {
    _src14 := other.Searches[i]
    if !_tgt.Equals(_src14) { return false }
  }
  if len(p.Resources) != len(other.Resources) { return false }
  for i, _tgt := range p.Resources {
    _src15 := other.Resources[i]
    if !_tgt.Equals(_src15) { return false }
  }
  if len(p.ExpungedNotes) != len(other.ExpungedNotes) { return false }
  for i, _tgt := range p.ExpungedNotes {
    _src16 := other.ExpungedNotes[i]
    if _tgt != _src16 { return false }
  }
  if len(p.ExpungedNotebooks) != len(other.ExpungedNotebooks) { return false }
  for i, _tgt := range p.ExpungedNotebooks {
    _src17 := other.ExpungedNotebooks[i]
    if _tgt != _src17 { return false }
  }
  if len(p.ExpungedTags) != len(other.ExpungedTags) { return false }
  for i, _tgt := range p.ExpungedTags {
    _src18 := other.ExpungedTags[i]
    if _tgt != _src18 { return false }
  }
  if len(p.ExpungedSearches) != len(other.ExpungedSearches) { return false }
  for i, _tgt := range p.ExpungedSearches {
    _src19 := other.ExpungedSearches[i]
    if _tgt != _src19 { return false }
  }
  if len(p.LinkedNotebooks) != len(other.LinkedNotebooks) { return false }
  for i, _tgt := range p.LinkedNotebooks {
    _src20 := other.LinkedNotebooks[i]
    if !_tgt.Equals(_src20) { return false }
  }
  if len(p.ExpungedLinkedNotebooks) != len(other.ExpungedLinkedNotebooks) { return false }
  for i, _tgt := range p.ExpungedLinkedNotebooks {
    _src21 := other.ExpungedLinkedNotebooks[i]
    if _tgt != _src21 { return false }
  }
  return true
}

func (p *SyncChunk) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SyncChunk(%+v)", *p)
}

//  This structure is used with the 'getFilteredSyncChunk' call to provide
//  fine-grained control over the data that's returned when a client needs
//  to synchronize with the service. Each flag in this structure specifies
//  whether to include one class of data in the results of that call.
// 
// <dl>
//  <dt>includeNotes</dt>
//    <dd>
//    If true, then the server will include the SyncChunks.notes field
//    </dd>
// 
//  <dt>includeNoteResources</dt>
//    <dd>
//    If true, then the server will include the 'resources' field on all of
//    the Notes that are in SyncChunk.notes.
//    If 'includeNotes' is false, then this will have no effect.
//    </dd>
// 
//  <dt>includeNoteAttributes</dt>
//    <dd>
//    If true, then the server will include the 'attributes' field on all of
//    the Notes that are in SyncChunks.notes.
//    If 'includeNotes' is false, then this will have no effect.
//    </dd>
// 
//  <dt>includeNotebooks</dt>
//    <dd>
//    If true, then the server will include the SyncChunks.notebooks field
//    </dd>
// 
//  <dt>includeTags</dt>
//    <dd>
//    If true, then the server will include the SyncChunks.tags field
//    </dd>
// 
//  <dt>includeSearches</dt>
//    <dd>
//    If true, then the server will include the SyncChunks.searches field
//    </dd>
// 
//  <dt>includeResources</dt>
//    <dd>
//    If true, then the server will include the SyncChunks.resources field.
//    Since the Resources are also provided with their Note
//    (in the Notes.resources list), this is primarily useful for clients that
//    want to watch for changes to individual Resources due to recognition data
//    being added.
//    </dd>
// 
//  <dt>includeLinkedNotebooks</dt>
//    <dd>
//    If true, then the server will include the SyncChunks.linkedNotebooks field.
//    </dd>
// 
//  <dt>includeExpunged</dt>
//    <dd>
//    If true, then the server will include the 'expunged' data for any type
//    of included data.  For example, if 'includeTags' and 'includeExpunged'
//    are both true, then the SyncChunks.expungedTags field will be set with
//    the GUIDs of tags that have been expunged from the server.
//    </dd>
// 
//  <dt>includeNoteApplicationDataFullMap</dt>
//    <dd>
//    If true, then the values for the applicationData map will be filled
//    in, assuming notes and note attributes are being returned.  Otherwise,
//    only the keysOnly field will be filled in.
//    </dd>
// 
//  <dt>includeResourceApplicationDataFullMap</dt>
//    <dd>
//    If true, then the fullMap values for the applicationData map will be
//    filled in, assuming resources and resource attributes are being returned
//    (includeResources is true).  Otherwise, only the keysOnly field will be
//    filled in.
//    </dd>
// 
//  <dt>includeNoteResourceApplicationDataFullMap</dt>
//    <dd>
//    If true, then the fullMap values for the applicationData map will be
//    filled in for resources found inside of notes, assuming resources are
//    being returned in notes (includeNoteResources is true).  Otherwise,
//    only the keysOnly field will be filled in.
//    </dd>
// 
//  <dt>omitSharedNotebooks<dt>
//    <dd>
//    Normally, if 'includeNotebooks' is true, then the SyncChunks will
//    include Notebooks that may include a set of SharedNotebook
//    invitations via Notebook.sharedNotebookIds and Notebook.sharedNotebooks.
//    However, if omitSharedNotebooks is set to true, then the Notebooks
//    will omit those two fields and leave them unset. This should be used
//    by clients who want to know their own set of Notebooks (and the
//    associated permissions via Notebook.recipientSettings), and who
//    do not need to know the full set of other people who can also see
//    that same notebook.
//    </dd>
// 
//  <dt>requireNoteContentClass</dt>
//    <dd>
//    If set, then only send notes whose content class matches this value.
//    The value can be a literal match or, if the last character is an
//    asterisk, a prefix match.
//    </dd>
// 
//  <dt>notebookGuids</dt>
//    <dd>
//    If set, then restrict the returned notebooks, notes, and
//    resources to those associated with one of the notebooks whose
//    GUID is provided in this list.  If not set, then no filtering on
//    notebook GUID will be performed.  If you set this field, you may
//    not also set includeExpunged else an EDAMUserException with an
//    error code of DATA_CONFLICT will be thrown.  You only need to set
//    this field if you want to restrict the returned entities more
//    than what your authentication token allows you to access.  For
//    example, there is no need to set this field for single notebook
//    tokens such as for shared notebooks.  You can use this field to
//    synchronize a newly discovered business notebook while
//    incrementally synchronizing a business account, in which case you
//    will only need to consider setting includeNotes,
//    includeNotebooks, includeNoteAttributes, includeNoteResources,
//    and maybe some of the "FullMap" fields.
//    </dd>
// 
//  <dt>includeSharedNotes</dt>
//    <dd>
//    If true, then the service will include the sharedNotes field on all
//    notes that are in SyncChunk.notes. If 'includeNotes' is false, then
//    this will have no effect.
//    </dd>
//  </dl>
// 
// Attributes:
//  - IncludeNotes
//  - IncludeNoteResources
//  - IncludeNoteAttributes
//  - IncludeNotebooks
//  - IncludeTags
//  - IncludeSearches
//  - IncludeResources
//  - IncludeLinkedNotebooks
//  - IncludeExpunged
//  - IncludeNoteApplicationDataFullMap
//  - IncludeResourceApplicationDataFullMap
//  - IncludeNoteResourceApplicationDataFullMap
//  - IncludeSharedNotes
//  - OmitSharedNotebooks
//  - RequireNoteContentClass
//  - NotebookGuids
type SyncChunkFilter struct {
  IncludeNotes *bool `thrift:"includeNotes,1" db:"includeNotes" json:"includeNotes,omitempty"`
  IncludeNoteResources *bool `thrift:"includeNoteResources,2" db:"includeNoteResources" json:"includeNoteResources,omitempty"`
  IncludeNoteAttributes *bool `thrift:"includeNoteAttributes,3" db:"includeNoteAttributes" json:"includeNoteAttributes,omitempty"`
  IncludeNotebooks *bool `thrift:"includeNotebooks,4" db:"includeNotebooks" json:"includeNotebooks,omitempty"`
  IncludeTags *bool `thrift:"includeTags,5" db:"includeTags" json:"includeTags,omitempty"`
  IncludeSearches *bool `thrift:"includeSearches,6" db:"includeSearches" json:"includeSearches,omitempty"`
  IncludeResources *bool `thrift:"includeResources,7" db:"includeResources" json:"includeResources,omitempty"`
  IncludeLinkedNotebooks *bool `thrift:"includeLinkedNotebooks,8" db:"includeLinkedNotebooks" json:"includeLinkedNotebooks,omitempty"`
  IncludeExpunged *bool `thrift:"includeExpunged,9" db:"includeExpunged" json:"includeExpunged,omitempty"`
  IncludeNoteApplicationDataFullMap *bool `thrift:"includeNoteApplicationDataFullMap,10" db:"includeNoteApplicationDataFullMap" json:"includeNoteApplicationDataFullMap,omitempty"`
  RequireNoteContentClass *string `thrift:"requireNoteContentClass,11" db:"requireNoteContentClass" json:"requireNoteContentClass,omitempty"`
  IncludeResourceApplicationDataFullMap *bool `thrift:"includeResourceApplicationDataFullMap,12" db:"includeResourceApplicationDataFullMap" json:"includeResourceApplicationDataFullMap,omitempty"`
  IncludeNoteResourceApplicationDataFullMap *bool `thrift:"includeNoteResourceApplicationDataFullMap,13" db:"includeNoteResourceApplicationDataFullMap" json:"includeNoteResourceApplicationDataFullMap,omitempty"`
  // unused field # 14
  NotebookGuids []string `thrift:"notebookGuids,15" db:"notebookGuids" json:"notebookGuids,omitempty"`
  OmitSharedNotebooks *bool `thrift:"omitSharedNotebooks,16" db:"omitSharedNotebooks" json:"omitSharedNotebooks,omitempty"`
  IncludeSharedNotes *bool `thrift:"includeSharedNotes,17" db:"includeSharedNotes" json:"includeSharedNotes,omitempty"`
}

func NewSyncChunkFilter() *SyncChunkFilter {
  return &SyncChunkFilter{}
}

var SyncChunkFilter_IncludeNotes_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeNotes() bool {
  if !p.IsSetIncludeNotes() {
    return SyncChunkFilter_IncludeNotes_DEFAULT
  }
return *p.IncludeNotes
}
var SyncChunkFilter_IncludeNoteResources_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeNoteResources() bool {
  if !p.IsSetIncludeNoteResources() {
    return SyncChunkFilter_IncludeNoteResources_DEFAULT
  }
return *p.IncludeNoteResources
}
var SyncChunkFilter_IncludeNoteAttributes_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeNoteAttributes() bool {
  if !p.IsSetIncludeNoteAttributes() {
    return SyncChunkFilter_IncludeNoteAttributes_DEFAULT
  }
return *p.IncludeNoteAttributes
}
var SyncChunkFilter_IncludeNotebooks_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeNotebooks() bool {
  if !p.IsSetIncludeNotebooks() {
    return SyncChunkFilter_IncludeNotebooks_DEFAULT
  }
return *p.IncludeNotebooks
}
var SyncChunkFilter_IncludeTags_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeTags() bool {
  if !p.IsSetIncludeTags() {
    return SyncChunkFilter_IncludeTags_DEFAULT
  }
return *p.IncludeTags
}
var SyncChunkFilter_IncludeSearches_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeSearches() bool {
  if !p.IsSetIncludeSearches() {
    return SyncChunkFilter_IncludeSearches_DEFAULT
  }
return *p.IncludeSearches
}
var SyncChunkFilter_IncludeResources_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeResources() bool {
  if !p.IsSetIncludeResources() {
    return SyncChunkFilter_IncludeResources_DEFAULT
  }
return *p.IncludeResources
}
var SyncChunkFilter_IncludeLinkedNotebooks_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeLinkedNotebooks() bool {
  if !p.IsSetIncludeLinkedNotebooks() {
    return SyncChunkFilter_IncludeLinkedNotebooks_DEFAULT
  }
return *p.IncludeLinkedNotebooks
}
var SyncChunkFilter_IncludeExpunged_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeExpunged() bool {
  if !p.IsSetIncludeExpunged() {
    return SyncChunkFilter_IncludeExpunged_DEFAULT
  }
return *p.IncludeExpunged
}
var SyncChunkFilter_IncludeNoteApplicationDataFullMap_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeNoteApplicationDataFullMap() bool {
  if !p.IsSetIncludeNoteApplicationDataFullMap() {
    return SyncChunkFilter_IncludeNoteApplicationDataFullMap_DEFAULT
  }
return *p.IncludeNoteApplicationDataFullMap
}
var SyncChunkFilter_IncludeResourceApplicationDataFullMap_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeResourceApplicationDataFullMap() bool {
  if !p.IsSetIncludeResourceApplicationDataFullMap() {
    return SyncChunkFilter_IncludeResourceApplicationDataFullMap_DEFAULT
  }
return *p.IncludeResourceApplicationDataFullMap
}
var SyncChunkFilter_IncludeNoteResourceApplicationDataFullMap_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeNoteResourceApplicationDataFullMap() bool {
  if !p.IsSetIncludeNoteResourceApplicationDataFullMap() {
    return SyncChunkFilter_IncludeNoteResourceApplicationDataFullMap_DEFAULT
  }
return *p.IncludeNoteResourceApplicationDataFullMap
}
var SyncChunkFilter_IncludeSharedNotes_DEFAULT bool
func (p *SyncChunkFilter) GetIncludeSharedNotes() bool {
  if !p.IsSetIncludeSharedNotes() {
    return SyncChunkFilter_IncludeSharedNotes_DEFAULT
  }
return *p.IncludeSharedNotes
}
var SyncChunkFilter_OmitSharedNotebooks_DEFAULT bool
func (p *SyncChunkFilter) GetOmitSharedNotebooks() bool {
  if !p.IsSetOmitSharedNotebooks() {
    return SyncChunkFilter_OmitSharedNotebooks_DEFAULT
  }
return *p.OmitSharedNotebooks
}
var SyncChunkFilter_RequireNoteContentClass_DEFAULT string
func (p *SyncChunkFilter) GetRequireNoteContentClass() string {
  if !p.IsSetRequireNoteContentClass() {
    return SyncChunkFilter_RequireNoteContentClass_DEFAULT
  }
return *p.RequireNoteContentClass
}
var SyncChunkFilter_NotebookGuids_DEFAULT []string

func (p *SyncChunkFilter) GetNotebookGuids() []string {
  return p.NotebookGuids
}
func (p *SyncChunkFilter) IsSetIncludeNotes() bool {
  return p.IncludeNotes != nil
}

func (p *SyncChunkFilter) IsSetIncludeNoteResources() bool {
  return p.IncludeNoteResources != nil
}

func (p *SyncChunkFilter) IsSetIncludeNoteAttributes() bool {
  return p.IncludeNoteAttributes != nil
}

func (p *SyncChunkFilter) IsSetIncludeNotebooks() bool {
  return p.IncludeNotebooks != nil
}

func (p *SyncChunkFilter) IsSetIncludeTags() bool {
  return p.IncludeTags != nil
}

func (p *SyncChunkFilter) IsSetIncludeSearches() bool {
  return p.IncludeSearches != nil
}

func (p *SyncChunkFilter) IsSetIncludeResources() bool {
  return p.IncludeResources != nil
}

func (p *SyncChunkFilter) IsSetIncludeLinkedNotebooks() bool {
  return p.IncludeLinkedNotebooks != nil
}

func (p *SyncChunkFilter) IsSetIncludeExpunged() bool {
  return p.IncludeExpunged != nil
}

func (p *SyncChunkFilter) IsSetIncludeNoteApplicationDataFullMap() bool {
  return p.IncludeNoteApplicationDataFullMap != nil
}

func (p *SyncChunkFilter) IsSetIncludeResourceApplicationDataFullMap() bool {
  return p.IncludeResourceApplicationDataFullMap != nil
}

func (p *SyncChunkFilter) IsSetIncludeNoteResourceApplicationDataFullMap() bool {
  return p.IncludeNoteResourceApplicationDataFullMap != nil
}

func (p *SyncChunkFilter) IsSetIncludeSharedNotes() bool {
  return p.IncludeSharedNotes != nil
}

func (p *SyncChunkFilter) IsSetOmitSharedNotebooks() bool {
  return p.OmitSharedNotebooks != nil
}

func (p *SyncChunkFilter) IsSetRequireNoteContentClass() bool {
  return p.RequireNoteContentClass != nil
}

func (p *SyncChunkFilter) IsSetNotebookGuids() bool {
  return p.NotebookGuids != nil
}

func (p *SyncChunkFilter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField16(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SyncChunkFilter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.IncludeNotes = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IncludeNoteResources = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.IncludeNoteAttributes = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.IncludeNotebooks = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.IncludeTags = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.IncludeSearches = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.IncludeResources = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.IncludeLinkedNotebooks = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.IncludeExpunged = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.IncludeNoteApplicationDataFullMap = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.IncludeResourceApplicationDataFullMap = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.IncludeNoteResourceApplicationDataFullMap = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 17: ", err)
} else {
  p.IncludeSharedNotes = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 16: ", err)
} else {
  p.OmitSharedNotebooks = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.RequireNoteContentClass = &v
}
  return nil
}

func (p *SyncChunkFilter)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.NotebookGuids =  tSet
  for i := 0; i < size; i ++ {
var _elem22 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem22 = v
}
    p.NotebookGuids = append(p.NotebookGuids, _elem22)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *SyncChunkFilter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SyncChunkFilter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
    if err := p.writeField16(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SyncChunkFilter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNotes() {
    if err := oprot.WriteFieldBegin(ctx, "includeNotes", thrift.BOOL, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:includeNotes: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNotes)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNotes (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:includeNotes: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNoteResources() {
    if err := oprot.WriteFieldBegin(ctx, "includeNoteResources", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeNoteResources: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNoteResources)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNoteResources (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeNoteResources: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNoteAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "includeNoteAttributes", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:includeNoteAttributes: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNoteAttributes)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNoteAttributes (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:includeNoteAttributes: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "includeNotebooks", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:includeNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNotebooks (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:includeNotebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeTags() {
    if err := oprot.WriteFieldBegin(ctx, "includeTags", thrift.BOOL, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:includeTags: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeTags)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeTags (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:includeTags: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeSearches() {
    if err := oprot.WriteFieldBegin(ctx, "includeSearches", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:includeSearches: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeSearches)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeSearches (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:includeSearches: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeResources() {
    if err := oprot.WriteFieldBegin(ctx, "includeResources", thrift.BOOL, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:includeResources: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeResources)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeResources (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:includeResources: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeLinkedNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "includeLinkedNotebooks", thrift.BOOL, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:includeLinkedNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeLinkedNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeLinkedNotebooks (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:includeLinkedNotebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeExpunged() {
    if err := oprot.WriteFieldBegin(ctx, "includeExpunged", thrift.BOOL, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:includeExpunged: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeExpunged)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeExpunged (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:includeExpunged: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNoteApplicationDataFullMap() {
    if err := oprot.WriteFieldBegin(ctx, "includeNoteApplicationDataFullMap", thrift.BOOL, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:includeNoteApplicationDataFullMap: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNoteApplicationDataFullMap)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNoteApplicationDataFullMap (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:includeNoteApplicationDataFullMap: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRequireNoteContentClass() {
    if err := oprot.WriteFieldBegin(ctx, "requireNoteContentClass", thrift.STRING, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:requireNoteContentClass: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.RequireNoteContentClass)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.requireNoteContentClass (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:requireNoteContentClass: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeResourceApplicationDataFullMap() {
    if err := oprot.WriteFieldBegin(ctx, "includeResourceApplicationDataFullMap", thrift.BOOL, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:includeResourceApplicationDataFullMap: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeResourceApplicationDataFullMap)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeResourceApplicationDataFullMap (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:includeResourceApplicationDataFullMap: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNoteResourceApplicationDataFullMap() {
    if err := oprot.WriteFieldBegin(ctx, "includeNoteResourceApplicationDataFullMap", thrift.BOOL, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:includeNoteResourceApplicationDataFullMap: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNoteResourceApplicationDataFullMap)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNoteResourceApplicationDataFullMap (13) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:includeNoteResourceApplicationDataFullMap: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebookGuids() {
    if err := oprot.WriteFieldBegin(ctx, "notebookGuids", thrift.SET, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:notebookGuids: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.NotebookGuids)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.NotebookGuids); i++ {
      for j := i+1; j<len(p.NotebookGuids); j++ {
        if func(tgt, src string) bool {
          if tgt != src { return false }
          return true
        }(p.NotebookGuids[i], p.NotebookGuids[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.NotebookGuids))
        }
      }
    }
    for _, v := range p.NotebookGuids {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:notebookGuids: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOmitSharedNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "omitSharedNotebooks", thrift.BOOL, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:omitSharedNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.OmitSharedNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.omitSharedNotebooks (16) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:omitSharedNotebooks: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeSharedNotes() {
    if err := oprot.WriteFieldBegin(ctx, "includeSharedNotes", thrift.BOOL, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:includeSharedNotes: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeSharedNotes)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeSharedNotes (17) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:includeSharedNotes: ", p), err) }
  }
  return err
}

func (p *SyncChunkFilter) Equals(other *SyncChunkFilter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IncludeNotes != other.IncludeNotes {
    if p.IncludeNotes == nil || other.IncludeNotes == nil {
      return false
    }
    if (*p.IncludeNotes) != (*other.IncludeNotes) { return false }
  }
  if p.IncludeNoteResources != other.IncludeNoteResources {
    if p.IncludeNoteResources == nil || other.IncludeNoteResources == nil {
      return false
    }
    if (*p.IncludeNoteResources) != (*other.IncludeNoteResources) { return false }
  }
  if p.IncludeNoteAttributes != other.IncludeNoteAttributes {
    if p.IncludeNoteAttributes == nil || other.IncludeNoteAttributes == nil {
      return false
    }
    if (*p.IncludeNoteAttributes) != (*other.IncludeNoteAttributes) { return false }
  }
  if p.IncludeNotebooks != other.IncludeNotebooks {
    if p.IncludeNotebooks == nil || other.IncludeNotebooks == nil {
      return false
    }
    if (*p.IncludeNotebooks) != (*other.IncludeNotebooks) { return false }
  }
  if p.IncludeTags != other.IncludeTags {
    if p.IncludeTags == nil || other.IncludeTags == nil {
      return false
    }
    if (*p.IncludeTags) != (*other.IncludeTags) { return false }
  }
  if p.IncludeSearches != other.IncludeSearches {
    if p.IncludeSearches == nil || other.IncludeSearches == nil {
      return false
    }
    if (*p.IncludeSearches) != (*other.IncludeSearches) { return false }
  }
  if p.IncludeResources != other.IncludeResources {
    if p.IncludeResources == nil || other.IncludeResources == nil {
      return false
    }
    if (*p.IncludeResources) != (*other.IncludeResources) { return false }
  }
  if p.IncludeLinkedNotebooks != other.IncludeLinkedNotebooks {
    if p.IncludeLinkedNotebooks == nil || other.IncludeLinkedNotebooks == nil {
      return false
    }
    if (*p.IncludeLinkedNotebooks) != (*other.IncludeLinkedNotebooks) { return false }
  }
  if p.IncludeExpunged != other.IncludeExpunged {
    if p.IncludeExpunged == nil || other.IncludeExpunged == nil {
      return false
    }
    if (*p.IncludeExpunged) != (*other.IncludeExpunged) { return false }
  }
  if p.IncludeNoteApplicationDataFullMap != other.IncludeNoteApplicationDataFullMap {
    if p.IncludeNoteApplicationDataFullMap == nil || other.IncludeNoteApplicationDataFullMap == nil {
      return false
    }
    if (*p.IncludeNoteApplicationDataFullMap) != (*other.IncludeNoteApplicationDataFullMap) { return false }
  }
  if p.RequireNoteContentClass != other.RequireNoteContentClass {
    if p.RequireNoteContentClass == nil || other.RequireNoteContentClass == nil {
      return false
    }
    if (*p.RequireNoteContentClass) != (*other.RequireNoteContentClass) { return false }
  }
  if p.IncludeResourceApplicationDataFullMap != other.IncludeResourceApplicationDataFullMap {
    if p.IncludeResourceApplicationDataFullMap == nil || other.IncludeResourceApplicationDataFullMap == nil {
      return false
    }
    if (*p.IncludeResourceApplicationDataFullMap) != (*other.IncludeResourceApplicationDataFullMap) { return false }
  }
  if p.IncludeNoteResourceApplicationDataFullMap != other.IncludeNoteResourceApplicationDataFullMap {
    if p.IncludeNoteResourceApplicationDataFullMap == nil || other.IncludeNoteResourceApplicationDataFullMap == nil {
      return false
    }
    if (*p.IncludeNoteResourceApplicationDataFullMap) != (*other.IncludeNoteResourceApplicationDataFullMap) { return false }
  }
  if len(p.NotebookGuids) != len(other.NotebookGuids) { return false }
  for i, _tgt := range p.NotebookGuids {
    _src23 := other.NotebookGuids[i]
    if _tgt != _src23 { return false }
  }
  if p.OmitSharedNotebooks != other.OmitSharedNotebooks {
    if p.OmitSharedNotebooks == nil || other.OmitSharedNotebooks == nil {
      return false
    }
    if (*p.OmitSharedNotebooks) != (*other.OmitSharedNotebooks) { return false }
  }
  if p.IncludeSharedNotes != other.IncludeSharedNotes {
    if p.IncludeSharedNotes == nil || other.IncludeSharedNotes == nil {
      return false
    }
    if (*p.IncludeSharedNotes) != (*other.IncludeSharedNotes) { return false }
  }
  return true
}

func (p *SyncChunkFilter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SyncChunkFilter(%+v)", *p)
}

//  A list of criteria that are used to indicate which notes are desired from
//  the account.  This is used in queries to the NoteStore to determine
//  which notes should be retrieved.
// 
// <dl>
//  <dt>order</dt>
//    <dd>
//    The NoteSortOrder value indicating what criterion should be
//    used to sort the results of the filter.
//    </dd>
// 
//  <dt>ascending</dt>
//    <dd>
//    If true, the results will be ascending in the requested
//    sort order.  If false, the results will be descending.
//    </dd>
// 
//  <dt>words</dt>
//    <dd>
//    If present, a search query string that will filter the set of notes to be returned.
//    Accepts the full search grammar documented in the Evernote API Overview.
//    </dd>
// 
//  <dt>notebookGuid</dt>
//    <dd>
//    If present, the Guid of the notebook that must contain
//    the notes.
//    </dd>
// 
//  <dt>tagGuids</dt>
//    <dd>
//    If present, the list of tags (by GUID) that must be present
//    on the notes.
//    </dd>
// 
//  <dt>timeZone</dt>
//    <dd>
//    The zone ID for the user, which will be used to interpret
//    any dates or times in the queries that do not include their desired zone
//    information.
//    For example, if a query requests notes created "yesterday", this
//    will be evaluated from the provided time zone, if provided.
//    The format must be encoded as a standard zone ID such as
//    "America/Los_Angeles".
//    </dd>
// 
//  <dt>inactive</dt>
//    <dd>
//    If true, then only notes that are not active (i.e. notes in
//    the Trash) will be returned. Otherwise, only active notes will be returned.
//    There is no way to find both active and inactive notes in a single query.
//    </dd>
// 
//  <dt>emphasized</dt>
//    <dd>
//    If present, a search query string that may or may not influence the notes
//    to be returned, both in terms of coverage as well as of order. Think of it
//    as a wish list, not a requirement.
//    Accepts the full search grammar documented in the Evernote API Overview.
//    </dd>
// 
//  <dt>includeAllReadableNotebooks</dt>
//    <dd>
//    If true, then the search will include all business notebooks that are readable
//    by the user. A business authentication token must be supplied for
//    this option to take effect when calling search APIs.
//    </dd>
// 
//  <dt>includeAllReadableWorkspaces</dt>
//    <dd>
//    If true, then the search will include all workspaces that are readable
//    by the user. A business authentication token must be supplied for
//    this option to take effect when calling search APIs.
//    </dd>
// 
//  <dt>context</dt>
//    <dd>
//    Specifies the context to consider when determining result ranking.
//    Clients must leave this value unset unless they wish to explicitly specify a known
//    non-default context.
//    </dd>
// 
//  <dt>rawWords</dt>
//    <dd>
//    If present, the raw user query input.
//    Accepts the full search grammar documented in the Evernote API Overview.
//    </dd>
// 
//  <dt>searchContextBytes</dt>
//    <dd>
//    Specifies the correlating information about the current search session, in byte array.
//    If this request is not for the first page of search results, the client should populate
//    this field with the value of searchContextBytes from the NotesMetadataList of the
//    original search response.
//    </dd>
//  </dl>
// 
// Attributes:
//  - Order
//  - Ascending
//  - Words
//  - NotebookGuid
//  - TagGuids
//  - TimeZone
//  - Inactive
//  - Emphasized
//  - IncludeAllReadableNotebooks
//  - IncludeAllReadableWorkspaces
//  - Context
//  - RawWords
//  - SearchContextBytes
type NoteFilter struct {
  Order *int32 `thrift:"order,1" db:"order" json:"order,omitempty"`
  Ascending *bool `thrift:"ascending,2" db:"ascending" json:"ascending,omitempty"`
  Words *string `thrift:"words,3" db:"words" json:"words,omitempty"`
  NotebookGuid *GUID `thrift:"notebookGuid,4" db:"notebookGuid" json:"notebookGuid,omitempty"`
  TagGuids []GUID `thrift:"tagGuids,5" db:"tagGuids" json:"tagGuids,omitempty"`
  TimeZone *string `thrift:"timeZone,6" db:"timeZone" json:"timeZone,omitempty"`
  Inactive *bool `thrift:"inactive,7" db:"inactive" json:"inactive,omitempty"`
  Emphasized *string `thrift:"emphasized,8" db:"emphasized" json:"emphasized,omitempty"`
  IncludeAllReadableNotebooks *bool `thrift:"includeAllReadableNotebooks,9" db:"includeAllReadableNotebooks" json:"includeAllReadableNotebooks,omitempty"`
  Context *string `thrift:"context,10" db:"context" json:"context,omitempty"`
  RawWords *string `thrift:"rawWords,11" db:"rawWords" json:"rawWords,omitempty"`
  SearchContextBytes []byte `thrift:"searchContextBytes,12" db:"searchContextBytes" json:"searchContextBytes,omitempty"`
  // unused fields # 13 to 14
  IncludeAllReadableWorkspaces *bool `thrift:"includeAllReadableWorkspaces,15" db:"includeAllReadableWorkspaces" json:"includeAllReadableWorkspaces,omitempty"`
}

func NewNoteFilter() *NoteFilter {
  return &NoteFilter{}
}

var NoteFilter_Order_DEFAULT int32
func (p *NoteFilter) GetOrder() int32 {
  if !p.IsSetOrder() {
    return NoteFilter_Order_DEFAULT
  }
return *p.Order
}
var NoteFilter_Ascending_DEFAULT bool
func (p *NoteFilter) GetAscending() bool {
  if !p.IsSetAscending() {
    return NoteFilter_Ascending_DEFAULT
  }
return *p.Ascending
}
var NoteFilter_Words_DEFAULT string
func (p *NoteFilter) GetWords() string {
  if !p.IsSetWords() {
    return NoteFilter_Words_DEFAULT
  }
return *p.Words
}
var NoteFilter_NotebookGuid_DEFAULT GUID
func (p *NoteFilter) GetNotebookGuid() GUID {
  if !p.IsSetNotebookGuid() {
    return NoteFilter_NotebookGuid_DEFAULT
  }
return *p.NotebookGuid
}
var NoteFilter_TagGuids_DEFAULT []GUID

func (p *NoteFilter) GetTagGuids() []GUID {
  return p.TagGuids
}
var NoteFilter_TimeZone_DEFAULT string
func (p *NoteFilter) GetTimeZone() string {
  if !p.IsSetTimeZone() {
    return NoteFilter_TimeZone_DEFAULT
  }
return *p.TimeZone
}
var NoteFilter_Inactive_DEFAULT bool
func (p *NoteFilter) GetInactive() bool {
  if !p.IsSetInactive() {
    return NoteFilter_Inactive_DEFAULT
  }
return *p.Inactive
}
var NoteFilter_Emphasized_DEFAULT string
func (p *NoteFilter) GetEmphasized() string {
  if !p.IsSetEmphasized() {
    return NoteFilter_Emphasized_DEFAULT
  }
return *p.Emphasized
}
var NoteFilter_IncludeAllReadableNotebooks_DEFAULT bool
func (p *NoteFilter) GetIncludeAllReadableNotebooks() bool {
  if !p.IsSetIncludeAllReadableNotebooks() {
    return NoteFilter_IncludeAllReadableNotebooks_DEFAULT
  }
return *p.IncludeAllReadableNotebooks
}
var NoteFilter_IncludeAllReadableWorkspaces_DEFAULT bool
func (p *NoteFilter) GetIncludeAllReadableWorkspaces() bool {
  if !p.IsSetIncludeAllReadableWorkspaces() {
    return NoteFilter_IncludeAllReadableWorkspaces_DEFAULT
  }
return *p.IncludeAllReadableWorkspaces
}
var NoteFilter_Context_DEFAULT string
func (p *NoteFilter) GetContext() string {
  if !p.IsSetContext() {
    return NoteFilter_Context_DEFAULT
  }
return *p.Context
}
var NoteFilter_RawWords_DEFAULT string
func (p *NoteFilter) GetRawWords() string {
  if !p.IsSetRawWords() {
    return NoteFilter_RawWords_DEFAULT
  }
return *p.RawWords
}
var NoteFilter_SearchContextBytes_DEFAULT []byte

func (p *NoteFilter) GetSearchContextBytes() []byte {
  return p.SearchContextBytes
}
func (p *NoteFilter) IsSetOrder() bool {
  return p.Order != nil
}

func (p *NoteFilter) IsSetAscending() bool {
  return p.Ascending != nil
}

func (p *NoteFilter) IsSetWords() bool {
  return p.Words != nil
}

func (p *NoteFilter) IsSetNotebookGuid() bool {
  return p.NotebookGuid != nil
}

func (p *NoteFilter) IsSetTagGuids() bool {
  return p.TagGuids != nil
}

func (p *NoteFilter) IsSetTimeZone() bool {
  return p.TimeZone != nil
}

func (p *NoteFilter) IsSetInactive() bool {
  return p.Inactive != nil
}

func (p *NoteFilter) IsSetEmphasized() bool {
  return p.Emphasized != nil
}

func (p *NoteFilter) IsSetIncludeAllReadableNotebooks() bool {
  return p.IncludeAllReadableNotebooks != nil
}

func (p *NoteFilter) IsSetIncludeAllReadableWorkspaces() bool {
  return p.IncludeAllReadableWorkspaces != nil
}

func (p *NoteFilter) IsSetContext() bool {
  return p.Context != nil
}

func (p *NoteFilter) IsSetRawWords() bool {
  return p.RawWords != nil
}

func (p *NoteFilter) IsSetSearchContextBytes() bool {
  return p.SearchContextBytes != nil
}

func (p *NoteFilter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteFilter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Order = &v
}
  return nil
}

func (p *NoteFilter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ascending = &v
}
  return nil
}

func (p *NoteFilter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Words = &v
}
  return nil
}

func (p *NoteFilter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := GUID(v)
  p.NotebookGuid = &temp
}
  return nil
}

func (p *NoteFilter)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.TagGuids =  tSlice
  for i := 0; i < size; i ++ {
var _elem24 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem24 = temp
}
    p.TagGuids = append(p.TagGuids, _elem24)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteFilter)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.TimeZone = &v
}
  return nil
}

func (p *NoteFilter)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.Inactive = &v
}
  return nil
}

func (p *NoteFilter)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.Emphasized = &v
}
  return nil
}

func (p *NoteFilter)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.IncludeAllReadableNotebooks = &v
}
  return nil
}

func (p *NoteFilter)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 15: ", err)
} else {
  p.IncludeAllReadableWorkspaces = &v
}
  return nil
}

func (p *NoteFilter)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.Context = &v
}
  return nil
}

func (p *NoteFilter)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.RawWords = &v
}
  return nil
}

func (p *NoteFilter)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.SearchContextBytes = v
}
  return nil
}

func (p *NoteFilter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteFilter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteFilter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOrder() {
    if err := oprot.WriteFieldBegin(ctx, "order", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:order: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Order)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.order (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:order: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAscending() {
    if err := oprot.WriteFieldBegin(ctx, "ascending", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ascending: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Ascending)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ascending (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ascending: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetWords() {
    if err := oprot.WriteFieldBegin(ctx, "words", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:words: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Words)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.words (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:words: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebookGuid() {
    if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:notebookGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NotebookGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:notebookGuid: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTagGuids() {
    if err := oprot.WriteFieldBegin(ctx, "tagGuids", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:tagGuids: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.TagGuids)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.TagGuids {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:tagGuids: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTimeZone() {
    if err := oprot.WriteFieldBegin(ctx, "timeZone", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:timeZone: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.TimeZone)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.timeZone (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:timeZone: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInactive() {
    if err := oprot.WriteFieldBegin(ctx, "inactive", thrift.BOOL, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:inactive: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Inactive)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.inactive (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:inactive: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEmphasized() {
    if err := oprot.WriteFieldBegin(ctx, "emphasized", thrift.STRING, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:emphasized: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Emphasized)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.emphasized (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:emphasized: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeAllReadableNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "includeAllReadableNotebooks", thrift.BOOL, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:includeAllReadableNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeAllReadableNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeAllReadableNotebooks (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:includeAllReadableNotebooks: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetContext() {
    if err := oprot.WriteFieldBegin(ctx, "context", thrift.STRING, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:context: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Context)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.context (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:context: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRawWords() {
    if err := oprot.WriteFieldBegin(ctx, "rawWords", thrift.STRING, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:rawWords: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.RawWords)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.rawWords (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:rawWords: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSearchContextBytes() {
    if err := oprot.WriteFieldBegin(ctx, "searchContextBytes", thrift.STRING, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:searchContextBytes: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.SearchContextBytes); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.searchContextBytes (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:searchContextBytes: ", p), err) }
  }
  return err
}

func (p *NoteFilter) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeAllReadableWorkspaces() {
    if err := oprot.WriteFieldBegin(ctx, "includeAllReadableWorkspaces", thrift.BOOL, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:includeAllReadableWorkspaces: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeAllReadableWorkspaces)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeAllReadableWorkspaces (15) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:includeAllReadableWorkspaces: ", p), err) }
  }
  return err
}

func (p *NoteFilter) Equals(other *NoteFilter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Order != other.Order {
    if p.Order == nil || other.Order == nil {
      return false
    }
    if (*p.Order) != (*other.Order) { return false }
  }
  if p.Ascending != other.Ascending {
    if p.Ascending == nil || other.Ascending == nil {
      return false
    }
    if (*p.Ascending) != (*other.Ascending) { return false }
  }
  if p.Words != other.Words {
    if p.Words == nil || other.Words == nil {
      return false
    }
    if (*p.Words) != (*other.Words) { return false }
  }
  if p.NotebookGuid != other.NotebookGuid {
    if p.NotebookGuid == nil || other.NotebookGuid == nil {
      return false
    }
    if (*p.NotebookGuid) != (*other.NotebookGuid) { return false }
  }
  if len(p.TagGuids) != len(other.TagGuids) { return false }
  for i, _tgt := range p.TagGuids {
    _src25 := other.TagGuids[i]
    if _tgt != _src25 { return false }
  }
  if p.TimeZone != other.TimeZone {
    if p.TimeZone == nil || other.TimeZone == nil {
      return false
    }
    if (*p.TimeZone) != (*other.TimeZone) { return false }
  }
  if p.Inactive != other.Inactive {
    if p.Inactive == nil || other.Inactive == nil {
      return false
    }
    if (*p.Inactive) != (*other.Inactive) { return false }
  }
  if p.Emphasized != other.Emphasized {
    if p.Emphasized == nil || other.Emphasized == nil {
      return false
    }
    if (*p.Emphasized) != (*other.Emphasized) { return false }
  }
  if p.IncludeAllReadableNotebooks != other.IncludeAllReadableNotebooks {
    if p.IncludeAllReadableNotebooks == nil || other.IncludeAllReadableNotebooks == nil {
      return false
    }
    if (*p.IncludeAllReadableNotebooks) != (*other.IncludeAllReadableNotebooks) { return false }
  }
  if p.Context != other.Context {
    if p.Context == nil || other.Context == nil {
      return false
    }
    if (*p.Context) != (*other.Context) { return false }
  }
  if p.RawWords != other.RawWords {
    if p.RawWords == nil || other.RawWords == nil {
      return false
    }
    if (*p.RawWords) != (*other.RawWords) { return false }
  }
  if bytes.Compare(p.SearchContextBytes, other.SearchContextBytes) != 0 { return false }
  if p.IncludeAllReadableWorkspaces != other.IncludeAllReadableWorkspaces {
    if p.IncludeAllReadableWorkspaces == nil || other.IncludeAllReadableWorkspaces == nil {
      return false
    }
    if (*p.IncludeAllReadableWorkspaces) != (*other.IncludeAllReadableWorkspaces) { return false }
  }
  return true
}

func (p *NoteFilter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteFilter(%+v)", *p)
}

//  A small structure for returning a list of notes out of a larger set.
// 
// <dl>
//  <dt>startIndex</dt>
//    <dd>
//    The starting index within the overall set of notes.  This
//    is also the number of notes that are "before" this list in the set.
//    </dd>
// 
//  <dt>totalNotes</dt>
//    <dd>
//    The number of notes in the larger set.  This can be used
//    to calculate how many notes are "after" this note in the set.
//    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
//    </dd>
// 
//  <dt>notes</dt>
//    <dd>
//    The list of notes from this range.  The Notes will include all
//    metadata (attributes, resources, etc.), but will not include the ENML
//    content of the note or the binary contents of any resources.
//    </dd>
// 
//  <dt>stoppedWords</dt>
//    <dd>
//    If the NoteList was produced using a text based search
//    query that included words that are not indexed or searched by the service,
//    this will include a list of those ignored words.
//    </dd>
// 
//  <dt>searchedWords</dt>
//    <dd>
//    If the NoteList was produced using a text based search
//    query that included viable search words or quoted expressions, this will
//    include a list of those words.  Any stopped words will not be included
//    in this list.
//    </dd>
// 
//  <dt>updateCount</dt>
//    <dd>
//    Indicates the total number of transactions that have
//    been committed within the account.  This reflects (for example) the
//    number of discrete additions or modifications that have been made to
//    the data in this account (tags, notes, resources, etc.).
//    This number is the "high water mark" for Update Sequence Numbers (USN)
//    within the account.
//    </dd>
// 
//  <dt>searchContextBytes</dt>
//    <dd>
//    Specifies the correlating information about the current search session, in byte array.
//    </dd>
//  </dl>
// 
//  <dt>debugInfo</dt>
//    <dd>
//    Depends on the value of <code>context</code> in NoteFilter, this field
//    may contain debug information if the service decides to do so.
//    </dd>
// 
// 
// Attributes:
//  - StartIndex
//  - TotalNotes
//  - Notes
//  - StoppedWords
//  - SearchedWords
//  - UpdateCount
//  - SearchContextBytes
//  - DebugInfo
type NoteList struct {
  StartIndex int32 `thrift:"startIndex,1,required" db:"startIndex" json:"startIndex"`
  TotalNotes int32 `thrift:"totalNotes,2,required" db:"totalNotes" json:"totalNotes"`
  Notes []*Note `thrift:"notes,3,required" db:"notes" json:"notes"`
  StoppedWords []string `thrift:"stoppedWords,4" db:"stoppedWords" json:"stoppedWords,omitempty"`
  SearchedWords []string `thrift:"searchedWords,5" db:"searchedWords" json:"searchedWords,omitempty"`
  UpdateCount *int32 `thrift:"updateCount,6" db:"updateCount" json:"updateCount,omitempty"`
  SearchContextBytes []byte `thrift:"searchContextBytes,7" db:"searchContextBytes" json:"searchContextBytes,omitempty"`
  DebugInfo *string `thrift:"debugInfo,8" db:"debugInfo" json:"debugInfo,omitempty"`
}

func NewNoteList() *NoteList {
  return &NoteList{}
}


func (p *NoteList) GetStartIndex() int32 {
  return p.StartIndex
}

func (p *NoteList) GetTotalNotes() int32 {
  return p.TotalNotes
}

func (p *NoteList) GetNotes() []*Note {
  return p.Notes
}
var NoteList_StoppedWords_DEFAULT []string

func (p *NoteList) GetStoppedWords() []string {
  return p.StoppedWords
}
var NoteList_SearchedWords_DEFAULT []string

func (p *NoteList) GetSearchedWords() []string {
  return p.SearchedWords
}
var NoteList_UpdateCount_DEFAULT int32
func (p *NoteList) GetUpdateCount() int32 {
  if !p.IsSetUpdateCount() {
    return NoteList_UpdateCount_DEFAULT
  }
return *p.UpdateCount
}
var NoteList_SearchContextBytes_DEFAULT []byte

func (p *NoteList) GetSearchContextBytes() []byte {
  return p.SearchContextBytes
}
var NoteList_DebugInfo_DEFAULT string
func (p *NoteList) GetDebugInfo() string {
  if !p.IsSetDebugInfo() {
    return NoteList_DebugInfo_DEFAULT
  }
return *p.DebugInfo
}
func (p *NoteList) IsSetStoppedWords() bool {
  return p.StoppedWords != nil
}

func (p *NoteList) IsSetSearchedWords() bool {
  return p.SearchedWords != nil
}

func (p *NoteList) IsSetUpdateCount() bool {
  return p.UpdateCount != nil
}

func (p *NoteList) IsSetSearchContextBytes() bool {
  return p.SearchContextBytes != nil
}

func (p *NoteList) IsSetDebugInfo() bool {
  return p.DebugInfo != nil
}

func (p *NoteList) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStartIndex bool = false;
  var issetTotalNotes bool = false;
  var issetNotes bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetStartIndex = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTotalNotes = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetNotes = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStartIndex{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartIndex is not set"));
  }
  if !issetTotalNotes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TotalNotes is not set"));
  }
  if !issetNotes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Notes is not set"));
  }
  return nil
}

func (p *NoteList)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartIndex = v
}
  return nil
}

func (p *NoteList)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TotalNotes = v
}
  return nil
}

func (p *NoteList)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Note, 0, size)
  p.Notes =  tSlice
  for i := 0; i < size; i ++ {
    _elem26 := &Note{}
    if err := _elem26.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem26), err)
    }
    p.Notes = append(p.Notes, _elem26)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteList)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.StoppedWords =  tSlice
  for i := 0; i < size; i ++ {
var _elem27 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem27 = v
}
    p.StoppedWords = append(p.StoppedWords, _elem27)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteList)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.SearchedWords =  tSlice
  for i := 0; i < size; i ++ {
var _elem28 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem28 = v
}
    p.SearchedWords = append(p.SearchedWords, _elem28)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteList)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.UpdateCount = &v
}
  return nil
}

func (p *NoteList)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.SearchContextBytes = v
}
  return nil
}

func (p *NoteList)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.DebugInfo = &v
}
  return nil
}

func (p *NoteList) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteList"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteList) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "startIndex", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startIndex: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.StartIndex)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.startIndex (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startIndex: ", p), err) }
  return err
}

func (p *NoteList) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "totalNotes", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:totalNotes: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.TotalNotes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.totalNotes (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:totalNotes: ", p), err) }
  return err
}

func (p *NoteList) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notes", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notes: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Notes)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Notes {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notes: ", p), err) }
  return err
}

func (p *NoteList) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStoppedWords() {
    if err := oprot.WriteFieldBegin(ctx, "stoppedWords", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:stoppedWords: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.StoppedWords)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.StoppedWords {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:stoppedWords: ", p), err) }
  }
  return err
}

func (p *NoteList) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSearchedWords() {
    if err := oprot.WriteFieldBegin(ctx, "searchedWords", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:searchedWords: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.SearchedWords)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.SearchedWords {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:searchedWords: ", p), err) }
  }
  return err
}

func (p *NoteList) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateCount() {
    if err := oprot.WriteFieldBegin(ctx, "updateCount", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:updateCount: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.UpdateCount)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.updateCount (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:updateCount: ", p), err) }
  }
  return err
}

func (p *NoteList) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSearchContextBytes() {
    if err := oprot.WriteFieldBegin(ctx, "searchContextBytes", thrift.STRING, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:searchContextBytes: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.SearchContextBytes); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.searchContextBytes (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:searchContextBytes: ", p), err) }
  }
  return err
}

func (p *NoteList) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDebugInfo() {
    if err := oprot.WriteFieldBegin(ctx, "debugInfo", thrift.STRING, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:debugInfo: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DebugInfo)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.debugInfo (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:debugInfo: ", p), err) }
  }
  return err
}

func (p *NoteList) Equals(other *NoteList) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.StartIndex != other.StartIndex { return false }
  if p.TotalNotes != other.TotalNotes { return false }
  if len(p.Notes) != len(other.Notes) { return false }
  for i, _tgt := range p.Notes {
    _src29 := other.Notes[i]
    if !_tgt.Equals(_src29) { return false }
  }
  if len(p.StoppedWords) != len(other.StoppedWords) { return false }
  for i, _tgt := range p.StoppedWords {
    _src30 := other.StoppedWords[i]
    if _tgt != _src30 { return false }
  }
  if len(p.SearchedWords) != len(other.SearchedWords) { return false }
  for i, _tgt := range p.SearchedWords {
    _src31 := other.SearchedWords[i]
    if _tgt != _src31 { return false }
  }
  if p.UpdateCount != other.UpdateCount {
    if p.UpdateCount == nil || other.UpdateCount == nil {
      return false
    }
    if (*p.UpdateCount) != (*other.UpdateCount) { return false }
  }
  if bytes.Compare(p.SearchContextBytes, other.SearchContextBytes) != 0 { return false }
  if p.DebugInfo != other.DebugInfo {
    if p.DebugInfo == nil || other.DebugInfo == nil {
      return false
    }
    if (*p.DebugInfo) != (*other.DebugInfo) { return false }
  }
  return true
}

func (p *NoteList) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteList(%+v)", *p)
}

// This structure is used in the set of results returned by the
// findNotesMetadata function.  It represents the high-level information about
// a single Note, without some of the larger deep structure.  This allows
// for the information about a list of Notes to be returned relatively quickly
// with less marshalling and data transfer to remote clients.
// Most fields in this structure are identical to the corresponding field in
// the Note structure, with the exception of:
// 
// <dl>
// <dt>largestResourceMime</dt>
//   <dd>If set, then this will contain the MIME type of the largest Resource
//   (in bytes) within the Note.  This may be useful, for example, to choose
//   an appropriate icon or thumbnail to represent the Note.
//   </dd>
// 
// <dt>largestResourceSize</dt>
//  <dd>If set, this will contain the size of the largest Resource file, in
//  bytes, within the Note.  This may be useful, for example, to decide whether
//  to ask the server for a thumbnail to represent the Note.
//  </dd>
// </dl>
// 
// Attributes:
//  - GUID
//  - Title
//  - ContentLength
//  - Created
//  - Updated
//  - Deleted
//  - UpdateSequenceNum
//  - NotebookGuid
//  - TagGuids
//  - Attributes
//  - LargestResourceMime
//  - LargestResourceSize
type NoteMetadata struct {
  GUID GUID `thrift:"guid,1,required" db:"guid" json:"guid"`
  Title *string `thrift:"title,2" db:"title" json:"title,omitempty"`
  // unused fields # 3 to 4
  ContentLength *int32 `thrift:"contentLength,5" db:"contentLength" json:"contentLength,omitempty"`
  Created *Timestamp `thrift:"created,6" db:"created" json:"created,omitempty"`
  Updated *Timestamp `thrift:"updated,7" db:"updated" json:"updated,omitempty"`
  Deleted *Timestamp `thrift:"deleted,8" db:"deleted" json:"deleted,omitempty"`
  // unused field # 9
  UpdateSequenceNum *int32 `thrift:"updateSequenceNum,10" db:"updateSequenceNum" json:"updateSequenceNum,omitempty"`
  NotebookGuid *string `thrift:"notebookGuid,11" db:"notebookGuid" json:"notebookGuid,omitempty"`
  TagGuids []GUID `thrift:"tagGuids,12" db:"tagGuids" json:"tagGuids,omitempty"`
  // unused field # 13
  Attributes *NoteAttributes `thrift:"attributes,14" db:"attributes" json:"attributes,omitempty"`
  // unused fields # 15 to 19
  LargestResourceMime *string `thrift:"largestResourceMime,20" db:"largestResourceMime" json:"largestResourceMime,omitempty"`
  LargestResourceSize *int32 `thrift:"largestResourceSize,21" db:"largestResourceSize" json:"largestResourceSize,omitempty"`
}

func NewNoteMetadata() *NoteMetadata {
  return &NoteMetadata{}
}


func (p *NoteMetadata) GetGUID() GUID {
  return p.GUID
}
var NoteMetadata_Title_DEFAULT string
func (p *NoteMetadata) GetTitle() string {
  if !p.IsSetTitle() {
    return NoteMetadata_Title_DEFAULT
  }
return *p.Title
}
var NoteMetadata_ContentLength_DEFAULT int32
func (p *NoteMetadata) GetContentLength() int32 {
  if !p.IsSetContentLength() {
    return NoteMetadata_ContentLength_DEFAULT
  }
return *p.ContentLength
}
var NoteMetadata_Created_DEFAULT Timestamp
func (p *NoteMetadata) GetCreated() Timestamp {
  if !p.IsSetCreated() {
    return NoteMetadata_Created_DEFAULT
  }
return *p.Created
}
var NoteMetadata_Updated_DEFAULT Timestamp
func (p *NoteMetadata) GetUpdated() Timestamp {
  if !p.IsSetUpdated() {
    return NoteMetadata_Updated_DEFAULT
  }
return *p.Updated
}
var NoteMetadata_Deleted_DEFAULT Timestamp
func (p *NoteMetadata) GetDeleted() Timestamp {
  if !p.IsSetDeleted() {
    return NoteMetadata_Deleted_DEFAULT
  }
return *p.Deleted
}
var NoteMetadata_UpdateSequenceNum_DEFAULT int32
func (p *NoteMetadata) GetUpdateSequenceNum() int32 {
  if !p.IsSetUpdateSequenceNum() {
    return NoteMetadata_UpdateSequenceNum_DEFAULT
  }
return *p.UpdateSequenceNum
}
var NoteMetadata_NotebookGuid_DEFAULT string
func (p *NoteMetadata) GetNotebookGuid() string {
  if !p.IsSetNotebookGuid() {
    return NoteMetadata_NotebookGuid_DEFAULT
  }
return *p.NotebookGuid
}
var NoteMetadata_TagGuids_DEFAULT []GUID

func (p *NoteMetadata) GetTagGuids() []GUID {
  return p.TagGuids
}
var NoteMetadata_Attributes_DEFAULT *NoteAttributes
func (p *NoteMetadata) GetAttributes() *NoteAttributes {
  if !p.IsSetAttributes() {
    return NoteMetadata_Attributes_DEFAULT
  }
return p.Attributes
}
var NoteMetadata_LargestResourceMime_DEFAULT string
func (p *NoteMetadata) GetLargestResourceMime() string {
  if !p.IsSetLargestResourceMime() {
    return NoteMetadata_LargestResourceMime_DEFAULT
  }
return *p.LargestResourceMime
}
var NoteMetadata_LargestResourceSize_DEFAULT int32
func (p *NoteMetadata) GetLargestResourceSize() int32 {
  if !p.IsSetLargestResourceSize() {
    return NoteMetadata_LargestResourceSize_DEFAULT
  }
return *p.LargestResourceSize
}
func (p *NoteMetadata) IsSetTitle() bool {
  return p.Title != nil
}

func (p *NoteMetadata) IsSetContentLength() bool {
  return p.ContentLength != nil
}

func (p *NoteMetadata) IsSetCreated() bool {
  return p.Created != nil
}

func (p *NoteMetadata) IsSetUpdated() bool {
  return p.Updated != nil
}

func (p *NoteMetadata) IsSetDeleted() bool {
  return p.Deleted != nil
}

func (p *NoteMetadata) IsSetUpdateSequenceNum() bool {
  return p.UpdateSequenceNum != nil
}

func (p *NoteMetadata) IsSetNotebookGuid() bool {
  return p.NotebookGuid != nil
}

func (p *NoteMetadata) IsSetTagGuids() bool {
  return p.TagGuids != nil
}

func (p *NoteMetadata) IsSetAttributes() bool {
  return p.Attributes != nil
}

func (p *NoteMetadata) IsSetLargestResourceMime() bool {
  return p.LargestResourceMime != nil
}

func (p *NoteMetadata) IsSetLargestResourceSize() bool {
  return p.LargestResourceSize != nil
}

func (p *NoteMetadata) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetGUID bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetGUID = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 20:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField20(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 21:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField21(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetGUID{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field GUID is not set"));
  }
  return nil
}

func (p *NoteMetadata)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteMetadata)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Title = &v
}
  return nil
}

func (p *NoteMetadata)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.ContentLength = &v
}
  return nil
}

func (p *NoteMetadata)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := Timestamp(v)
  p.Created = &temp
}
  return nil
}

func (p *NoteMetadata)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  temp := Timestamp(v)
  p.Updated = &temp
}
  return nil
}

func (p *NoteMetadata)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  temp := Timestamp(v)
  p.Deleted = &temp
}
  return nil
}

func (p *NoteMetadata)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.UpdateSequenceNum = &v
}
  return nil
}

func (p *NoteMetadata)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.NotebookGuid = &v
}
  return nil
}

func (p *NoteMetadata)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]GUID, 0, size)
  p.TagGuids =  tSlice
  for i := 0; i < size; i ++ {
var _elem32 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _elem32 = temp
}
    p.TagGuids = append(p.TagGuids, _elem32)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteMetadata)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  p.Attributes = &NoteAttributes{}
  if err := p.Attributes.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Attributes), err)
  }
  return nil
}

func (p *NoteMetadata)  ReadField20(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 20: ", err)
} else {
  p.LargestResourceMime = &v
}
  return nil
}

func (p *NoteMetadata)  ReadField21(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 21: ", err)
} else {
  p.LargestResourceSize = &v
}
  return nil
}

func (p *NoteMetadata) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteMetadata"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField20(ctx, oprot); err != nil { return err }
    if err := p.writeField21(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteMetadata) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:guid: ", p), err) }
  return err
}

func (p *NoteMetadata) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTitle() {
    if err := oprot.WriteFieldBegin(ctx, "title", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:title: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Title)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.title (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:title: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetContentLength() {
    if err := oprot.WriteFieldBegin(ctx, "contentLength", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:contentLength: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ContentLength)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.contentLength (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:contentLength: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCreated() {
    if err := oprot.WriteFieldBegin(ctx, "created", thrift.I64, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:created: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Created)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.created (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:created: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdated() {
    if err := oprot.WriteFieldBegin(ctx, "updated", thrift.I64, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:updated: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Updated)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.updated (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:updated: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDeleted() {
    if err := oprot.WriteFieldBegin(ctx, "deleted", thrift.I64, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:deleted: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Deleted)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.deleted (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:deleted: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateSequenceNum() {
    if err := oprot.WriteFieldBegin(ctx, "updateSequenceNum", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:updateSequenceNum: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.UpdateSequenceNum)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.updateSequenceNum (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:updateSequenceNum: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebookGuid() {
    if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:notebookGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NotebookGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:notebookGuid: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTagGuids() {
    if err := oprot.WriteFieldBegin(ctx, "tagGuids", thrift.LIST, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:tagGuids: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.TagGuids)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.TagGuids {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:tagGuids: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.STRUCT, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:attributes: ", p), err) }
    if err := p.Attributes.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Attributes), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:attributes: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField20(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLargestResourceMime() {
    if err := oprot.WriteFieldBegin(ctx, "largestResourceMime", thrift.STRING, 20); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:largestResourceMime: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.LargestResourceMime)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.largestResourceMime (20) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 20:largestResourceMime: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) writeField21(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLargestResourceSize() {
    if err := oprot.WriteFieldBegin(ctx, "largestResourceSize", thrift.I32, 21); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 21:largestResourceSize: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.LargestResourceSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.largestResourceSize (21) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 21:largestResourceSize: ", p), err) }
  }
  return err
}

func (p *NoteMetadata) Equals(other *NoteMetadata) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.GUID != other.GUID { return false }
  if p.Title != other.Title {
    if p.Title == nil || other.Title == nil {
      return false
    }
    if (*p.Title) != (*other.Title) { return false }
  }
  if p.ContentLength != other.ContentLength {
    if p.ContentLength == nil || other.ContentLength == nil {
      return false
    }
    if (*p.ContentLength) != (*other.ContentLength) { return false }
  }
  if p.Created != other.Created {
    if p.Created == nil || other.Created == nil {
      return false
    }
    if (*p.Created) != (*other.Created) { return false }
  }
  if p.Updated != other.Updated {
    if p.Updated == nil || other.Updated == nil {
      return false
    }
    if (*p.Updated) != (*other.Updated) { return false }
  }
  if p.Deleted != other.Deleted {
    if p.Deleted == nil || other.Deleted == nil {
      return false
    }
    if (*p.Deleted) != (*other.Deleted) { return false }
  }
  if p.UpdateSequenceNum != other.UpdateSequenceNum {
    if p.UpdateSequenceNum == nil || other.UpdateSequenceNum == nil {
      return false
    }
    if (*p.UpdateSequenceNum) != (*other.UpdateSequenceNum) { return false }
  }
  if p.NotebookGuid != other.NotebookGuid {
    if p.NotebookGuid == nil || other.NotebookGuid == nil {
      return false
    }
    if (*p.NotebookGuid) != (*other.NotebookGuid) { return false }
  }
  if len(p.TagGuids) != len(other.TagGuids) { return false }
  for i, _tgt := range p.TagGuids {
    _src33 := other.TagGuids[i]
    if _tgt != _src33 { return false }
  }
  if !p.Attributes.Equals(other.Attributes) { return false }
  if p.LargestResourceMime != other.LargestResourceMime {
    if p.LargestResourceMime == nil || other.LargestResourceMime == nil {
      return false
    }
    if (*p.LargestResourceMime) != (*other.LargestResourceMime) { return false }
  }
  if p.LargestResourceSize != other.LargestResourceSize {
    if p.LargestResourceSize == nil || other.LargestResourceSize == nil {
      return false
    }
    if (*p.LargestResourceSize) != (*other.LargestResourceSize) { return false }
  }
  return true
}

func (p *NoteMetadata) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteMetadata(%+v)", *p)
}

//  This structure is returned from calls to the findNotesMetadata function to
//  give the high-level metadata about a subset of Notes that are found to
//  match a specified NoteFilter in a search.
// 
// <dl>
//  <dt>startIndex</dt>
//    <dd>
//    The starting index within the overall set of notes.  This
//    is also the number of notes that are "before" this list in the set.
//    </dd>
// 
//  <dt>totalNotes</dt>
//    <dd>
//    The number of notes in the larger set.  This can be used
//    to calculate how many notes are "after" this note in the set.
//    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
//    </dd>
// 
//  <dt>notes</dt>
//    <dd>
//    The list of metadata for Notes in this range.  The set of optional fields
//    that are set in each metadata structure will depend on the
//    NotesMetadataResultSpec provided by the caller when the search was
//    performed.  Only the 'guid' field will be guaranteed to be set in each
//    Note.
//    </dd>
// 
//  <dt>stoppedWords</dt>
//    <dd>
//    If the NoteList was produced using a text based search
//    query that included words that are not indexed or searched by the service,
//    this will include a list of those ignored words.
//    </dd>
// 
//  <dt>searchedWords</dt>
//    <dd>
//    If the NoteList was produced using a text based search
//    query that included viable search words or quoted expressions, this will
//    include a list of those words.  Any stopped words will not be included
//    in this list.
//    </dd>
// 
//  <dt>updateCount</dt>
//    <dd>
//    Indicates the total number of transactions that have
//    been committed within the account.  This reflects (for example) the
//    number of discrete additions or modifications that have been made to
//    the data in this account (tags, notes, resources, etc.).
//    This number is the "high water mark" for Update Sequence Numbers (USN)
//    within the account.
//    </dd>
// 
//  <dt>searchContextBytes</dt>
//    <dd>
//    Specifies the correlating information about the current search session, in byte array.
//    </dd>
// 
//  <dt>debugInfo</dt>
//    <dd>
//    Depends on the value of <code>context</code> in NoteFilter, this field
//    may contain debug information if the service decides to do so.
//    </dd>
// 
//  </dl>
// 
// Attributes:
//  - StartIndex
//  - TotalNotes
//  - Notes
//  - StoppedWords
//  - SearchedWords
//  - UpdateCount
//  - SearchContextBytes
//  - DebugInfo
type NotesMetadataList struct {
  StartIndex int32 `thrift:"startIndex,1,required" db:"startIndex" json:"startIndex"`
  TotalNotes int32 `thrift:"totalNotes,2,required" db:"totalNotes" json:"totalNotes"`
  Notes []*NoteMetadata `thrift:"notes,3,required" db:"notes" json:"notes"`
  StoppedWords []string `thrift:"stoppedWords,4" db:"stoppedWords" json:"stoppedWords,omitempty"`
  SearchedWords []string `thrift:"searchedWords,5" db:"searchedWords" json:"searchedWords,omitempty"`
  UpdateCount *int32 `thrift:"updateCount,6" db:"updateCount" json:"updateCount,omitempty"`
  SearchContextBytes []byte `thrift:"searchContextBytes,7" db:"searchContextBytes" json:"searchContextBytes,omitempty"`
  // unused field # 8
  DebugInfo *string `thrift:"debugInfo,9" db:"debugInfo" json:"debugInfo,omitempty"`
}

func NewNotesMetadataList() *NotesMetadataList {
  return &NotesMetadataList{}
}


func (p *NotesMetadataList) GetStartIndex() int32 {
  return p.StartIndex
}

func (p *NotesMetadataList) GetTotalNotes() int32 {
  return p.TotalNotes
}

func (p *NotesMetadataList) GetNotes() []*NoteMetadata {
  return p.Notes
}
var NotesMetadataList_StoppedWords_DEFAULT []string

func (p *NotesMetadataList) GetStoppedWords() []string {
  return p.StoppedWords
}
var NotesMetadataList_SearchedWords_DEFAULT []string

func (p *NotesMetadataList) GetSearchedWords() []string {
  return p.SearchedWords
}
var NotesMetadataList_UpdateCount_DEFAULT int32
func (p *NotesMetadataList) GetUpdateCount() int32 {
  if !p.IsSetUpdateCount() {
    return NotesMetadataList_UpdateCount_DEFAULT
  }
return *p.UpdateCount
}
var NotesMetadataList_SearchContextBytes_DEFAULT []byte

func (p *NotesMetadataList) GetSearchContextBytes() []byte {
  return p.SearchContextBytes
}
var NotesMetadataList_DebugInfo_DEFAULT string
func (p *NotesMetadataList) GetDebugInfo() string {
  if !p.IsSetDebugInfo() {
    return NotesMetadataList_DebugInfo_DEFAULT
  }
return *p.DebugInfo
}
func (p *NotesMetadataList) IsSetStoppedWords() bool {
  return p.StoppedWords != nil
}

func (p *NotesMetadataList) IsSetSearchedWords() bool {
  return p.SearchedWords != nil
}

func (p *NotesMetadataList) IsSetUpdateCount() bool {
  return p.UpdateCount != nil
}

func (p *NotesMetadataList) IsSetSearchContextBytes() bool {
  return p.SearchContextBytes != nil
}

func (p *NotesMetadataList) IsSetDebugInfo() bool {
  return p.DebugInfo != nil
}

func (p *NotesMetadataList) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetStartIndex bool = false;
  var issetTotalNotes bool = false;
  var issetNotes bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetStartIndex = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetTotalNotes = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetNotes = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetStartIndex{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartIndex is not set"));
  }
  if !issetTotalNotes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TotalNotes is not set"));
  }
  if !issetNotes{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Notes is not set"));
  }
  return nil
}

func (p *NotesMetadataList)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.StartIndex = v
}
  return nil
}

func (p *NotesMetadataList)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TotalNotes = v
}
  return nil
}

func (p *NotesMetadataList)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NoteMetadata, 0, size)
  p.Notes =  tSlice
  for i := 0; i < size; i ++ {
    _elem34 := &NoteMetadata{}
    if err := _elem34.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem34), err)
    }
    p.Notes = append(p.Notes, _elem34)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NotesMetadataList)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.StoppedWords =  tSlice
  for i := 0; i < size; i ++ {
var _elem35 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem35 = v
}
    p.StoppedWords = append(p.StoppedWords, _elem35)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NotesMetadataList)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.SearchedWords =  tSlice
  for i := 0; i < size; i ++ {
var _elem36 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem36 = v
}
    p.SearchedWords = append(p.SearchedWords, _elem36)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NotesMetadataList)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.UpdateCount = &v
}
  return nil
}

func (p *NotesMetadataList)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.SearchContextBytes = v
}
  return nil
}

func (p *NotesMetadataList)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.DebugInfo = &v
}
  return nil
}

func (p *NotesMetadataList) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NotesMetadataList"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NotesMetadataList) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "startIndex", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:startIndex: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.StartIndex)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.startIndex (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:startIndex: ", p), err) }
  return err
}

func (p *NotesMetadataList) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "totalNotes", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:totalNotes: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.TotalNotes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.totalNotes (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:totalNotes: ", p), err) }
  return err
}

func (p *NotesMetadataList) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notes", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notes: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Notes)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Notes {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notes: ", p), err) }
  return err
}

func (p *NotesMetadataList) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStoppedWords() {
    if err := oprot.WriteFieldBegin(ctx, "stoppedWords", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:stoppedWords: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.StoppedWords)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.StoppedWords {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:stoppedWords: ", p), err) }
  }
  return err
}

func (p *NotesMetadataList) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSearchedWords() {
    if err := oprot.WriteFieldBegin(ctx, "searchedWords", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:searchedWords: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.SearchedWords)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.SearchedWords {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:searchedWords: ", p), err) }
  }
  return err
}

func (p *NotesMetadataList) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateCount() {
    if err := oprot.WriteFieldBegin(ctx, "updateCount", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:updateCount: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.UpdateCount)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.updateCount (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:updateCount: ", p), err) }
  }
  return err
}

func (p *NotesMetadataList) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSearchContextBytes() {
    if err := oprot.WriteFieldBegin(ctx, "searchContextBytes", thrift.STRING, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:searchContextBytes: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.SearchContextBytes); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.searchContextBytes (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:searchContextBytes: ", p), err) }
  }
  return err
}

func (p *NotesMetadataList) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDebugInfo() {
    if err := oprot.WriteFieldBegin(ctx, "debugInfo", thrift.STRING, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:debugInfo: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DebugInfo)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.debugInfo (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:debugInfo: ", p), err) }
  }
  return err
}

func (p *NotesMetadataList) Equals(other *NotesMetadataList) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.StartIndex != other.StartIndex { return false }
  if p.TotalNotes != other.TotalNotes { return false }
  if len(p.Notes) != len(other.Notes) { return false }
  for i, _tgt := range p.Notes {
    _src37 := other.Notes[i]
    if !_tgt.Equals(_src37) { return false }
  }
  if len(p.StoppedWords) != len(other.StoppedWords) { return false }
  for i, _tgt := range p.StoppedWords {
    _src38 := other.StoppedWords[i]
    if _tgt != _src38 { return false }
  }
  if len(p.SearchedWords) != len(other.SearchedWords) { return false }
  for i, _tgt := range p.SearchedWords {
    _src39 := other.SearchedWords[i]
    if _tgt != _src39 { return false }
  }
  if p.UpdateCount != other.UpdateCount {
    if p.UpdateCount == nil || other.UpdateCount == nil {
      return false
    }
    if (*p.UpdateCount) != (*other.UpdateCount) { return false }
  }
  if bytes.Compare(p.SearchContextBytes, other.SearchContextBytes) != 0 { return false }
  if p.DebugInfo != other.DebugInfo {
    if p.DebugInfo == nil || other.DebugInfo == nil {
      return false
    }
    if (*p.DebugInfo) != (*other.DebugInfo) { return false }
  }
  return true
}

func (p *NotesMetadataList) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NotesMetadataList(%+v)", *p)
}

// This structure is provided to the findNotesMetadata function to specify
// the subset of fields that should be included in each NoteMetadata element
// that is returned in the NotesMetadataList.
// Each field on this structure is a boolean flag that indicates whether the
// corresponding field should be included in the NoteMetadata structure when
// it is returned.  For example, if the 'includeTitle' field is set on this
// structure when calling findNotesMetadata, then each NoteMetadata in the
// list should have its 'title' field set.
// If one of the fields in this spec is not set, then it will be treated as
// 'false' by the server, so the default behavior is to include nothing in
// replies (but the mandatory GUID)
// 
// Attributes:
//  - IncludeTitle
//  - IncludeContentLength
//  - IncludeCreated
//  - IncludeUpdated
//  - IncludeDeleted
//  - IncludeUpdateSequenceNum
//  - IncludeNotebookGuid
//  - IncludeTagGuids
//  - IncludeAttributes
//  - IncludeLargestResourceMime
//  - IncludeLargestResourceSize
type NotesMetadataResultSpec struct {
  // unused field # 1
  IncludeTitle *bool `thrift:"includeTitle,2" db:"includeTitle" json:"includeTitle,omitempty"`
  // unused fields # 3 to 4
  IncludeContentLength *bool `thrift:"includeContentLength,5" db:"includeContentLength" json:"includeContentLength,omitempty"`
  IncludeCreated *bool `thrift:"includeCreated,6" db:"includeCreated" json:"includeCreated,omitempty"`
  IncludeUpdated *bool `thrift:"includeUpdated,7" db:"includeUpdated" json:"includeUpdated,omitempty"`
  IncludeDeleted *bool `thrift:"includeDeleted,8" db:"includeDeleted" json:"includeDeleted,omitempty"`
  // unused field # 9
  IncludeUpdateSequenceNum *bool `thrift:"includeUpdateSequenceNum,10" db:"includeUpdateSequenceNum" json:"includeUpdateSequenceNum,omitempty"`
  IncludeNotebookGuid *bool `thrift:"includeNotebookGuid,11" db:"includeNotebookGuid" json:"includeNotebookGuid,omitempty"`
  IncludeTagGuids *bool `thrift:"includeTagGuids,12" db:"includeTagGuids" json:"includeTagGuids,omitempty"`
  // unused field # 13
  IncludeAttributes *bool `thrift:"includeAttributes,14" db:"includeAttributes" json:"includeAttributes,omitempty"`
  // unused fields # 15 to 19
  IncludeLargestResourceMime *bool `thrift:"includeLargestResourceMime,20" db:"includeLargestResourceMime" json:"includeLargestResourceMime,omitempty"`
  IncludeLargestResourceSize *bool `thrift:"includeLargestResourceSize,21" db:"includeLargestResourceSize" json:"includeLargestResourceSize,omitempty"`
}

func NewNotesMetadataResultSpec() *NotesMetadataResultSpec {
  return &NotesMetadataResultSpec{}
}

var NotesMetadataResultSpec_IncludeTitle_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeTitle() bool {
  if !p.IsSetIncludeTitle() {
    return NotesMetadataResultSpec_IncludeTitle_DEFAULT
  }
return *p.IncludeTitle
}
var NotesMetadataResultSpec_IncludeContentLength_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeContentLength() bool {
  if !p.IsSetIncludeContentLength() {
    return NotesMetadataResultSpec_IncludeContentLength_DEFAULT
  }
return *p.IncludeContentLength
}
var NotesMetadataResultSpec_IncludeCreated_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeCreated() bool {
  if !p.IsSetIncludeCreated() {
    return NotesMetadataResultSpec_IncludeCreated_DEFAULT
  }
return *p.IncludeCreated
}
var NotesMetadataResultSpec_IncludeUpdated_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeUpdated() bool {
  if !p.IsSetIncludeUpdated() {
    return NotesMetadataResultSpec_IncludeUpdated_DEFAULT
  }
return *p.IncludeUpdated
}
var NotesMetadataResultSpec_IncludeDeleted_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeDeleted() bool {
  if !p.IsSetIncludeDeleted() {
    return NotesMetadataResultSpec_IncludeDeleted_DEFAULT
  }
return *p.IncludeDeleted
}
var NotesMetadataResultSpec_IncludeUpdateSequenceNum_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeUpdateSequenceNum() bool {
  if !p.IsSetIncludeUpdateSequenceNum() {
    return NotesMetadataResultSpec_IncludeUpdateSequenceNum_DEFAULT
  }
return *p.IncludeUpdateSequenceNum
}
var NotesMetadataResultSpec_IncludeNotebookGuid_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeNotebookGuid() bool {
  if !p.IsSetIncludeNotebookGuid() {
    return NotesMetadataResultSpec_IncludeNotebookGuid_DEFAULT
  }
return *p.IncludeNotebookGuid
}
var NotesMetadataResultSpec_IncludeTagGuids_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeTagGuids() bool {
  if !p.IsSetIncludeTagGuids() {
    return NotesMetadataResultSpec_IncludeTagGuids_DEFAULT
  }
return *p.IncludeTagGuids
}
var NotesMetadataResultSpec_IncludeAttributes_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeAttributes() bool {
  if !p.IsSetIncludeAttributes() {
    return NotesMetadataResultSpec_IncludeAttributes_DEFAULT
  }
return *p.IncludeAttributes
}
var NotesMetadataResultSpec_IncludeLargestResourceMime_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeLargestResourceMime() bool {
  if !p.IsSetIncludeLargestResourceMime() {
    return NotesMetadataResultSpec_IncludeLargestResourceMime_DEFAULT
  }
return *p.IncludeLargestResourceMime
}
var NotesMetadataResultSpec_IncludeLargestResourceSize_DEFAULT bool
func (p *NotesMetadataResultSpec) GetIncludeLargestResourceSize() bool {
  if !p.IsSetIncludeLargestResourceSize() {
    return NotesMetadataResultSpec_IncludeLargestResourceSize_DEFAULT
  }
return *p.IncludeLargestResourceSize
}
func (p *NotesMetadataResultSpec) IsSetIncludeTitle() bool {
  return p.IncludeTitle != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeContentLength() bool {
  return p.IncludeContentLength != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeCreated() bool {
  return p.IncludeCreated != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeUpdated() bool {
  return p.IncludeUpdated != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeDeleted() bool {
  return p.IncludeDeleted != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeUpdateSequenceNum() bool {
  return p.IncludeUpdateSequenceNum != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeNotebookGuid() bool {
  return p.IncludeNotebookGuid != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeTagGuids() bool {
  return p.IncludeTagGuids != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeAttributes() bool {
  return p.IncludeAttributes != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeLargestResourceMime() bool {
  return p.IncludeLargestResourceMime != nil
}

func (p *NotesMetadataResultSpec) IsSetIncludeLargestResourceSize() bool {
  return p.IncludeLargestResourceSize != nil
}

func (p *NotesMetadataResultSpec) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 20:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField20(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 21:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField21(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IncludeTitle = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.IncludeContentLength = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.IncludeCreated = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.IncludeUpdated = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.IncludeDeleted = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.IncludeUpdateSequenceNum = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.IncludeNotebookGuid = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.IncludeTagGuids = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  p.IncludeAttributes = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField20(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 20: ", err)
} else {
  p.IncludeLargestResourceMime = &v
}
  return nil
}

func (p *NotesMetadataResultSpec)  ReadField21(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 21: ", err)
} else {
  p.IncludeLargestResourceSize = &v
}
  return nil
}

func (p *NotesMetadataResultSpec) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NotesMetadataResultSpec"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField20(ctx, oprot); err != nil { return err }
    if err := p.writeField21(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NotesMetadataResultSpec) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeTitle() {
    if err := oprot.WriteFieldBegin(ctx, "includeTitle", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeTitle: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeTitle)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeTitle (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeTitle: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeContentLength() {
    if err := oprot.WriteFieldBegin(ctx, "includeContentLength", thrift.BOOL, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:includeContentLength: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeContentLength)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeContentLength (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:includeContentLength: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeCreated() {
    if err := oprot.WriteFieldBegin(ctx, "includeCreated", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:includeCreated: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeCreated)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeCreated (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:includeCreated: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeUpdated() {
    if err := oprot.WriteFieldBegin(ctx, "includeUpdated", thrift.BOOL, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:includeUpdated: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeUpdated)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeUpdated (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:includeUpdated: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeDeleted() {
    if err := oprot.WriteFieldBegin(ctx, "includeDeleted", thrift.BOOL, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:includeDeleted: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeDeleted)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeDeleted (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:includeDeleted: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeUpdateSequenceNum() {
    if err := oprot.WriteFieldBegin(ctx, "includeUpdateSequenceNum", thrift.BOOL, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:includeUpdateSequenceNum: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeUpdateSequenceNum)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeUpdateSequenceNum (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:includeUpdateSequenceNum: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNotebookGuid() {
    if err := oprot.WriteFieldBegin(ctx, "includeNotebookGuid", thrift.BOOL, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:includeNotebookGuid: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNotebookGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNotebookGuid (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:includeNotebookGuid: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeTagGuids() {
    if err := oprot.WriteFieldBegin(ctx, "includeTagGuids", thrift.BOOL, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:includeTagGuids: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeTagGuids)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeTagGuids (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:includeTagGuids: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeAttributes() {
    if err := oprot.WriteFieldBegin(ctx, "includeAttributes", thrift.BOOL, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:includeAttributes: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeAttributes)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeAttributes (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:includeAttributes: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField20(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeLargestResourceMime() {
    if err := oprot.WriteFieldBegin(ctx, "includeLargestResourceMime", thrift.BOOL, 20); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:includeLargestResourceMime: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeLargestResourceMime)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeLargestResourceMime (20) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 20:includeLargestResourceMime: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) writeField21(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeLargestResourceSize() {
    if err := oprot.WriteFieldBegin(ctx, "includeLargestResourceSize", thrift.BOOL, 21); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 21:includeLargestResourceSize: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeLargestResourceSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeLargestResourceSize (21) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 21:includeLargestResourceSize: ", p), err) }
  }
  return err
}

func (p *NotesMetadataResultSpec) Equals(other *NotesMetadataResultSpec) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IncludeTitle != other.IncludeTitle {
    if p.IncludeTitle == nil || other.IncludeTitle == nil {
      return false
    }
    if (*p.IncludeTitle) != (*other.IncludeTitle) { return false }
  }
  if p.IncludeContentLength != other.IncludeContentLength {
    if p.IncludeContentLength == nil || other.IncludeContentLength == nil {
      return false
    }
    if (*p.IncludeContentLength) != (*other.IncludeContentLength) { return false }
  }
  if p.IncludeCreated != other.IncludeCreated {
    if p.IncludeCreated == nil || other.IncludeCreated == nil {
      return false
    }
    if (*p.IncludeCreated) != (*other.IncludeCreated) { return false }
  }
  if p.IncludeUpdated != other.IncludeUpdated {
    if p.IncludeUpdated == nil || other.IncludeUpdated == nil {
      return false
    }
    if (*p.IncludeUpdated) != (*other.IncludeUpdated) { return false }
  }
  if p.IncludeDeleted != other.IncludeDeleted {
    if p.IncludeDeleted == nil || other.IncludeDeleted == nil {
      return false
    }
    if (*p.IncludeDeleted) != (*other.IncludeDeleted) { return false }
  }
  if p.IncludeUpdateSequenceNum != other.IncludeUpdateSequenceNum {
    if p.IncludeUpdateSequenceNum == nil || other.IncludeUpdateSequenceNum == nil {
      return false
    }
    if (*p.IncludeUpdateSequenceNum) != (*other.IncludeUpdateSequenceNum) { return false }
  }
  if p.IncludeNotebookGuid != other.IncludeNotebookGuid {
    if p.IncludeNotebookGuid == nil || other.IncludeNotebookGuid == nil {
      return false
    }
    if (*p.IncludeNotebookGuid) != (*other.IncludeNotebookGuid) { return false }
  }
  if p.IncludeTagGuids != other.IncludeTagGuids {
    if p.IncludeTagGuids == nil || other.IncludeTagGuids == nil {
      return false
    }
    if (*p.IncludeTagGuids) != (*other.IncludeTagGuids) { return false }
  }
  if p.IncludeAttributes != other.IncludeAttributes {
    if p.IncludeAttributes == nil || other.IncludeAttributes == nil {
      return false
    }
    if (*p.IncludeAttributes) != (*other.IncludeAttributes) { return false }
  }
  if p.IncludeLargestResourceMime != other.IncludeLargestResourceMime {
    if p.IncludeLargestResourceMime == nil || other.IncludeLargestResourceMime == nil {
      return false
    }
    if (*p.IncludeLargestResourceMime) != (*other.IncludeLargestResourceMime) { return false }
  }
  if p.IncludeLargestResourceSize != other.IncludeLargestResourceSize {
    if p.IncludeLargestResourceSize == nil || other.IncludeLargestResourceSize == nil {
      return false
    }
    if (*p.IncludeLargestResourceSize) != (*other.IncludeLargestResourceSize) { return false }
  }
  return true
}

func (p *NotesMetadataResultSpec) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NotesMetadataResultSpec(%+v)", *p)
}

//  A data structure representing the number of notes for each notebook
//  and tag with a non-zero set of applicable notes.
// 
// <dl>
//  <dt>notebookCounts</dt>
//    <dd>
//    A mapping from the Notebook GUID to the number of
//    notes (from some selection) that are in the corresponding notebook.
//    </dd>
// 
//  <dt>tagCounts</dt>
//    <dd>
//    A mapping from the Tag GUID to the number of notes (from some
//    selection) that have the corresponding tag.
//    </dd>
// 
//  <dt>trashCount</dt>
//    <dd>
//    If this is set, then this is the number of notes that are in the trash.
//    If this is not set, then the number of notes in the trash hasn't been
//    reported.  (I.e. if there are no notes in the trash, this will be set
//    to 0.)
//    </dd>
//  </dl>
// 
// Attributes:
//  - NotebookCounts
//  - TagCounts
//  - TrashCount
type NoteCollectionCounts struct {
  NotebookCounts map[GUID]int32 `thrift:"notebookCounts,1" db:"notebookCounts" json:"notebookCounts,omitempty"`
  TagCounts map[GUID]int32 `thrift:"tagCounts,2" db:"tagCounts" json:"tagCounts,omitempty"`
  TrashCount *int32 `thrift:"trashCount,3" db:"trashCount" json:"trashCount,omitempty"`
}

func NewNoteCollectionCounts() *NoteCollectionCounts {
  return &NoteCollectionCounts{}
}

var NoteCollectionCounts_NotebookCounts_DEFAULT map[GUID]int32

func (p *NoteCollectionCounts) GetNotebookCounts() map[GUID]int32 {
  return p.NotebookCounts
}
var NoteCollectionCounts_TagCounts_DEFAULT map[GUID]int32

func (p *NoteCollectionCounts) GetTagCounts() map[GUID]int32 {
  return p.TagCounts
}
var NoteCollectionCounts_TrashCount_DEFAULT int32
func (p *NoteCollectionCounts) GetTrashCount() int32 {
  if !p.IsSetTrashCount() {
    return NoteCollectionCounts_TrashCount_DEFAULT
  }
return *p.TrashCount
}
func (p *NoteCollectionCounts) IsSetNotebookCounts() bool {
  return p.NotebookCounts != nil
}

func (p *NoteCollectionCounts) IsSetTagCounts() bool {
  return p.TagCounts != nil
}

func (p *NoteCollectionCounts) IsSetTrashCount() bool {
  return p.TrashCount != nil
}

func (p *NoteCollectionCounts) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteCollectionCounts)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[GUID]int32, size)
  p.NotebookCounts =  tMap
  for i := 0; i < size; i ++ {
var _key40 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _key40 = temp
}
var _val41 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val41 = v
}
    p.NotebookCounts[_key40] = _val41
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NoteCollectionCounts)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[GUID]int32, size)
  p.TagCounts =  tMap
  for i := 0; i < size; i ++ {
var _key42 GUID
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := GUID(v)
    _key42 = temp
}
var _val43 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val43 = v
}
    p.TagCounts[_key42] = _val43
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NoteCollectionCounts)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.TrashCount = &v
}
  return nil
}

func (p *NoteCollectionCounts) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteCollectionCounts"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteCollectionCounts) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebookCounts() {
    if err := oprot.WriteFieldBegin(ctx, "notebookCounts", thrift.MAP, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notebookCounts: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.I32, len(p.NotebookCounts)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.NotebookCounts {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notebookCounts: ", p), err) }
  }
  return err
}

func (p *NoteCollectionCounts) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTagCounts() {
    if err := oprot.WriteFieldBegin(ctx, "tagCounts", thrift.MAP, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tagCounts: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.I32, len(p.TagCounts)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.TagCounts {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tagCounts: ", p), err) }
  }
  return err
}

func (p *NoteCollectionCounts) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTrashCount() {
    if err := oprot.WriteFieldBegin(ctx, "trashCount", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:trashCount: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.TrashCount)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.trashCount (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:trashCount: ", p), err) }
  }
  return err
}

func (p *NoteCollectionCounts) Equals(other *NoteCollectionCounts) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.NotebookCounts) != len(other.NotebookCounts) { return false }
  for k, _tgt := range p.NotebookCounts {
    _src44 := other.NotebookCounts[k]
    if _tgt != _src44 { return false }
  }
  if len(p.TagCounts) != len(other.TagCounts) { return false }
  for k, _tgt := range p.TagCounts {
    _src45 := other.TagCounts[k]
    if _tgt != _src45 { return false }
  }
  if p.TrashCount != other.TrashCount {
    if p.TrashCount == nil || other.TrashCount == nil {
      return false
    }
    if (*p.TrashCount) != (*other.TrashCount) { return false }
  }
  return true
}

func (p *NoteCollectionCounts) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteCollectionCounts(%+v)", *p)
}

// This structure is provided to the getNoteWithResultSpec function to specify the subset of
// fields that should be included in the Note that is returned. This allows clients to request
// the minimum set of information that they require when retrieving a note, reducing the size
// of the response and improving the response time.
// 
// If one of the fields in this spec is not set, then it will be treated as 'false' by the service,
// so that the default behavior is to include none of the fields below in the Note.
// 
// <dl>
//   <dt>includeContent</dt>
//   <dd>If true, the Note.content field will be populated with the note's ENML contents.</dd>
// 
//   <dt>includeResourcesData</dt>
//   <dd>If true, any Resource elements will include the binary contents of their 'data' field's
//     body.</dd>
// 
//   <dt>includeResourcesRecognition</dt>
//   <dd>If true, any Resource elements will include the binary contents of their 'recognition'
//     field's body if recognition data is available.</dd>
// 
//   <dt>includeResourcesAlternateData</dt>
//   <dd>If true, any Resource elements will include the binary contents of their 'alternateData'
//     field's body, if an alternate form is available.</dd>
// 
//   <dt>includeSharedNotes</dt>
//   <dd>If true, the Note.sharedNotes field will be populated with the note's shares.</dd>
// 
//   <dt>includeNoteAppDataValues</dt>
//   <dd>If true, the Note.attributes.applicationData.fullMap field will be populated.</dd>
// 
//   <dt>includeResourceAppDataValues</dt>
//   <dd>If true, the Note.resource.attributes.applicationData.fullMap field will be populated.</dd>
// 
//   <dt>includeAccountLimits</dt>
//   <dd>If true, the Note.limits field will be populated with the note owner's account limits.</dd>
// </dl>
// 
// Attributes:
//  - IncludeContent
//  - IncludeResourcesData
//  - IncludeResourcesRecognition
//  - IncludeResourcesAlternateData
//  - IncludeSharedNotes
//  - IncludeNoteAppDataValues
//  - IncludeResourceAppDataValues
//  - IncludeAccountLimits
type NoteResultSpec struct {
  IncludeContent *bool `thrift:"includeContent,1" db:"includeContent" json:"includeContent,omitempty"`
  IncludeResourcesData *bool `thrift:"includeResourcesData,2" db:"includeResourcesData" json:"includeResourcesData,omitempty"`
  IncludeResourcesRecognition *bool `thrift:"includeResourcesRecognition,3" db:"includeResourcesRecognition" json:"includeResourcesRecognition,omitempty"`
  IncludeResourcesAlternateData *bool `thrift:"includeResourcesAlternateData,4" db:"includeResourcesAlternateData" json:"includeResourcesAlternateData,omitempty"`
  IncludeSharedNotes *bool `thrift:"includeSharedNotes,5" db:"includeSharedNotes" json:"includeSharedNotes,omitempty"`
  IncludeNoteAppDataValues *bool `thrift:"includeNoteAppDataValues,6" db:"includeNoteAppDataValues" json:"includeNoteAppDataValues,omitempty"`
  IncludeResourceAppDataValues *bool `thrift:"includeResourceAppDataValues,7" db:"includeResourceAppDataValues" json:"includeResourceAppDataValues,omitempty"`
  IncludeAccountLimits *bool `thrift:"includeAccountLimits,8" db:"includeAccountLimits" json:"includeAccountLimits,omitempty"`
}

func NewNoteResultSpec() *NoteResultSpec {
  return &NoteResultSpec{}
}

var NoteResultSpec_IncludeContent_DEFAULT bool
func (p *NoteResultSpec) GetIncludeContent() bool {
  if !p.IsSetIncludeContent() {
    return NoteResultSpec_IncludeContent_DEFAULT
  }
return *p.IncludeContent
}
var NoteResultSpec_IncludeResourcesData_DEFAULT bool
func (p *NoteResultSpec) GetIncludeResourcesData() bool {
  if !p.IsSetIncludeResourcesData() {
    return NoteResultSpec_IncludeResourcesData_DEFAULT
  }
return *p.IncludeResourcesData
}
var NoteResultSpec_IncludeResourcesRecognition_DEFAULT bool
func (p *NoteResultSpec) GetIncludeResourcesRecognition() bool {
  if !p.IsSetIncludeResourcesRecognition() {
    return NoteResultSpec_IncludeResourcesRecognition_DEFAULT
  }
return *p.IncludeResourcesRecognition
}
var NoteResultSpec_IncludeResourcesAlternateData_DEFAULT bool
func (p *NoteResultSpec) GetIncludeResourcesAlternateData() bool {
  if !p.IsSetIncludeResourcesAlternateData() {
    return NoteResultSpec_IncludeResourcesAlternateData_DEFAULT
  }
return *p.IncludeResourcesAlternateData
}
var NoteResultSpec_IncludeSharedNotes_DEFAULT bool
func (p *NoteResultSpec) GetIncludeSharedNotes() bool {
  if !p.IsSetIncludeSharedNotes() {
    return NoteResultSpec_IncludeSharedNotes_DEFAULT
  }
return *p.IncludeSharedNotes
}
var NoteResultSpec_IncludeNoteAppDataValues_DEFAULT bool
func (p *NoteResultSpec) GetIncludeNoteAppDataValues() bool {
  if !p.IsSetIncludeNoteAppDataValues() {
    return NoteResultSpec_IncludeNoteAppDataValues_DEFAULT
  }
return *p.IncludeNoteAppDataValues
}
var NoteResultSpec_IncludeResourceAppDataValues_DEFAULT bool
func (p *NoteResultSpec) GetIncludeResourceAppDataValues() bool {
  if !p.IsSetIncludeResourceAppDataValues() {
    return NoteResultSpec_IncludeResourceAppDataValues_DEFAULT
  }
return *p.IncludeResourceAppDataValues
}
var NoteResultSpec_IncludeAccountLimits_DEFAULT bool
func (p *NoteResultSpec) GetIncludeAccountLimits() bool {
  if !p.IsSetIncludeAccountLimits() {
    return NoteResultSpec_IncludeAccountLimits_DEFAULT
  }
return *p.IncludeAccountLimits
}
func (p *NoteResultSpec) IsSetIncludeContent() bool {
  return p.IncludeContent != nil
}

func (p *NoteResultSpec) IsSetIncludeResourcesData() bool {
  return p.IncludeResourcesData != nil
}

func (p *NoteResultSpec) IsSetIncludeResourcesRecognition() bool {
  return p.IncludeResourcesRecognition != nil
}

func (p *NoteResultSpec) IsSetIncludeResourcesAlternateData() bool {
  return p.IncludeResourcesAlternateData != nil
}

func (p *NoteResultSpec) IsSetIncludeSharedNotes() bool {
  return p.IncludeSharedNotes != nil
}

func (p *NoteResultSpec) IsSetIncludeNoteAppDataValues() bool {
  return p.IncludeNoteAppDataValues != nil
}

func (p *NoteResultSpec) IsSetIncludeResourceAppDataValues() bool {
  return p.IncludeResourceAppDataValues != nil
}

func (p *NoteResultSpec) IsSetIncludeAccountLimits() bool {
  return p.IncludeAccountLimits != nil
}

func (p *NoteResultSpec) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteResultSpec)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.IncludeContent = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IncludeResourcesData = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.IncludeResourcesRecognition = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.IncludeResourcesAlternateData = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.IncludeSharedNotes = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.IncludeNoteAppDataValues = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.IncludeResourceAppDataValues = &v
}
  return nil
}

func (p *NoteResultSpec)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.IncludeAccountLimits = &v
}
  return nil
}

func (p *NoteResultSpec) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteResultSpec"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteResultSpec) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeContent() {
    if err := oprot.WriteFieldBegin(ctx, "includeContent", thrift.BOOL, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:includeContent: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeContent)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeContent (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:includeContent: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeResourcesData() {
    if err := oprot.WriteFieldBegin(ctx, "includeResourcesData", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeResourcesData: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeResourcesData)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeResourcesData (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeResourcesData: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeResourcesRecognition() {
    if err := oprot.WriteFieldBegin(ctx, "includeResourcesRecognition", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:includeResourcesRecognition: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeResourcesRecognition)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeResourcesRecognition (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:includeResourcesRecognition: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeResourcesAlternateData() {
    if err := oprot.WriteFieldBegin(ctx, "includeResourcesAlternateData", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:includeResourcesAlternateData: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeResourcesAlternateData)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeResourcesAlternateData (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:includeResourcesAlternateData: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeSharedNotes() {
    if err := oprot.WriteFieldBegin(ctx, "includeSharedNotes", thrift.BOOL, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:includeSharedNotes: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeSharedNotes)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeSharedNotes (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:includeSharedNotes: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeNoteAppDataValues() {
    if err := oprot.WriteFieldBegin(ctx, "includeNoteAppDataValues", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:includeNoteAppDataValues: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeNoteAppDataValues)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeNoteAppDataValues (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:includeNoteAppDataValues: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeResourceAppDataValues() {
    if err := oprot.WriteFieldBegin(ctx, "includeResourceAppDataValues", thrift.BOOL, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:includeResourceAppDataValues: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeResourceAppDataValues)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeResourceAppDataValues (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:includeResourceAppDataValues: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeAccountLimits() {
    if err := oprot.WriteFieldBegin(ctx, "includeAccountLimits", thrift.BOOL, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:includeAccountLimits: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeAccountLimits)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeAccountLimits (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:includeAccountLimits: ", p), err) }
  }
  return err
}

func (p *NoteResultSpec) Equals(other *NoteResultSpec) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IncludeContent != other.IncludeContent {
    if p.IncludeContent == nil || other.IncludeContent == nil {
      return false
    }
    if (*p.IncludeContent) != (*other.IncludeContent) { return false }
  }
  if p.IncludeResourcesData != other.IncludeResourcesData {
    if p.IncludeResourcesData == nil || other.IncludeResourcesData == nil {
      return false
    }
    if (*p.IncludeResourcesData) != (*other.IncludeResourcesData) { return false }
  }
  if p.IncludeResourcesRecognition != other.IncludeResourcesRecognition {
    if p.IncludeResourcesRecognition == nil || other.IncludeResourcesRecognition == nil {
      return false
    }
    if (*p.IncludeResourcesRecognition) != (*other.IncludeResourcesRecognition) { return false }
  }
  if p.IncludeResourcesAlternateData != other.IncludeResourcesAlternateData {
    if p.IncludeResourcesAlternateData == nil || other.IncludeResourcesAlternateData == nil {
      return false
    }
    if (*p.IncludeResourcesAlternateData) != (*other.IncludeResourcesAlternateData) { return false }
  }
  if p.IncludeSharedNotes != other.IncludeSharedNotes {
    if p.IncludeSharedNotes == nil || other.IncludeSharedNotes == nil {
      return false
    }
    if (*p.IncludeSharedNotes) != (*other.IncludeSharedNotes) { return false }
  }
  if p.IncludeNoteAppDataValues != other.IncludeNoteAppDataValues {
    if p.IncludeNoteAppDataValues == nil || other.IncludeNoteAppDataValues == nil {
      return false
    }
    if (*p.IncludeNoteAppDataValues) != (*other.IncludeNoteAppDataValues) { return false }
  }
  if p.IncludeResourceAppDataValues != other.IncludeResourceAppDataValues {
    if p.IncludeResourceAppDataValues == nil || other.IncludeResourceAppDataValues == nil {
      return false
    }
    if (*p.IncludeResourceAppDataValues) != (*other.IncludeResourceAppDataValues) { return false }
  }
  if p.IncludeAccountLimits != other.IncludeAccountLimits {
    if p.IncludeAccountLimits == nil || other.IncludeAccountLimits == nil {
      return false
    }
    if (*p.IncludeAccountLimits) != (*other.IncludeAccountLimits) { return false }
  }
  return true
}

func (p *NoteResultSpec) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteResultSpec(%+v)", *p)
}

// Parameters that must be given to the NoteStore emailNote call. These allow
// the caller to specify the note to send, the recipient addresses, etc.
// 
// <dl>
//  <dt>guid</dt>
//    <dd>
//      If set, this must be the GUID of a note within the user's account that
//      should be retrieved from the service and sent as email.  If not set,
//      the 'note' field must be provided instead.
//    </dd>
// 
//  <dt>note</dt>
//    <dd>
//      If the 'guid' field is not set, this field must be provided, including
//      the full contents of the note note (and all of its Resources) to send.
//      This can be used for a Note that as not been created in the service,
//      for example by a local client with local notes.
//    </dd>
// 
//  <dt>toAddresses</dt>
//    <dd>
//      If provided, this should contain a list of the SMTP email addresses
//      that should be included in the "To:" line of the email.
//      Callers must specify at least one "to" or "cc" email address.
//    </dd>
// 
//  <dt>ccAddresses</dt>
//    <dd>
//      If provided, this should contain a list of the SMTP email addresses
//      that should be included in the "Cc:" line of the email.
//      Callers must specify at least one "to" or "cc" email address.
//    </dd>
// 
//  <dt>subject</dt>
//    <dd>
//      If provided, this should contain the subject line of the email that
//      will be sent.  If not provided, the title of the note will be used
//      as the subject of the email.
//    </dd>
// 
//  <dt>message</dt>
//    <dd>
//      If provided, this is additional personal text that should be included
//      into the email as a message from the owner to the recipient(s).
//    </dd>
// </dl>
// 
// Attributes:
//  - GUID
//  - Note
//  - ToAddresses
//  - CcAddresses
//  - Subject
//  - Message
type NoteEmailParameters struct {
  GUID *string `thrift:"guid,1" db:"guid" json:"guid,omitempty"`
  Note *Note `thrift:"note,2" db:"note" json:"note,omitempty"`
  ToAddresses []string `thrift:"toAddresses,3" db:"toAddresses" json:"toAddresses,omitempty"`
  CcAddresses []string `thrift:"ccAddresses,4" db:"ccAddresses" json:"ccAddresses,omitempty"`
  Subject *string `thrift:"subject,5" db:"subject" json:"subject,omitempty"`
  Message *string `thrift:"message,6" db:"message" json:"message,omitempty"`
}

func NewNoteEmailParameters() *NoteEmailParameters {
  return &NoteEmailParameters{}
}

var NoteEmailParameters_GUID_DEFAULT string
func (p *NoteEmailParameters) GetGUID() string {
  if !p.IsSetGUID() {
    return NoteEmailParameters_GUID_DEFAULT
  }
return *p.GUID
}
var NoteEmailParameters_Note_DEFAULT *Note
func (p *NoteEmailParameters) GetNote() *Note {
  if !p.IsSetNote() {
    return NoteEmailParameters_Note_DEFAULT
  }
return p.Note
}
var NoteEmailParameters_ToAddresses_DEFAULT []string

func (p *NoteEmailParameters) GetToAddresses() []string {
  return p.ToAddresses
}
var NoteEmailParameters_CcAddresses_DEFAULT []string

func (p *NoteEmailParameters) GetCcAddresses() []string {
  return p.CcAddresses
}
var NoteEmailParameters_Subject_DEFAULT string
func (p *NoteEmailParameters) GetSubject() string {
  if !p.IsSetSubject() {
    return NoteEmailParameters_Subject_DEFAULT
  }
return *p.Subject
}
var NoteEmailParameters_Message_DEFAULT string
func (p *NoteEmailParameters) GetMessage() string {
  if !p.IsSetMessage() {
    return NoteEmailParameters_Message_DEFAULT
  }
return *p.Message
}
func (p *NoteEmailParameters) IsSetGUID() bool {
  return p.GUID != nil
}

func (p *NoteEmailParameters) IsSetNote() bool {
  return p.Note != nil
}

func (p *NoteEmailParameters) IsSetToAddresses() bool {
  return p.ToAddresses != nil
}

func (p *NoteEmailParameters) IsSetCcAddresses() bool {
  return p.CcAddresses != nil
}

func (p *NoteEmailParameters) IsSetSubject() bool {
  return p.Subject != nil
}

func (p *NoteEmailParameters) IsSetMessage() bool {
  return p.Message != nil
}

func (p *NoteEmailParameters) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteEmailParameters)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.GUID = &v
}
  return nil
}

func (p *NoteEmailParameters)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Note = &Note{}
  if err := p.Note.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Note), err)
  }
  return nil
}

func (p *NoteEmailParameters)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.ToAddresses =  tSlice
  for i := 0; i < size; i ++ {
var _elem46 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem46 = v
}
    p.ToAddresses = append(p.ToAddresses, _elem46)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteEmailParameters)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.CcAddresses =  tSlice
  for i := 0; i < size; i ++ {
var _elem47 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem47 = v
}
    p.CcAddresses = append(p.CcAddresses, _elem47)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteEmailParameters)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Subject = &v
}
  return nil
}

func (p *NoteEmailParameters)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *NoteEmailParameters) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteEmailParameters"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteEmailParameters) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGUID() {
    if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:guid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.GUID)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.guid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:guid: ", p), err) }
  }
  return err
}

func (p *NoteEmailParameters) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNote() {
    if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:note: ", p), err) }
    if err := p.Note.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Note), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:note: ", p), err) }
  }
  return err
}

func (p *NoteEmailParameters) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetToAddresses() {
    if err := oprot.WriteFieldBegin(ctx, "toAddresses", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:toAddresses: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ToAddresses)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ToAddresses {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:toAddresses: ", p), err) }
  }
  return err
}

func (p *NoteEmailParameters) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCcAddresses() {
    if err := oprot.WriteFieldBegin(ctx, "ccAddresses", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ccAddresses: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.CcAddresses)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.CcAddresses {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ccAddresses: ", p), err) }
  }
  return err
}

func (p *NoteEmailParameters) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSubject() {
    if err := oprot.WriteFieldBegin(ctx, "subject", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:subject: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Subject)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.subject (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:subject: ", p), err) }
  }
  return err
}

func (p *NoteEmailParameters) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:message: ", p), err) }
  }
  return err
}

func (p *NoteEmailParameters) Equals(other *NoteEmailParameters) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.GUID != other.GUID {
    if p.GUID == nil || other.GUID == nil {
      return false
    }
    if (*p.GUID) != (*other.GUID) { return false }
  }
  if !p.Note.Equals(other.Note) { return false }
  if len(p.ToAddresses) != len(other.ToAddresses) { return false }
  for i, _tgt := range p.ToAddresses {
    _src48 := other.ToAddresses[i]
    if _tgt != _src48 { return false }
  }
  if len(p.CcAddresses) != len(other.CcAddresses) { return false }
  for i, _tgt := range p.CcAddresses {
    _src49 := other.CcAddresses[i]
    if _tgt != _src49 { return false }
  }
  if p.Subject != other.Subject {
    if p.Subject == nil || other.Subject == nil {
      return false
    }
    if (*p.Subject) != (*other.Subject) { return false }
  }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  return true
}

func (p *NoteEmailParameters) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteEmailParameters(%+v)", *p)
}

// Identifying information about previous versions of a note that are backed up
// within Evernote's servers.  Used in the return value of the listNoteVersions
// call.
// 
// <dl>
//  <dt>updateSequenceNum</dt>
//  <dd>
//    The update sequence number for the Note when it last had this content.
//    This serves to uniquely identify each version of the note, since USN
//    values are unique within an account for each update.
//  </dd>
//  <dt>updated</dt>
//  <dd>
//    The 'updated' time that was set on the Note when it had this version
//    of the content.  This is the user-modifiable modification time on the
//    note, so it's not reliable for guaranteeing the order of various
//    versions.  (E.g. if someone modifies the note, then changes this time
//    manually into the past and then updates the note again.)
//  </dd>
//  <dt>saved</dt>
//  <dd>
//    A timestamp that holds the date and time when this version of the note
//    was backed up by Evernote's servers.
//  </dd>
//  <dt>title</dt>
//  <dd>
//    The title of the note when this particular version was saved.  (The
//    current title of the note may differ from this value.)
//  </dd>
//  <dt>lastEditorId</dt>
//  <dd>
//    The ID of the user who made the change to this version of the note. This will be
//    unset if the note version was edited by the owner of the account.
//  </dd>
// </dl>
// 
// Attributes:
//  - UpdateSequenceNum
//  - Updated
//  - Saved
//  - Title
//  - LastEditorId
type NoteVersionId struct {
  UpdateSequenceNum int32 `thrift:"updateSequenceNum,1,required" db:"updateSequenceNum" json:"updateSequenceNum"`
  Updated Timestamp `thrift:"updated,2,required" db:"updated" json:"updated"`
  Saved Timestamp `thrift:"saved,3,required" db:"saved" json:"saved"`
  Title string `thrift:"title,4,required" db:"title" json:"title"`
  LastEditorId *UserID `thrift:"lastEditorId,5" db:"lastEditorId" json:"lastEditorId,omitempty"`
}

func NewNoteVersionId() *NoteVersionId {
  return &NoteVersionId{}
}


func (p *NoteVersionId) GetUpdateSequenceNum() int32 {
  return p.UpdateSequenceNum
}

func (p *NoteVersionId) GetUpdated() Timestamp {
  return p.Updated
}

func (p *NoteVersionId) GetSaved() Timestamp {
  return p.Saved
}

func (p *NoteVersionId) GetTitle() string {
  return p.Title
}
var NoteVersionId_LastEditorId_DEFAULT UserID
func (p *NoteVersionId) GetLastEditorId() UserID {
  if !p.IsSetLastEditorId() {
    return NoteVersionId_LastEditorId_DEFAULT
  }
return *p.LastEditorId
}
func (p *NoteVersionId) IsSetLastEditorId() bool {
  return p.LastEditorId != nil
}

func (p *NoteVersionId) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUpdateSequenceNum bool = false;
  var issetUpdated bool = false;
  var issetSaved bool = false;
  var issetTitle bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetUpdateSequenceNum = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetUpdated = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetSaved = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetTitle = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUpdateSequenceNum{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UpdateSequenceNum is not set"));
  }
  if !issetUpdated{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Updated is not set"));
  }
  if !issetSaved{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Saved is not set"));
  }
  if !issetTitle{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Title is not set"));
  }
  return nil
}

func (p *NoteVersionId)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.UpdateSequenceNum = v
}
  return nil
}

func (p *NoteVersionId)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Timestamp(v)
  p.Updated = temp
}
  return nil
}

func (p *NoteVersionId)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Timestamp(v)
  p.Saved = temp
}
  return nil
}

func (p *NoteVersionId)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Title = v
}
  return nil
}

func (p *NoteVersionId)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := UserID(v)
  p.LastEditorId = &temp
}
  return nil
}

func (p *NoteVersionId) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteVersionId"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteVersionId) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateSequenceNum", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:updateSequenceNum: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UpdateSequenceNum)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updateSequenceNum (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:updateSequenceNum: ", p), err) }
  return err
}

func (p *NoteVersionId) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updated", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updated: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Updated)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updated (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updated: ", p), err) }
  return err
}

func (p *NoteVersionId) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "saved", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:saved: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Saved)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.saved (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:saved: ", p), err) }
  return err
}

func (p *NoteVersionId) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "title", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:title: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Title)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.title (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:title: ", p), err) }
  return err
}

func (p *NoteVersionId) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLastEditorId() {
    if err := oprot.WriteFieldBegin(ctx, "lastEditorId", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:lastEditorId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.LastEditorId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.lastEditorId (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:lastEditorId: ", p), err) }
  }
  return err
}

func (p *NoteVersionId) Equals(other *NoteVersionId) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.UpdateSequenceNum != other.UpdateSequenceNum { return false }
  if p.Updated != other.Updated { return false }
  if p.Saved != other.Saved { return false }
  if p.Title != other.Title { return false }
  if p.LastEditorId != other.LastEditorId {
    if p.LastEditorId == nil || other.LastEditorId == nil {
      return false
    }
    if (*p.LastEditorId) != (*other.LastEditorId) { return false }
  }
  return true
}

func (p *NoteVersionId) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteVersionId(%+v)", *p)
}

// A description of the thing for which we are searching for related
// entities.
// 
// You must specify either <em>noteGuid</em> or <em>plainText</em>, but
// not both. <em>filter</em> and <em>referenceUri</em> are optional.
// 
// <dl>
// <dt>noteGuid</dt>
// <dd>The GUID of an existing note in your account for which related
//     entities will be found.</dd>
// 
// <dt>plainText</dt>
// <dd>A string of plain text for which to find related entities.
//     You should provide a text block with a number of characters between
//     EDAM_RELATED_PLAINTEXT_LEN_MIN and EDAM_RELATED_PLAINTEXT_LEN_MAX.
//     </dd>
// 
// <dt>filter</dt>
// <dd>The list of criteria that will constrain the notes being considered
//     related.
//     Please note that some of the parameters may be ignored, such as
//     <em>order</em> and <em>ascending</em>.
// </dd>
// 
// <dt>referenceUri</dt>
// <dd>A URI string specifying a reference entity, around which "relatedness"
//     should be based. This can be an URL pointing to a web page, for example.
// </dd>
// 
// <dt>context</dt>
// <dd>Specifies the context to consider when determining related results.
//     Clients must leave this value unset unless they wish to explicitly specify a known
//     non-default context.
// </dd>
// 
// <dt>cacheKey</dt>
// <dd>If set and non-empty, this is an indicator for the server whether it is actually
//     necessary to perform a new findRelated call at all. Cache Keys are opaque strings
//     which are returned by the server as part of "RelatedResult" in response
//     to a "NoteStore.findRelated" query. Cache Keys are inherently query specific.
// 
//     If set to an empty string, this indicates that the server should generate a cache
//     key in the response as part of "RelatedResult".
// 
//     If not set, the server will not attempt to generate a cache key at all.
// </dd>
// </dl>
// 
// Attributes:
//  - NoteGuid
//  - PlainText
//  - Filter
//  - ReferenceUri
//  - Context
//  - CacheKey
type RelatedQuery struct {
  NoteGuid *string `thrift:"noteGuid,1" db:"noteGuid" json:"noteGuid,omitempty"`
  PlainText *string `thrift:"plainText,2" db:"plainText" json:"plainText,omitempty"`
  Filter *NoteFilter `thrift:"filter,3" db:"filter" json:"filter,omitempty"`
  ReferenceUri *string `thrift:"referenceUri,4" db:"referenceUri" json:"referenceUri,omitempty"`
  Context *string `thrift:"context,5" db:"context" json:"context,omitempty"`
  CacheKey *string `thrift:"cacheKey,6" db:"cacheKey" json:"cacheKey,omitempty"`
}

func NewRelatedQuery() *RelatedQuery {
  return &RelatedQuery{}
}

var RelatedQuery_NoteGuid_DEFAULT string
func (p *RelatedQuery) GetNoteGuid() string {
  if !p.IsSetNoteGuid() {
    return RelatedQuery_NoteGuid_DEFAULT
  }
return *p.NoteGuid
}
var RelatedQuery_PlainText_DEFAULT string
func (p *RelatedQuery) GetPlainText() string {
  if !p.IsSetPlainText() {
    return RelatedQuery_PlainText_DEFAULT
  }
return *p.PlainText
}
var RelatedQuery_Filter_DEFAULT *NoteFilter
func (p *RelatedQuery) GetFilter() *NoteFilter {
  if !p.IsSetFilter() {
    return RelatedQuery_Filter_DEFAULT
  }
return p.Filter
}
var RelatedQuery_ReferenceUri_DEFAULT string
func (p *RelatedQuery) GetReferenceUri() string {
  if !p.IsSetReferenceUri() {
    return RelatedQuery_ReferenceUri_DEFAULT
  }
return *p.ReferenceUri
}
var RelatedQuery_Context_DEFAULT string
func (p *RelatedQuery) GetContext() string {
  if !p.IsSetContext() {
    return RelatedQuery_Context_DEFAULT
  }
return *p.Context
}
var RelatedQuery_CacheKey_DEFAULT string
func (p *RelatedQuery) GetCacheKey() string {
  if !p.IsSetCacheKey() {
    return RelatedQuery_CacheKey_DEFAULT
  }
return *p.CacheKey
}
func (p *RelatedQuery) IsSetNoteGuid() bool {
  return p.NoteGuid != nil
}

func (p *RelatedQuery) IsSetPlainText() bool {
  return p.PlainText != nil
}

func (p *RelatedQuery) IsSetFilter() bool {
  return p.Filter != nil
}

func (p *RelatedQuery) IsSetReferenceUri() bool {
  return p.ReferenceUri != nil
}

func (p *RelatedQuery) IsSetContext() bool {
  return p.Context != nil
}

func (p *RelatedQuery) IsSetCacheKey() bool {
  return p.CacheKey != nil
}

func (p *RelatedQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RelatedQuery)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NoteGuid = &v
}
  return nil
}

func (p *RelatedQuery)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PlainText = &v
}
  return nil
}

func (p *RelatedQuery)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Filter = &NoteFilter{}
  if err := p.Filter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Filter), err)
  }
  return nil
}

func (p *RelatedQuery)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ReferenceUri = &v
}
  return nil
}

func (p *RelatedQuery)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Context = &v
}
  return nil
}

func (p *RelatedQuery)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.CacheKey = &v
}
  return nil
}

func (p *RelatedQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RelatedQuery"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RelatedQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoteGuid() {
    if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:noteGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NoteGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noteGuid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:noteGuid: ", p), err) }
  }
  return err
}

func (p *RelatedQuery) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPlainText() {
    if err := oprot.WriteFieldBegin(ctx, "plainText", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:plainText: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.PlainText)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.plainText (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:plainText: ", p), err) }
  }
  return err
}

func (p *RelatedQuery) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFilter() {
    if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:filter: ", p), err) }
    if err := p.Filter.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Filter), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:filter: ", p), err) }
  }
  return err
}

func (p *RelatedQuery) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetReferenceUri() {
    if err := oprot.WriteFieldBegin(ctx, "referenceUri", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:referenceUri: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.ReferenceUri)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.referenceUri (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:referenceUri: ", p), err) }
  }
  return err
}

func (p *RelatedQuery) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetContext() {
    if err := oprot.WriteFieldBegin(ctx, "context", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:context: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Context)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.context (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:context: ", p), err) }
  }
  return err
}

func (p *RelatedQuery) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheKey() {
    if err := oprot.WriteFieldBegin(ctx, "cacheKey", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:cacheKey: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.CacheKey)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheKey (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:cacheKey: ", p), err) }
  }
  return err
}

func (p *RelatedQuery) Equals(other *RelatedQuery) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NoteGuid != other.NoteGuid {
    if p.NoteGuid == nil || other.NoteGuid == nil {
      return false
    }
    if (*p.NoteGuid) != (*other.NoteGuid) { return false }
  }
  if p.PlainText != other.PlainText {
    if p.PlainText == nil || other.PlainText == nil {
      return false
    }
    if (*p.PlainText) != (*other.PlainText) { return false }
  }
  if !p.Filter.Equals(other.Filter) { return false }
  if p.ReferenceUri != other.ReferenceUri {
    if p.ReferenceUri == nil || other.ReferenceUri == nil {
      return false
    }
    if (*p.ReferenceUri) != (*other.ReferenceUri) { return false }
  }
  if p.Context != other.Context {
    if p.Context == nil || other.Context == nil {
      return false
    }
    if (*p.Context) != (*other.Context) { return false }
  }
  if p.CacheKey != other.CacheKey {
    if p.CacheKey == nil || other.CacheKey == nil {
      return false
    }
    if (*p.CacheKey) != (*other.CacheKey) { return false }
  }
  return true
}

func (p *RelatedQuery) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RelatedQuery(%+v)", *p)
}

// The result of calling findRelated().  The contents of the notes,
// notebooks, and tags fields will be in decreasing order of expected
// relevance.  It is possible that fewer results than requested will be
// returned even if there are enough distinct entities in the account
// in cases where the relevance is estimated to be low.
// 
// <dl>
// <dt>notes</dt>
// <dd>If notes have been requested to be included, this will be the
//     list of notes.</dd>
// 
// <dt>notebooks</dt>
// <dd>If notebooks have been requested to be included, this will be the
//     list of notebooks.</dd>
// 
// <dt>tags</dt>
// <dd>If tags have been requested to be included, this will be the list
//     of tags.</dd>
// 
// <dt>containingNotebooks</dt>
// <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
//     in the RelatedResultSpec, return the list of notebooks to
//     to which the returned related notes belong. The notebooks in this
//     list will occur once per notebook GUID and are represented as
//     NotebookDescriptor objects.</dd>
// 
// <dt>experts</dt>
// <dd>If experts have been requested to be included, this will return
//  a list of users within your business who have knowledge about the specified query.
// </dd>
// 
// <dt>relatedContent</dt>
// <dd>If related content has been requested to be included, this will be the list of
//  related content snippets.
// </dd>
// 
// <dt>cacheKey</dt>
// <dd>If set and non-empty, this cache key may be used in subsequent
//     "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
//     responses that were cached on the client-side, instead of actually performing
//     another search.
// 
//     If set to an empty string, this indicates that the server could not determine
//     a specific key for this response, but the client should nevertheless remove
//     any previously cached result for this request.
// 
//     If unset/null, it is up to the client whether to re-use cached results or to
//     use the server's response.
// 
//     If set to the exact non-empty cache key that was specified in
//     "RelatedQuery.cacheKey", this indicates that the server decided that cached results
//     could be reused.
// 
//     Depending on the cache key specified in the query, the "RelatedResult" may only be
//     partially filled. For each set field, the client should replace the corresponding
//     part in the previously cached result with the new partial result.
// 
//     For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
//     "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
//     that the previously requested and cached <em>Related Content</em> are unchanged,
//     but new results for <em>Related Notes</em> are available. The
//     response will have a new cache key and have "RelatedResult.notes" set, but have
//     "RelatedResult.relatedContent" unset (not just empty, but really unset).
// 
//     In this situation, the client should replace any cached notes with the newly
//     returned "RelatedResult.notes", but it can re-use the previously cached entries for
//     "RelatedResult.relatedContent". List fields that are set, but empty indicate that
//     no results could be found; the cache should be updated correspondingly.
// </dd>
// 
// <dt>cacheExpires</dt>
// <dd> If set, clients should reuse this response for any situations where the same input
//      parameters are applicable for up to this many seconds after receiving this result.
// 
//      After this time has passed, the client may request a new result from the service,
//      but it should supply the stored cacheKey to the service when checking for an
//      update.
// </dd>
// 
// </dl>
// 
// Attributes:
//  - Notes
//  - Notebooks
//  - Tags
//  - ContainingNotebooks
//  - DebugInfo
//  - Experts
//  - RelatedContent
//  - CacheKey
//  - CacheExpires
type RelatedResult_ struct {
  Notes []*Note `thrift:"notes,1" db:"notes" json:"notes,omitempty"`
  Notebooks []*Notebook `thrift:"notebooks,2" db:"notebooks" json:"notebooks,omitempty"`
  Tags []*Tag `thrift:"tags,3" db:"tags" json:"tags,omitempty"`
  ContainingNotebooks []*NotebookDescriptor `thrift:"containingNotebooks,4" db:"containingNotebooks" json:"containingNotebooks,omitempty"`
  DebugInfo *string `thrift:"debugInfo,5" db:"debugInfo" json:"debugInfo,omitempty"`
  Experts []*UserProfile `thrift:"experts,6" db:"experts" json:"experts,omitempty"`
  RelatedContent []*RelatedContent `thrift:"relatedContent,7" db:"relatedContent" json:"relatedContent,omitempty"`
  CacheKey *string `thrift:"cacheKey,8" db:"cacheKey" json:"cacheKey,omitempty"`
  CacheExpires *int32 `thrift:"cacheExpires,9" db:"cacheExpires" json:"cacheExpires,omitempty"`
}

func NewRelatedResult_() *RelatedResult_ {
  return &RelatedResult_{}
}

var RelatedResult__Notes_DEFAULT []*Note

func (p *RelatedResult_) GetNotes() []*Note {
  return p.Notes
}
var RelatedResult__Notebooks_DEFAULT []*Notebook

func (p *RelatedResult_) GetNotebooks() []*Notebook {
  return p.Notebooks
}
var RelatedResult__Tags_DEFAULT []*Tag

func (p *RelatedResult_) GetTags() []*Tag {
  return p.Tags
}
var RelatedResult__ContainingNotebooks_DEFAULT []*NotebookDescriptor

func (p *RelatedResult_) GetContainingNotebooks() []*NotebookDescriptor {
  return p.ContainingNotebooks
}
var RelatedResult__DebugInfo_DEFAULT string
func (p *RelatedResult_) GetDebugInfo() string {
  if !p.IsSetDebugInfo() {
    return RelatedResult__DebugInfo_DEFAULT
  }
return *p.DebugInfo
}
var RelatedResult__Experts_DEFAULT []*UserProfile

func (p *RelatedResult_) GetExperts() []*UserProfile {
  return p.Experts
}
var RelatedResult__RelatedContent_DEFAULT []*RelatedContent

func (p *RelatedResult_) GetRelatedContent() []*RelatedContent {
  return p.RelatedContent
}
var RelatedResult__CacheKey_DEFAULT string
func (p *RelatedResult_) GetCacheKey() string {
  if !p.IsSetCacheKey() {
    return RelatedResult__CacheKey_DEFAULT
  }
return *p.CacheKey
}
var RelatedResult__CacheExpires_DEFAULT int32
func (p *RelatedResult_) GetCacheExpires() int32 {
  if !p.IsSetCacheExpires() {
    return RelatedResult__CacheExpires_DEFAULT
  }
return *p.CacheExpires
}
func (p *RelatedResult_) IsSetNotes() bool {
  return p.Notes != nil
}

func (p *RelatedResult_) IsSetNotebooks() bool {
  return p.Notebooks != nil
}

func (p *RelatedResult_) IsSetTags() bool {
  return p.Tags != nil
}

func (p *RelatedResult_) IsSetContainingNotebooks() bool {
  return p.ContainingNotebooks != nil
}

func (p *RelatedResult_) IsSetDebugInfo() bool {
  return p.DebugInfo != nil
}

func (p *RelatedResult_) IsSetExperts() bool {
  return p.Experts != nil
}

func (p *RelatedResult_) IsSetRelatedContent() bool {
  return p.RelatedContent != nil
}

func (p *RelatedResult_) IsSetCacheKey() bool {
  return p.CacheKey != nil
}

func (p *RelatedResult_) IsSetCacheExpires() bool {
  return p.CacheExpires != nil
}

func (p *RelatedResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Note, 0, size)
  p.Notes =  tSlice
  for i := 0; i < size; i ++ {
    _elem50 := &Note{}
    if err := _elem50.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem50), err)
    }
    p.Notes = append(p.Notes, _elem50)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Notebook, 0, size)
  p.Notebooks =  tSlice
  for i := 0; i < size; i ++ {
    _elem51 := &Notebook{}
    if err := _elem51.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem51), err)
    }
    p.Notebooks = append(p.Notebooks, _elem51)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Tag, 0, size)
  p.Tags =  tSlice
  for i := 0; i < size; i ++ {
    _elem52 := &Tag{}
    if err := _elem52.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem52), err)
    }
    p.Tags = append(p.Tags, _elem52)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NotebookDescriptor, 0, size)
  p.ContainingNotebooks =  tSlice
  for i := 0; i < size; i ++ {
    _elem53 := &NotebookDescriptor{}
    if err := _elem53.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem53), err)
    }
    p.ContainingNotebooks = append(p.ContainingNotebooks, _elem53)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.DebugInfo = &v
}
  return nil
}

func (p *RelatedResult_)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*UserProfile, 0, size)
  p.Experts =  tSlice
  for i := 0; i < size; i ++ {
    _elem54 := &UserProfile{}
    if err := _elem54.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem54), err)
    }
    p.Experts = append(p.Experts, _elem54)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*RelatedContent, 0, size)
  p.RelatedContent =  tSlice
  for i := 0; i < size; i ++ {
    _elem55 := &RelatedContent{}
    if err := _elem55.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem55), err)
    }
    p.RelatedContent = append(p.RelatedContent, _elem55)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *RelatedResult_)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.CacheKey = &v
}
  return nil
}

func (p *RelatedResult_)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.CacheExpires = &v
}
  return nil
}

func (p *RelatedResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RelatedResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RelatedResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotes() {
    if err := oprot.WriteFieldBegin(ctx, "notes", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notes: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Notes)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Notes {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notes: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "notebooks", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notebooks: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Notebooks)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Notebooks {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notebooks: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTags() {
    if err := oprot.WriteFieldBegin(ctx, "tags", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tags: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tags)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Tags {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tags: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetContainingNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "containingNotebooks", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:containingNotebooks: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ContainingNotebooks)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.ContainingNotebooks {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:containingNotebooks: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDebugInfo() {
    if err := oprot.WriteFieldBegin(ctx, "debugInfo", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:debugInfo: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DebugInfo)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.debugInfo (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:debugInfo: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExperts() {
    if err := oprot.WriteFieldBegin(ctx, "experts", thrift.LIST, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:experts: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Experts)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Experts {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:experts: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRelatedContent() {
    if err := oprot.WriteFieldBegin(ctx, "relatedContent", thrift.LIST, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:relatedContent: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.RelatedContent)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.RelatedContent {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:relatedContent: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheKey() {
    if err := oprot.WriteFieldBegin(ctx, "cacheKey", thrift.STRING, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:cacheKey: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.CacheKey)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheKey (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:cacheKey: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCacheExpires() {
    if err := oprot.WriteFieldBegin(ctx, "cacheExpires", thrift.I32, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:cacheExpires: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.CacheExpires)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cacheExpires (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:cacheExpires: ", p), err) }
  }
  return err
}

func (p *RelatedResult_) Equals(other *RelatedResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Notes) != len(other.Notes) { return false }
  for i, _tgt := range p.Notes {
    _src56 := other.Notes[i]
    if !_tgt.Equals(_src56) { return false }
  }
  if len(p.Notebooks) != len(other.Notebooks) { return false }
  for i, _tgt := range p.Notebooks {
    _src57 := other.Notebooks[i]
    if !_tgt.Equals(_src57) { return false }
  }
  if len(p.Tags) != len(other.Tags) { return false }
  for i, _tgt := range p.Tags {
    _src58 := other.Tags[i]
    if !_tgt.Equals(_src58) { return false }
  }
  if len(p.ContainingNotebooks) != len(other.ContainingNotebooks) { return false }
  for i, _tgt := range p.ContainingNotebooks {
    _src59 := other.ContainingNotebooks[i]
    if !_tgt.Equals(_src59) { return false }
  }
  if p.DebugInfo != other.DebugInfo {
    if p.DebugInfo == nil || other.DebugInfo == nil {
      return false
    }
    if (*p.DebugInfo) != (*other.DebugInfo) { return false }
  }
  if len(p.Experts) != len(other.Experts) { return false }
  for i, _tgt := range p.Experts {
    _src60 := other.Experts[i]
    if !_tgt.Equals(_src60) { return false }
  }
  if len(p.RelatedContent) != len(other.RelatedContent) { return false }
  for i, _tgt := range p.RelatedContent {
    _src61 := other.RelatedContent[i]
    if !_tgt.Equals(_src61) { return false }
  }
  if p.CacheKey != other.CacheKey {
    if p.CacheKey == nil || other.CacheKey == nil {
      return false
    }
    if (*p.CacheKey) != (*other.CacheKey) { return false }
  }
  if p.CacheExpires != other.CacheExpires {
    if p.CacheExpires == nil || other.CacheExpires == nil {
      return false
    }
    if (*p.CacheExpires) != (*other.CacheExpires) { return false }
  }
  return true
}

func (p *RelatedResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RelatedResult_(%+v)", *p)
}

// A description of the thing for which the service will find related
// entities, via findRelated(), together with a description of what
// type of entities and how many you are seeking in the
// RelatedResult.
// 
// <dl>
// <dt>maxNotes</dt>
// <dd>Return notes that are related to the query, but no more than
//     this many.  Any value greater than EDAM_RELATED_MAX_NOTES
//     will be silently capped.  If you do not set this field, then
//     no notes will be returned.</dd>
// 
// <dt>maxNotebooks</dt>
// <dd>Return notebooks that are related to the query, but no more than
//     this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
//     will be silently capped.  If you do not set this field, then
//     no notebooks will be returned.</dd>
// 
// <dt>maxTags</dt>
// <dd>Return tags that are related to the query, but no more than
//     this many.  Any value greater than EDAM_RELATED_MAX_TAGS
//     will be silently capped.  If you do not set this field, then
//     no tags will be returned.</dd>
// </dl>
// 
// <dt>writableNotebooksOnly</dt>
// <dd>Require that all returned related notebooks are writable.
//     The user will be able to create notes in all returned notebooks.
//     However, individual notes returned may still belong to notebooks
//     in which the user lacks the ability to create notes.</dd>
// </dl>
// 
// <dt>includeContainingNotebooks</dt>
// <dd>If set to <code>true</code>, return the containingNotebooks field
//     in the RelatedResult, which will contain the list of notebooks to
//     to which the returned related notes belong.</dd>
// </dl>
// 
// <dt>includeDebugInfo</dt>
// <dd>If set to <code>true</code>, indicate that debug information should
//     be returned in the 'debugInfo' field of RelatedResult. Note that the call may
//     be slower if this flag is set.</dd>
// 
// <dt>maxExperts</dt>
// <dd>This can only be used when making a findRelated call against a business.
//  Find users within your business who have knowledge about the specified query.
//  No more than this many users will be returned. Any value greater than
//  EDAM_RELATED_MAX_EXPERTS will be silently capped.
// </dd>
// 
// <dt>maxRelatedContent</dt>
// <dd>Return snippets of related content that is related to the query, but no more than
//  this many. Any value greater than EDAM_RELATED_MAX_RELATED_CONTENT will be silently
//  capped. If you do not set this field, then no related content will be returned.</dd>
// </dl>
// 
// <dt>relatedContentTypes</dt>
// <dd>Specifies the types of Related Content that should be returned.</dd>
// </dl>
// 
// Attributes:
//  - MaxNotes
//  - MaxNotebooks
//  - MaxTags
//  - WritableNotebooksOnly
//  - IncludeContainingNotebooks
//  - IncludeDebugInfo
//  - MaxExperts
//  - MaxRelatedContent
//  - RelatedContentTypes
type RelatedResultSpec struct {
  MaxNotes *int32 `thrift:"maxNotes,1" db:"maxNotes" json:"maxNotes,omitempty"`
  MaxNotebooks *int32 `thrift:"maxNotebooks,2" db:"maxNotebooks" json:"maxNotebooks,omitempty"`
  MaxTags *int32 `thrift:"maxTags,3" db:"maxTags" json:"maxTags,omitempty"`
  WritableNotebooksOnly *bool `thrift:"writableNotebooksOnly,4" db:"writableNotebooksOnly" json:"writableNotebooksOnly,omitempty"`
  IncludeContainingNotebooks *bool `thrift:"includeContainingNotebooks,5" db:"includeContainingNotebooks" json:"includeContainingNotebooks,omitempty"`
  IncludeDebugInfo *bool `thrift:"includeDebugInfo,6" db:"includeDebugInfo" json:"includeDebugInfo,omitempty"`
  MaxExperts *int32 `thrift:"maxExperts,7" db:"maxExperts" json:"maxExperts,omitempty"`
  MaxRelatedContent *int32 `thrift:"maxRelatedContent,8" db:"maxRelatedContent" json:"maxRelatedContent,omitempty"`
  RelatedContentTypes []RelatedContentType `thrift:"relatedContentTypes,9" db:"relatedContentTypes" json:"relatedContentTypes,omitempty"`
}

func NewRelatedResultSpec() *RelatedResultSpec {
  return &RelatedResultSpec{}
}

var RelatedResultSpec_MaxNotes_DEFAULT int32
func (p *RelatedResultSpec) GetMaxNotes() int32 {
  if !p.IsSetMaxNotes() {
    return RelatedResultSpec_MaxNotes_DEFAULT
  }
return *p.MaxNotes
}
var RelatedResultSpec_MaxNotebooks_DEFAULT int32
func (p *RelatedResultSpec) GetMaxNotebooks() int32 {
  if !p.IsSetMaxNotebooks() {
    return RelatedResultSpec_MaxNotebooks_DEFAULT
  }
return *p.MaxNotebooks
}
var RelatedResultSpec_MaxTags_DEFAULT int32
func (p *RelatedResultSpec) GetMaxTags() int32 {
  if !p.IsSetMaxTags() {
    return RelatedResultSpec_MaxTags_DEFAULT
  }
return *p.MaxTags
}
var RelatedResultSpec_WritableNotebooksOnly_DEFAULT bool
func (p *RelatedResultSpec) GetWritableNotebooksOnly() bool {
  if !p.IsSetWritableNotebooksOnly() {
    return RelatedResultSpec_WritableNotebooksOnly_DEFAULT
  }
return *p.WritableNotebooksOnly
}
var RelatedResultSpec_IncludeContainingNotebooks_DEFAULT bool
func (p *RelatedResultSpec) GetIncludeContainingNotebooks() bool {
  if !p.IsSetIncludeContainingNotebooks() {
    return RelatedResultSpec_IncludeContainingNotebooks_DEFAULT
  }
return *p.IncludeContainingNotebooks
}
var RelatedResultSpec_IncludeDebugInfo_DEFAULT bool
func (p *RelatedResultSpec) GetIncludeDebugInfo() bool {
  if !p.IsSetIncludeDebugInfo() {
    return RelatedResultSpec_IncludeDebugInfo_DEFAULT
  }
return *p.IncludeDebugInfo
}
var RelatedResultSpec_MaxExperts_DEFAULT int32
func (p *RelatedResultSpec) GetMaxExperts() int32 {
  if !p.IsSetMaxExperts() {
    return RelatedResultSpec_MaxExperts_DEFAULT
  }
return *p.MaxExperts
}
var RelatedResultSpec_MaxRelatedContent_DEFAULT int32
func (p *RelatedResultSpec) GetMaxRelatedContent() int32 {
  if !p.IsSetMaxRelatedContent() {
    return RelatedResultSpec_MaxRelatedContent_DEFAULT
  }
return *p.MaxRelatedContent
}
var RelatedResultSpec_RelatedContentTypes_DEFAULT []RelatedContentType

func (p *RelatedResultSpec) GetRelatedContentTypes() []RelatedContentType {
  return p.RelatedContentTypes
}
func (p *RelatedResultSpec) IsSetMaxNotes() bool {
  return p.MaxNotes != nil
}

func (p *RelatedResultSpec) IsSetMaxNotebooks() bool {
  return p.MaxNotebooks != nil
}

func (p *RelatedResultSpec) IsSetMaxTags() bool {
  return p.MaxTags != nil
}

func (p *RelatedResultSpec) IsSetWritableNotebooksOnly() bool {
  return p.WritableNotebooksOnly != nil
}

func (p *RelatedResultSpec) IsSetIncludeContainingNotebooks() bool {
  return p.IncludeContainingNotebooks != nil
}

func (p *RelatedResultSpec) IsSetIncludeDebugInfo() bool {
  return p.IncludeDebugInfo != nil
}

func (p *RelatedResultSpec) IsSetMaxExperts() bool {
  return p.MaxExperts != nil
}

func (p *RelatedResultSpec) IsSetMaxRelatedContent() bool {
  return p.MaxRelatedContent != nil
}

func (p *RelatedResultSpec) IsSetRelatedContentTypes() bool {
  return p.RelatedContentTypes != nil
}

func (p *RelatedResultSpec) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RelatedResultSpec)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.MaxNotes = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MaxNotebooks = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.MaxTags = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.WritableNotebooksOnly = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.IncludeContainingNotebooks = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.IncludeDebugInfo = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.MaxExperts = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.MaxRelatedContent = &v
}
  return nil
}

func (p *RelatedResultSpec)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]RelatedContentType, 0, size)
  p.RelatedContentTypes =  tSet
  for i := 0; i < size; i ++ {
var _elem62 RelatedContentType
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := RelatedContentType(v)
    _elem62 = temp
}
    p.RelatedContentTypes = append(p.RelatedContentTypes, _elem62)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *RelatedResultSpec) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RelatedResultSpec"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RelatedResultSpec) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxNotes() {
    if err := oprot.WriteFieldBegin(ctx, "maxNotes", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:maxNotes: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxNotes)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxNotes (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:maxNotes: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "maxNotebooks", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:maxNotebooks: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxNotebooks (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:maxNotebooks: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxTags() {
    if err := oprot.WriteFieldBegin(ctx, "maxTags", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:maxTags: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxTags)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxTags (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:maxTags: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetWritableNotebooksOnly() {
    if err := oprot.WriteFieldBegin(ctx, "writableNotebooksOnly", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:writableNotebooksOnly: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.WritableNotebooksOnly)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.writableNotebooksOnly (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:writableNotebooksOnly: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeContainingNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "includeContainingNotebooks", thrift.BOOL, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:includeContainingNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeContainingNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeContainingNotebooks (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:includeContainingNotebooks: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIncludeDebugInfo() {
    if err := oprot.WriteFieldBegin(ctx, "includeDebugInfo", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:includeDebugInfo: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.IncludeDebugInfo)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.includeDebugInfo (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:includeDebugInfo: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxExperts() {
    if err := oprot.WriteFieldBegin(ctx, "maxExperts", thrift.I32, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:maxExperts: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxExperts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxExperts (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:maxExperts: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxRelatedContent() {
    if err := oprot.WriteFieldBegin(ctx, "maxRelatedContent", thrift.I32, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:maxRelatedContent: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxRelatedContent)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.maxRelatedContent (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:maxRelatedContent: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRelatedContentTypes() {
    if err := oprot.WriteFieldBegin(ctx, "relatedContentTypes", thrift.SET, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:relatedContentTypes: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.RelatedContentTypes)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.RelatedContentTypes); i++ {
      for j := i+1; j<len(p.RelatedContentTypes); j++ {
        if func(tgt, src RelatedContentType) bool {
          if tgt != src { return false }
          return true
        }(p.RelatedContentTypes[i], p.RelatedContentTypes[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.RelatedContentTypes))
        }
      }
    }
    for _, v := range p.RelatedContentTypes {
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:relatedContentTypes: ", p), err) }
  }
  return err
}

func (p *RelatedResultSpec) Equals(other *RelatedResultSpec) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.MaxNotes != other.MaxNotes {
    if p.MaxNotes == nil || other.MaxNotes == nil {
      return false
    }
    if (*p.MaxNotes) != (*other.MaxNotes) { return false }
  }
  if p.MaxNotebooks != other.MaxNotebooks {
    if p.MaxNotebooks == nil || other.MaxNotebooks == nil {
      return false
    }
    if (*p.MaxNotebooks) != (*other.MaxNotebooks) { return false }
  }
  if p.MaxTags != other.MaxTags {
    if p.MaxTags == nil || other.MaxTags == nil {
      return false
    }
    if (*p.MaxTags) != (*other.MaxTags) { return false }
  }
  if p.WritableNotebooksOnly != other.WritableNotebooksOnly {
    if p.WritableNotebooksOnly == nil || other.WritableNotebooksOnly == nil {
      return false
    }
    if (*p.WritableNotebooksOnly) != (*other.WritableNotebooksOnly) { return false }
  }
  if p.IncludeContainingNotebooks != other.IncludeContainingNotebooks {
    if p.IncludeContainingNotebooks == nil || other.IncludeContainingNotebooks == nil {
      return false
    }
    if (*p.IncludeContainingNotebooks) != (*other.IncludeContainingNotebooks) { return false }
  }
  if p.IncludeDebugInfo != other.IncludeDebugInfo {
    if p.IncludeDebugInfo == nil || other.IncludeDebugInfo == nil {
      return false
    }
    if (*p.IncludeDebugInfo) != (*other.IncludeDebugInfo) { return false }
  }
  if p.MaxExperts != other.MaxExperts {
    if p.MaxExperts == nil || other.MaxExperts == nil {
      return false
    }
    if (*p.MaxExperts) != (*other.MaxExperts) { return false }
  }
  if p.MaxRelatedContent != other.MaxRelatedContent {
    if p.MaxRelatedContent == nil || other.MaxRelatedContent == nil {
      return false
    }
    if (*p.MaxRelatedContent) != (*other.MaxRelatedContent) { return false }
  }
  if len(p.RelatedContentTypes) != len(other.RelatedContentTypes) { return false }
  for i, _tgt := range p.RelatedContentTypes {
    _src63 := other.RelatedContentTypes[i]
    if _tgt != _src63 { return false }
  }
  return true
}

func (p *RelatedResultSpec) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RelatedResultSpec(%+v)", *p)
}

// The result of a call to updateNoteIfUsnMatches, which optionally updates a note
// based on the current value of the note's update sequence number on the service.
// 
// <dl>
// <dt>note</dt>
// <dd>Either the current state of the note if <tt>updated</tt> is false or the
// result of updating the note as would be done via the <tt>updateNote</tt> method.
// If the note was not updated, you will receive a Note that does not include note
// content, resources data, resources recognition data, or resources alternate data.
// You can check for updates to these large objects by checking the Data.bodyHash
// values and downloading accordingly.</dd>
// 
// <dt>updated</dt>
// <dd>Whether or not the note was updated by the operation.</dd>
// </dl>
// 
// Attributes:
//  - Note
//  - Updated
type UpdateNoteIfUsnMatchesResult_ struct {
  Note *Note `thrift:"note,1" db:"note" json:"note,omitempty"`
  Updated *bool `thrift:"updated,2" db:"updated" json:"updated,omitempty"`
}

func NewUpdateNoteIfUsnMatchesResult_() *UpdateNoteIfUsnMatchesResult_ {
  return &UpdateNoteIfUsnMatchesResult_{}
}

var UpdateNoteIfUsnMatchesResult__Note_DEFAULT *Note
func (p *UpdateNoteIfUsnMatchesResult_) GetNote() *Note {
  if !p.IsSetNote() {
    return UpdateNoteIfUsnMatchesResult__Note_DEFAULT
  }
return p.Note
}
var UpdateNoteIfUsnMatchesResult__Updated_DEFAULT bool
func (p *UpdateNoteIfUsnMatchesResult_) GetUpdated() bool {
  if !p.IsSetUpdated() {
    return UpdateNoteIfUsnMatchesResult__Updated_DEFAULT
  }
return *p.Updated
}
func (p *UpdateNoteIfUsnMatchesResult_) IsSetNote() bool {
  return p.Note != nil
}

func (p *UpdateNoteIfUsnMatchesResult_) IsSetUpdated() bool {
  return p.Updated != nil
}

func (p *UpdateNoteIfUsnMatchesResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UpdateNoteIfUsnMatchesResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Note = &Note{}
  if err := p.Note.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Note), err)
  }
  return nil
}

func (p *UpdateNoteIfUsnMatchesResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Updated = &v
}
  return nil
}

func (p *UpdateNoteIfUsnMatchesResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "UpdateNoteIfUsnMatchesResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UpdateNoteIfUsnMatchesResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNote() {
    if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:note: ", p), err) }
    if err := p.Note.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Note), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:note: ", p), err) }
  }
  return err
}

func (p *UpdateNoteIfUsnMatchesResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdated() {
    if err := oprot.WriteFieldBegin(ctx, "updated", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updated: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Updated)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.updated (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updated: ", p), err) }
  }
  return err
}

func (p *UpdateNoteIfUsnMatchesResult_) Equals(other *UpdateNoteIfUsnMatchesResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Note.Equals(other.Note) { return false }
  if p.Updated != other.Updated {
    if p.Updated == nil || other.Updated == nil {
      return false
    }
    if (*p.Updated) != (*other.Updated) { return false }
  }
  return true
}

func (p *UpdateNoteIfUsnMatchesResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UpdateNoteIfUsnMatchesResult_(%+v)", *p)
}

// Attributes:
//  - NoSetReadOnly
//  - NoSetReadPlusActivity
//  - NoSetModify
//  - NoSetFullAccess
type ShareRelationshipRestrictions struct {
  NoSetReadOnly *bool `thrift:"noSetReadOnly,1" db:"noSetReadOnly" json:"noSetReadOnly,omitempty"`
  NoSetReadPlusActivity *bool `thrift:"noSetReadPlusActivity,2" db:"noSetReadPlusActivity" json:"noSetReadPlusActivity,omitempty"`
  NoSetModify *bool `thrift:"noSetModify,3" db:"noSetModify" json:"noSetModify,omitempty"`
  NoSetFullAccess *bool `thrift:"noSetFullAccess,4" db:"noSetFullAccess" json:"noSetFullAccess,omitempty"`
}

func NewShareRelationshipRestrictions() *ShareRelationshipRestrictions {
  return &ShareRelationshipRestrictions{}
}

var ShareRelationshipRestrictions_NoSetReadOnly_DEFAULT bool
func (p *ShareRelationshipRestrictions) GetNoSetReadOnly() bool {
  if !p.IsSetNoSetReadOnly() {
    return ShareRelationshipRestrictions_NoSetReadOnly_DEFAULT
  }
return *p.NoSetReadOnly
}
var ShareRelationshipRestrictions_NoSetReadPlusActivity_DEFAULT bool
func (p *ShareRelationshipRestrictions) GetNoSetReadPlusActivity() bool {
  if !p.IsSetNoSetReadPlusActivity() {
    return ShareRelationshipRestrictions_NoSetReadPlusActivity_DEFAULT
  }
return *p.NoSetReadPlusActivity
}
var ShareRelationshipRestrictions_NoSetModify_DEFAULT bool
func (p *ShareRelationshipRestrictions) GetNoSetModify() bool {
  if !p.IsSetNoSetModify() {
    return ShareRelationshipRestrictions_NoSetModify_DEFAULT
  }
return *p.NoSetModify
}
var ShareRelationshipRestrictions_NoSetFullAccess_DEFAULT bool
func (p *ShareRelationshipRestrictions) GetNoSetFullAccess() bool {
  if !p.IsSetNoSetFullAccess() {
    return ShareRelationshipRestrictions_NoSetFullAccess_DEFAULT
  }
return *p.NoSetFullAccess
}
func (p *ShareRelationshipRestrictions) IsSetNoSetReadOnly() bool {
  return p.NoSetReadOnly != nil
}

func (p *ShareRelationshipRestrictions) IsSetNoSetReadPlusActivity() bool {
  return p.NoSetReadPlusActivity != nil
}

func (p *ShareRelationshipRestrictions) IsSetNoSetModify() bool {
  return p.NoSetModify != nil
}

func (p *ShareRelationshipRestrictions) IsSetNoSetFullAccess() bool {
  return p.NoSetFullAccess != nil
}

func (p *ShareRelationshipRestrictions) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ShareRelationshipRestrictions)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NoSetReadOnly = &v
}
  return nil
}

func (p *ShareRelationshipRestrictions)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NoSetReadPlusActivity = &v
}
  return nil
}

func (p *ShareRelationshipRestrictions)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NoSetModify = &v
}
  return nil
}

func (p *ShareRelationshipRestrictions)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.NoSetFullAccess = &v
}
  return nil
}

func (p *ShareRelationshipRestrictions) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ShareRelationshipRestrictions"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ShareRelationshipRestrictions) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetReadOnly() {
    if err := oprot.WriteFieldBegin(ctx, "noSetReadOnly", thrift.BOOL, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:noSetReadOnly: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetReadOnly)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetReadOnly (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:noSetReadOnly: ", p), err) }
  }
  return err
}

func (p *ShareRelationshipRestrictions) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetReadPlusActivity() {
    if err := oprot.WriteFieldBegin(ctx, "noSetReadPlusActivity", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noSetReadPlusActivity: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetReadPlusActivity)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetReadPlusActivity (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noSetReadPlusActivity: ", p), err) }
  }
  return err
}

func (p *ShareRelationshipRestrictions) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetModify() {
    if err := oprot.WriteFieldBegin(ctx, "noSetModify", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:noSetModify: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetModify)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetModify (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:noSetModify: ", p), err) }
  }
  return err
}

func (p *ShareRelationshipRestrictions) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetFullAccess() {
    if err := oprot.WriteFieldBegin(ctx, "noSetFullAccess", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:noSetFullAccess: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetFullAccess)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetFullAccess (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:noSetFullAccess: ", p), err) }
  }
  return err
}

func (p *ShareRelationshipRestrictions) Equals(other *ShareRelationshipRestrictions) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NoSetReadOnly != other.NoSetReadOnly {
    if p.NoSetReadOnly == nil || other.NoSetReadOnly == nil {
      return false
    }
    if (*p.NoSetReadOnly) != (*other.NoSetReadOnly) { return false }
  }
  if p.NoSetReadPlusActivity != other.NoSetReadPlusActivity {
    if p.NoSetReadPlusActivity == nil || other.NoSetReadPlusActivity == nil {
      return false
    }
    if (*p.NoSetReadPlusActivity) != (*other.NoSetReadPlusActivity) { return false }
  }
  if p.NoSetModify != other.NoSetModify {
    if p.NoSetModify == nil || other.NoSetModify == nil {
      return false
    }
    if (*p.NoSetModify) != (*other.NoSetModify) { return false }
  }
  if p.NoSetFullAccess != other.NoSetFullAccess {
    if p.NoSetFullAccess == nil || other.NoSetFullAccess == nil {
      return false
    }
    if (*p.NoSetFullAccess) != (*other.NoSetFullAccess) { return false }
  }
  return true
}

func (p *ShareRelationshipRestrictions) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ShareRelationshipRestrictions(%+v)", *p)
}

// Describes an invitation to a person to use their Evernote
// credentials to become a member of a notebook.
// 
// <dl>
// <dt>displayName</dt>
// <dd>The string that clients should show to users to represent this
// invitation.</dd>
// 
// <dt>recipientUserIdentity</dt>
// <dd>Identifies the recipient of the invitation. The user identity
// type can be either EMAIL, EVERNOTE or IDENTITYID. If the
// invitation was created using the classic notebook sharing APIs it will be EMAIL. If it
// was created using the new identity-based notebook sharing APIs it will either be
// EVERNOTE or IDENTITYID, depending on whether we can map the identity to an Evernote
// user at the time of creation.
// </dd>
// 
// <dt>privilege</dt>
// <dd>The privilege level at which the member will be joined, if it
// turns out that the member is not already joined at a higher level.
// Note that the <tt>identity</tt> field may not uniquely identify an
// Evernote User ID, and so we won't know until the invitation is
// redeemed whether or not the recipient already has privilege.</dd>
// 
// <dt>sharerUserId</dt>
// <dd>The user id of the user who most recently shared this notebook
// to this identity. This field is used by the service to convey information
// to the user, so clients should treat it as read-only.</dd>
// </dl>
// 
// Attributes:
//  - DisplayName
//  - RecipientUserIdentity
//  - Privilege
//  - SharerUserId
type InvitationShareRelationship struct {
  DisplayName *string `thrift:"displayName,1" db:"displayName" json:"displayName,omitempty"`
  RecipientUserIdentity *UserIdentity `thrift:"recipientUserIdentity,2" db:"recipientUserIdentity" json:"recipientUserIdentity,omitempty"`
  Privilege *ShareRelationshipPrivilegeLevel `thrift:"privilege,3" db:"privilege" json:"privilege,omitempty"`
  // unused field # 4
  SharerUserId *UserID `thrift:"sharerUserId,5" db:"sharerUserId" json:"sharerUserId,omitempty"`
}

func NewInvitationShareRelationship() *InvitationShareRelationship {
  return &InvitationShareRelationship{}
}

var InvitationShareRelationship_DisplayName_DEFAULT string
func (p *InvitationShareRelationship) GetDisplayName() string {
  if !p.IsSetDisplayName() {
    return InvitationShareRelationship_DisplayName_DEFAULT
  }
return *p.DisplayName
}
var InvitationShareRelationship_RecipientUserIdentity_DEFAULT *UserIdentity
func (p *InvitationShareRelationship) GetRecipientUserIdentity() *UserIdentity {
  if !p.IsSetRecipientUserIdentity() {
    return InvitationShareRelationship_RecipientUserIdentity_DEFAULT
  }
return p.RecipientUserIdentity
}
var InvitationShareRelationship_Privilege_DEFAULT ShareRelationshipPrivilegeLevel
func (p *InvitationShareRelationship) GetPrivilege() ShareRelationshipPrivilegeLevel {
  if !p.IsSetPrivilege() {
    return InvitationShareRelationship_Privilege_DEFAULT
  }
return *p.Privilege
}
var InvitationShareRelationship_SharerUserId_DEFAULT UserID
func (p *InvitationShareRelationship) GetSharerUserId() UserID {
  if !p.IsSetSharerUserId() {
    return InvitationShareRelationship_SharerUserId_DEFAULT
  }
return *p.SharerUserId
}
func (p *InvitationShareRelationship) IsSetDisplayName() bool {
  return p.DisplayName != nil
}

func (p *InvitationShareRelationship) IsSetRecipientUserIdentity() bool {
  return p.RecipientUserIdentity != nil
}

func (p *InvitationShareRelationship) IsSetPrivilege() bool {
  return p.Privilege != nil
}

func (p *InvitationShareRelationship) IsSetSharerUserId() bool {
  return p.SharerUserId != nil
}

func (p *InvitationShareRelationship) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *InvitationShareRelationship)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DisplayName = &v
}
  return nil
}

func (p *InvitationShareRelationship)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.RecipientUserIdentity = &UserIdentity{}
  if err := p.RecipientUserIdentity.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RecipientUserIdentity), err)
  }
  return nil
}

func (p *InvitationShareRelationship)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := ShareRelationshipPrivilegeLevel(v)
  p.Privilege = &temp
}
  return nil
}

func (p *InvitationShareRelationship)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := UserID(v)
  p.SharerUserId = &temp
}
  return nil
}

func (p *InvitationShareRelationship) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "InvitationShareRelationship"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *InvitationShareRelationship) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDisplayName() {
    if err := oprot.WriteFieldBegin(ctx, "displayName", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:displayName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DisplayName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.displayName (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:displayName: ", p), err) }
  }
  return err
}

func (p *InvitationShareRelationship) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientUserIdentity() {
    if err := oprot.WriteFieldBegin(ctx, "recipientUserIdentity", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:recipientUserIdentity: ", p), err) }
    if err := p.RecipientUserIdentity.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RecipientUserIdentity), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:recipientUserIdentity: ", p), err) }
  }
  return err
}

func (p *InvitationShareRelationship) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "privilege", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:privilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Privilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.privilege (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:privilege: ", p), err) }
  }
  return err
}

func (p *InvitationShareRelationship) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSharerUserId() {
    if err := oprot.WriteFieldBegin(ctx, "sharerUserId", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:sharerUserId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.SharerUserId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.sharerUserId (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:sharerUserId: ", p), err) }
  }
  return err
}

func (p *InvitationShareRelationship) Equals(other *InvitationShareRelationship) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DisplayName != other.DisplayName {
    if p.DisplayName == nil || other.DisplayName == nil {
      return false
    }
    if (*p.DisplayName) != (*other.DisplayName) { return false }
  }
  if !p.RecipientUserIdentity.Equals(other.RecipientUserIdentity) { return false }
  if p.Privilege != other.Privilege {
    if p.Privilege == nil || other.Privilege == nil {
      return false
    }
    if (*p.Privilege) != (*other.Privilege) { return false }
  }
  if p.SharerUserId != other.SharerUserId {
    if p.SharerUserId == nil || other.SharerUserId == nil {
      return false
    }
    if (*p.SharerUserId) != (*other.SharerUserId) { return false }
  }
  return true
}

func (p *InvitationShareRelationship) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("InvitationShareRelationship(%+v)", *p)
}

// Describes the association between a Notebook and an Evernote User who is
// a member of that notebook.
// 
// <dl>
// <dt>displayName</dt>
// <dd>The string that clients should show to users to represent this
// member.</dd>
// 
// <dt>recipientUserId</dt>
// <dd>The Evernote User ID of the recipient of this notebook share.
// </dd>
// 
// <dt>bestPrivilege</dt>
// <dd>The privilege at which the member can access the notebook,
// which is the best privilege granted either individually or to a
// group to which a member belongs, such as a business.  This field is
// used by the service to convey information to the user, so clients
// should treat it as read-only.</dd>
// 
// <dt>individualPrivilege</dt>
// <dd>The individually granted privilege for the member, which does
// not take GROUP privileges into account.  This value may be unset if
// only a group-assigned privilege has been granted to the member.
// This value can be managed by others with sufficient rights using
// the manageNotebookShares method.  The valid values that clients
// should present to users for selection are given via the the
// 'restrictions' field.</dd>
// 
// <dt>restrictions</dt>
// <dd>The restrictions on which privileges may be individually
// assigned to the recipient of this share relationship.</dd>
// 
// <dt>sharerUserId</dt>
// <dd>The user id of the user who most recently shared the notebook
// to this user. This field is currently unset for a MemberShareRelationship
// created by joining a notebook that has been published to the business
// (MemberShareRelationships where the individual privilege is unset).
// This field is used by the service to convey information to the user, so
// clients should treat it as read-only.
// </dd>
// </dl>
// 
// Attributes:
//  - DisplayName
//  - RecipientUserId
//  - BestPrivilege
//  - IndividualPrivilege
//  - Restrictions
//  - SharerUserId
type MemberShareRelationship struct {
  DisplayName *string `thrift:"displayName,1" db:"displayName" json:"displayName,omitempty"`
  RecipientUserId *UserID `thrift:"recipientUserId,2" db:"recipientUserId" json:"recipientUserId,omitempty"`
  BestPrivilege *ShareRelationshipPrivilegeLevel `thrift:"bestPrivilege,3" db:"bestPrivilege" json:"bestPrivilege,omitempty"`
  IndividualPrivilege *ShareRelationshipPrivilegeLevel `thrift:"individualPrivilege,4" db:"individualPrivilege" json:"individualPrivilege,omitempty"`
  Restrictions *ShareRelationshipRestrictions `thrift:"restrictions,5" db:"restrictions" json:"restrictions,omitempty"`
  SharerUserId *UserID `thrift:"sharerUserId,6" db:"sharerUserId" json:"sharerUserId,omitempty"`
}

func NewMemberShareRelationship() *MemberShareRelationship {
  return &MemberShareRelationship{}
}

var MemberShareRelationship_DisplayName_DEFAULT string
func (p *MemberShareRelationship) GetDisplayName() string {
  if !p.IsSetDisplayName() {
    return MemberShareRelationship_DisplayName_DEFAULT
  }
return *p.DisplayName
}
var MemberShareRelationship_RecipientUserId_DEFAULT UserID
func (p *MemberShareRelationship) GetRecipientUserId() UserID {
  if !p.IsSetRecipientUserId() {
    return MemberShareRelationship_RecipientUserId_DEFAULT
  }
return *p.RecipientUserId
}
var MemberShareRelationship_BestPrivilege_DEFAULT ShareRelationshipPrivilegeLevel
func (p *MemberShareRelationship) GetBestPrivilege() ShareRelationshipPrivilegeLevel {
  if !p.IsSetBestPrivilege() {
    return MemberShareRelationship_BestPrivilege_DEFAULT
  }
return *p.BestPrivilege
}
var MemberShareRelationship_IndividualPrivilege_DEFAULT ShareRelationshipPrivilegeLevel
func (p *MemberShareRelationship) GetIndividualPrivilege() ShareRelationshipPrivilegeLevel {
  if !p.IsSetIndividualPrivilege() {
    return MemberShareRelationship_IndividualPrivilege_DEFAULT
  }
return *p.IndividualPrivilege
}
var MemberShareRelationship_Restrictions_DEFAULT *ShareRelationshipRestrictions
func (p *MemberShareRelationship) GetRestrictions() *ShareRelationshipRestrictions {
  if !p.IsSetRestrictions() {
    return MemberShareRelationship_Restrictions_DEFAULT
  }
return p.Restrictions
}
var MemberShareRelationship_SharerUserId_DEFAULT UserID
func (p *MemberShareRelationship) GetSharerUserId() UserID {
  if !p.IsSetSharerUserId() {
    return MemberShareRelationship_SharerUserId_DEFAULT
  }
return *p.SharerUserId
}
func (p *MemberShareRelationship) IsSetDisplayName() bool {
  return p.DisplayName != nil
}

func (p *MemberShareRelationship) IsSetRecipientUserId() bool {
  return p.RecipientUserId != nil
}

func (p *MemberShareRelationship) IsSetBestPrivilege() bool {
  return p.BestPrivilege != nil
}

func (p *MemberShareRelationship) IsSetIndividualPrivilege() bool {
  return p.IndividualPrivilege != nil
}

func (p *MemberShareRelationship) IsSetRestrictions() bool {
  return p.Restrictions != nil
}

func (p *MemberShareRelationship) IsSetSharerUserId() bool {
  return p.SharerUserId != nil
}

func (p *MemberShareRelationship) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *MemberShareRelationship)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DisplayName = &v
}
  return nil
}

func (p *MemberShareRelationship)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := UserID(v)
  p.RecipientUserId = &temp
}
  return nil
}

func (p *MemberShareRelationship)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := ShareRelationshipPrivilegeLevel(v)
  p.BestPrivilege = &temp
}
  return nil
}

func (p *MemberShareRelationship)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := ShareRelationshipPrivilegeLevel(v)
  p.IndividualPrivilege = &temp
}
  return nil
}

func (p *MemberShareRelationship)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Restrictions = &ShareRelationshipRestrictions{}
  if err := p.Restrictions.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Restrictions), err)
  }
  return nil
}

func (p *MemberShareRelationship)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := UserID(v)
  p.SharerUserId = &temp
}
  return nil
}

func (p *MemberShareRelationship) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "MemberShareRelationship"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *MemberShareRelationship) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDisplayName() {
    if err := oprot.WriteFieldBegin(ctx, "displayName", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:displayName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DisplayName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.displayName (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:displayName: ", p), err) }
  }
  return err
}

func (p *MemberShareRelationship) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientUserId() {
    if err := oprot.WriteFieldBegin(ctx, "recipientUserId", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:recipientUserId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.RecipientUserId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.recipientUserId (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:recipientUserId: ", p), err) }
  }
  return err
}

func (p *MemberShareRelationship) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBestPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "bestPrivilege", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:bestPrivilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BestPrivilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.bestPrivilege (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:bestPrivilege: ", p), err) }
  }
  return err
}

func (p *MemberShareRelationship) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIndividualPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "individualPrivilege", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:individualPrivilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.IndividualPrivilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.individualPrivilege (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:individualPrivilege: ", p), err) }
  }
  return err
}

func (p *MemberShareRelationship) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRestrictions() {
    if err := oprot.WriteFieldBegin(ctx, "restrictions", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:restrictions: ", p), err) }
    if err := p.Restrictions.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Restrictions), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:restrictions: ", p), err) }
  }
  return err
}

func (p *MemberShareRelationship) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSharerUserId() {
    if err := oprot.WriteFieldBegin(ctx, "sharerUserId", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:sharerUserId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.SharerUserId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.sharerUserId (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:sharerUserId: ", p), err) }
  }
  return err
}

func (p *MemberShareRelationship) Equals(other *MemberShareRelationship) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DisplayName != other.DisplayName {
    if p.DisplayName == nil || other.DisplayName == nil {
      return false
    }
    if (*p.DisplayName) != (*other.DisplayName) { return false }
  }
  if p.RecipientUserId != other.RecipientUserId {
    if p.RecipientUserId == nil || other.RecipientUserId == nil {
      return false
    }
    if (*p.RecipientUserId) != (*other.RecipientUserId) { return false }
  }
  if p.BestPrivilege != other.BestPrivilege {
    if p.BestPrivilege == nil || other.BestPrivilege == nil {
      return false
    }
    if (*p.BestPrivilege) != (*other.BestPrivilege) { return false }
  }
  if p.IndividualPrivilege != other.IndividualPrivilege {
    if p.IndividualPrivilege == nil || other.IndividualPrivilege == nil {
      return false
    }
    if (*p.IndividualPrivilege) != (*other.IndividualPrivilege) { return false }
  }
  if !p.Restrictions.Equals(other.Restrictions) { return false }
  if p.SharerUserId != other.SharerUserId {
    if p.SharerUserId == nil || other.SharerUserId == nil {
      return false
    }
    if (*p.SharerUserId) != (*other.SharerUserId) { return false }
  }
  return true
}

func (p *MemberShareRelationship) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("MemberShareRelationship(%+v)", *p)
}

// Captures a collection of share relationships for a notebook, for
// example, as returned by the getNotebookShares method.  The share
// relationships fall into two broad categories: members, and
// invitations that can be used to become members.
// 
// <dl>
// <dt>invitations</dt>
// <dd>A list of open invitations that can be redeemed into
// memberships to the notebook.</dd>
// 
// <dt>memberships</dt>
// <dd>A list of memberships of the notebook.  A member is identified
// by their Evernote UserID and has rights to access the
// notebook.</dd>
// 
// <dt>invitationRestrictions</dt>
// <dd>The restrictions on what privileges may be granted to invitees
// to this notebook. These restrictions may be specific to the calling
// user or to the notebook itself. They represent the
// union of all possible invite cases, so it is possible that once the
// recipient of the invitation has been identified by the service, such
// as by a business auto-join, the actual assigned privilege may change.
// </dd>
// </dl>
// 
// Attributes:
//  - Invitations
//  - Memberships
//  - InvitationRestrictions
type ShareRelationships struct {
  Invitations []*InvitationShareRelationship `thrift:"invitations,1" db:"invitations" json:"invitations,omitempty"`
  Memberships []*MemberShareRelationship `thrift:"memberships,2" db:"memberships" json:"memberships,omitempty"`
  InvitationRestrictions *ShareRelationshipRestrictions `thrift:"invitationRestrictions,3" db:"invitationRestrictions" json:"invitationRestrictions,omitempty"`
}

func NewShareRelationships() *ShareRelationships {
  return &ShareRelationships{}
}

var ShareRelationships_Invitations_DEFAULT []*InvitationShareRelationship

func (p *ShareRelationships) GetInvitations() []*InvitationShareRelationship {
  return p.Invitations
}
var ShareRelationships_Memberships_DEFAULT []*MemberShareRelationship

func (p *ShareRelationships) GetMemberships() []*MemberShareRelationship {
  return p.Memberships
}
var ShareRelationships_InvitationRestrictions_DEFAULT *ShareRelationshipRestrictions
func (p *ShareRelationships) GetInvitationRestrictions() *ShareRelationshipRestrictions {
  if !p.IsSetInvitationRestrictions() {
    return ShareRelationships_InvitationRestrictions_DEFAULT
  }
return p.InvitationRestrictions
}
func (p *ShareRelationships) IsSetInvitations() bool {
  return p.Invitations != nil
}

func (p *ShareRelationships) IsSetMemberships() bool {
  return p.Memberships != nil
}

func (p *ShareRelationships) IsSetInvitationRestrictions() bool {
  return p.InvitationRestrictions != nil
}

func (p *ShareRelationships) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ShareRelationships)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*InvitationShareRelationship, 0, size)
  p.Invitations =  tSlice
  for i := 0; i < size; i ++ {
    _elem64 := &InvitationShareRelationship{}
    if err := _elem64.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem64), err)
    }
    p.Invitations = append(p.Invitations, _elem64)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ShareRelationships)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*MemberShareRelationship, 0, size)
  p.Memberships =  tSlice
  for i := 0; i < size; i ++ {
    _elem65 := &MemberShareRelationship{}
    if err := _elem65.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem65), err)
    }
    p.Memberships = append(p.Memberships, _elem65)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ShareRelationships)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.InvitationRestrictions = &ShareRelationshipRestrictions{}
  if err := p.InvitationRestrictions.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.InvitationRestrictions), err)
  }
  return nil
}

func (p *ShareRelationships) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ShareRelationships"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ShareRelationships) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitations() {
    if err := oprot.WriteFieldBegin(ctx, "invitations", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:invitations: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Invitations)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Invitations {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:invitations: ", p), err) }
  }
  return err
}

func (p *ShareRelationships) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMemberships() {
    if err := oprot.WriteFieldBegin(ctx, "memberships", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberships: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Memberships)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Memberships {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberships: ", p), err) }
  }
  return err
}

func (p *ShareRelationships) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitationRestrictions() {
    if err := oprot.WriteFieldBegin(ctx, "invitationRestrictions", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:invitationRestrictions: ", p), err) }
    if err := p.InvitationRestrictions.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.InvitationRestrictions), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:invitationRestrictions: ", p), err) }
  }
  return err
}

func (p *ShareRelationships) Equals(other *ShareRelationships) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Invitations) != len(other.Invitations) { return false }
  for i, _tgt := range p.Invitations {
    _src66 := other.Invitations[i]
    if !_tgt.Equals(_src66) { return false }
  }
  if len(p.Memberships) != len(other.Memberships) { return false }
  for i, _tgt := range p.Memberships {
    _src67 := other.Memberships[i]
    if !_tgt.Equals(_src67) { return false }
  }
  if !p.InvitationRestrictions.Equals(other.InvitationRestrictions) { return false }
  return true
}

func (p *ShareRelationships) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ShareRelationships(%+v)", *p)
}

// A structure that captures parameters used by clients to manage the
// shares for a given notebook via the manageNotebookShares method.
// 
// <dl>
// <dt>notebookGuid</dt>
// <dd>The GUID of the notebook whose shares are being managed.</dd>
// 
// <dt>inviteMessage</dt>
// <dd>If the service sends a message to invitees, this parameter will
// be used to form the actual message that is sent.</dd>
// 
// <dt>membershipsToUpdate</dt>
// <dd>The list of existing memberships to update.  This field is not
// intended to be the full set of memberships for the notebook and
// should only include those already-existing memberships that you
// actually want to change.  If you want to remove shares, see the
// unshares fields.  If you want to create a membership,
// i.e. auto-join a business user, you can do this via the
// invitationsToCreateOrUpdate field using an Evernote UserID of a
// fellow business member (the created invitation is automatically
// joined by the service, so the client is creating an
// invitation, not a membership).</dd>
// 
// <dt>invitationsToCreateOrUpdate</dt>
// <dd>The list of invitations to update, as matched by the identity
// field of the InvitationShareRelationship instances, or to create if
// an existing invitation does not exist.  This field is not intended
// to be the full set of invitations on the notebook and should only
// include those invitations that you wish to create or update.  Note
// that your invitation could convert into a membership via a
// service-supported auto-join operation.  This happens, for example,
// when you use an invitation with an Evernote UserID type for a
// recipient who is a member of the business to which the notebook
// belongs.  Note that to discover the user IDs for business members,
// the sharer must also be part of the business.</dd>
// 
// <dt>unshares</dt>
// <dd>The list of share relationships to expunge from the service.
// If the user identity is for an Evernote UserID, then matching invitations or
// memberships will be removed. If it's an e-mail, then e-mail based shared notebook
// invitations will be removed. If it's for an Identity ID, then any invitations that
// match the identity (by identity ID or user ID or e-mail for legacy invitations) will be
// removed.</dd>
// </dl>
// 
// Attributes:
//  - NotebookGuid
//  - InviteMessage
//  - MembershipsToUpdate
//  - InvitationsToCreateOrUpdate
//  - Unshares
type ManageNotebookSharesParameters struct {
  NotebookGuid *string `thrift:"notebookGuid,1" db:"notebookGuid" json:"notebookGuid,omitempty"`
  InviteMessage *string `thrift:"inviteMessage,2" db:"inviteMessage" json:"inviteMessage,omitempty"`
  MembershipsToUpdate []*MemberShareRelationship `thrift:"membershipsToUpdate,3" db:"membershipsToUpdate" json:"membershipsToUpdate,omitempty"`
  InvitationsToCreateOrUpdate []*InvitationShareRelationship `thrift:"invitationsToCreateOrUpdate,4" db:"invitationsToCreateOrUpdate" json:"invitationsToCreateOrUpdate,omitempty"`
  Unshares []*UserIdentity `thrift:"unshares,5" db:"unshares" json:"unshares,omitempty"`
}

func NewManageNotebookSharesParameters() *ManageNotebookSharesParameters {
  return &ManageNotebookSharesParameters{}
}

var ManageNotebookSharesParameters_NotebookGuid_DEFAULT string
func (p *ManageNotebookSharesParameters) GetNotebookGuid() string {
  if !p.IsSetNotebookGuid() {
    return ManageNotebookSharesParameters_NotebookGuid_DEFAULT
  }
return *p.NotebookGuid
}
var ManageNotebookSharesParameters_InviteMessage_DEFAULT string
func (p *ManageNotebookSharesParameters) GetInviteMessage() string {
  if !p.IsSetInviteMessage() {
    return ManageNotebookSharesParameters_InviteMessage_DEFAULT
  }
return *p.InviteMessage
}
var ManageNotebookSharesParameters_MembershipsToUpdate_DEFAULT []*MemberShareRelationship

func (p *ManageNotebookSharesParameters) GetMembershipsToUpdate() []*MemberShareRelationship {
  return p.MembershipsToUpdate
}
var ManageNotebookSharesParameters_InvitationsToCreateOrUpdate_DEFAULT []*InvitationShareRelationship

func (p *ManageNotebookSharesParameters) GetInvitationsToCreateOrUpdate() []*InvitationShareRelationship {
  return p.InvitationsToCreateOrUpdate
}
var ManageNotebookSharesParameters_Unshares_DEFAULT []*UserIdentity

func (p *ManageNotebookSharesParameters) GetUnshares() []*UserIdentity {
  return p.Unshares
}
func (p *ManageNotebookSharesParameters) IsSetNotebookGuid() bool {
  return p.NotebookGuid != nil
}

func (p *ManageNotebookSharesParameters) IsSetInviteMessage() bool {
  return p.InviteMessage != nil
}

func (p *ManageNotebookSharesParameters) IsSetMembershipsToUpdate() bool {
  return p.MembershipsToUpdate != nil
}

func (p *ManageNotebookSharesParameters) IsSetInvitationsToCreateOrUpdate() bool {
  return p.InvitationsToCreateOrUpdate != nil
}

func (p *ManageNotebookSharesParameters) IsSetUnshares() bool {
  return p.Unshares != nil
}

func (p *ManageNotebookSharesParameters) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ManageNotebookSharesParameters)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NotebookGuid = &v
}
  return nil
}

func (p *ManageNotebookSharesParameters)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.InviteMessage = &v
}
  return nil
}

func (p *ManageNotebookSharesParameters)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*MemberShareRelationship, 0, size)
  p.MembershipsToUpdate =  tSlice
  for i := 0; i < size; i ++ {
    _elem68 := &MemberShareRelationship{}
    if err := _elem68.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem68), err)
    }
    p.MembershipsToUpdate = append(p.MembershipsToUpdate, _elem68)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNotebookSharesParameters)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*InvitationShareRelationship, 0, size)
  p.InvitationsToCreateOrUpdate =  tSlice
  for i := 0; i < size; i ++ {
    _elem69 := &InvitationShareRelationship{}
    if err := _elem69.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem69), err)
    }
    p.InvitationsToCreateOrUpdate = append(p.InvitationsToCreateOrUpdate, _elem69)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNotebookSharesParameters)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*UserIdentity, 0, size)
  p.Unshares =  tSlice
  for i := 0; i < size; i ++ {
    _elem70 := &UserIdentity{}
    if err := _elem70.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem70), err)
    }
    p.Unshares = append(p.Unshares, _elem70)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNotebookSharesParameters) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ManageNotebookSharesParameters"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ManageNotebookSharesParameters) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebookGuid() {
    if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notebookGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NotebookGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notebookGuid: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesParameters) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInviteMessage() {
    if err := oprot.WriteFieldBegin(ctx, "inviteMessage", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:inviteMessage: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.InviteMessage)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.inviteMessage (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:inviteMessage: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesParameters) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMembershipsToUpdate() {
    if err := oprot.WriteFieldBegin(ctx, "membershipsToUpdate", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:membershipsToUpdate: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.MembershipsToUpdate)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.MembershipsToUpdate {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:membershipsToUpdate: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesParameters) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitationsToCreateOrUpdate() {
    if err := oprot.WriteFieldBegin(ctx, "invitationsToCreateOrUpdate", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:invitationsToCreateOrUpdate: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.InvitationsToCreateOrUpdate)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.InvitationsToCreateOrUpdate {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:invitationsToCreateOrUpdate: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesParameters) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUnshares() {
    if err := oprot.WriteFieldBegin(ctx, "unshares", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:unshares: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Unshares)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Unshares {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:unshares: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesParameters) Equals(other *ManageNotebookSharesParameters) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NotebookGuid != other.NotebookGuid {
    if p.NotebookGuid == nil || other.NotebookGuid == nil {
      return false
    }
    if (*p.NotebookGuid) != (*other.NotebookGuid) { return false }
  }
  if p.InviteMessage != other.InviteMessage {
    if p.InviteMessage == nil || other.InviteMessage == nil {
      return false
    }
    if (*p.InviteMessage) != (*other.InviteMessage) { return false }
  }
  if len(p.MembershipsToUpdate) != len(other.MembershipsToUpdate) { return false }
  for i, _tgt := range p.MembershipsToUpdate {
    _src71 := other.MembershipsToUpdate[i]
    if !_tgt.Equals(_src71) { return false }
  }
  if len(p.InvitationsToCreateOrUpdate) != len(other.InvitationsToCreateOrUpdate) { return false }
  for i, _tgt := range p.InvitationsToCreateOrUpdate {
    _src72 := other.InvitationsToCreateOrUpdate[i]
    if !_tgt.Equals(_src72) { return false }
  }
  if len(p.Unshares) != len(other.Unshares) { return false }
  for i, _tgt := range p.Unshares {
    _src73 := other.Unshares[i]
    if !_tgt.Equals(_src73) { return false }
  }
  return true
}

func (p *ManageNotebookSharesParameters) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ManageNotebookSharesParameters(%+v)", *p)
}

// A structure to capture certain errors that occurred during a call
// to manageNotebookShares.  That method can be run best-effort,
// meaning that some change requests can be applied while others fail.
// Note that some errors such as system errors will still fail the
// entire transaction regardless of running best effort.  When some
// change requests do not succeed, the error conditions are captured
// in instances of this class, captured by the identity of the share
// relationship and one of the exception fields.
// 
// <dl>
// <dt>userIdentity</dt>
// <dd>The identity of the share relationship whose update encountered
// an error.</dd>
// 
// <dt>userException</dt>
// <dd>If the error is represented as an EDAMUserException that would
// have otherwise been thrown without best-effort execution.  Only one
// exception field will be set.</dd>
// 
// <dt>notFoundException</dt>
// <dd>If the error is represented as an EDAMNotFoundException that would
// have otherwise been thrown without best-effort execution.  Only one
// exception field will be set.</dd>
// </dl>
// 
// Attributes:
//  - UserIdentity
//  - UserException
//  - NotFoundException
type ManageNotebookSharesError struct {
  UserIdentity *UserIdentity `thrift:"userIdentity,1" db:"userIdentity" json:"userIdentity,omitempty"`
  UserException *EDAMUserException `thrift:"userException,2" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewManageNotebookSharesError() *ManageNotebookSharesError {
  return &ManageNotebookSharesError{}
}

var ManageNotebookSharesError_UserIdentity_DEFAULT *UserIdentity
func (p *ManageNotebookSharesError) GetUserIdentity() *UserIdentity {
  if !p.IsSetUserIdentity() {
    return ManageNotebookSharesError_UserIdentity_DEFAULT
  }
return p.UserIdentity
}
var ManageNotebookSharesError_UserException_DEFAULT *EDAMUserException
func (p *ManageNotebookSharesError) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return ManageNotebookSharesError_UserException_DEFAULT
  }
return p.UserException
}
var ManageNotebookSharesError_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *ManageNotebookSharesError) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return ManageNotebookSharesError_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *ManageNotebookSharesError) IsSetUserIdentity() bool {
  return p.UserIdentity != nil
}

func (p *ManageNotebookSharesError) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *ManageNotebookSharesError) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *ManageNotebookSharesError) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ManageNotebookSharesError)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserIdentity = &UserIdentity{}
  if err := p.UserIdentity.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserIdentity), err)
  }
  return nil
}

func (p *ManageNotebookSharesError)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *ManageNotebookSharesError)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *ManageNotebookSharesError) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ManageNotebookSharesError"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ManageNotebookSharesError) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserIdentity() {
    if err := oprot.WriteFieldBegin(ctx, "userIdentity", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userIdentity: ", p), err) }
    if err := p.UserIdentity.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserIdentity), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userIdentity: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesError) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:userException: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesError) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesError) Equals(other *ManageNotebookSharesError) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.UserIdentity.Equals(other.UserIdentity) { return false }
  if !p.UserException.Equals(other.UserException) { return false }
  if !p.NotFoundException.Equals(other.NotFoundException) { return false }
  return true
}

func (p *ManageNotebookSharesError) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ManageNotebookSharesError(%+v)", *p)
}

// The return value of a call to the manageNotebookShares method.
// 
// <dl>
// <dt>errors</dt>
// <dd>If the method completed without throwing exceptions, some errors
// might still have occurred, and in that case, this field will contain
// the list of those errors the occurred.
// </dd>
// </dl>
// 
// Attributes:
//  - Errors
type ManageNotebookSharesResult_ struct {
  Errors []*ManageNotebookSharesError `thrift:"errors,1" db:"errors" json:"errors,omitempty"`
}

func NewManageNotebookSharesResult_() *ManageNotebookSharesResult_ {
  return &ManageNotebookSharesResult_{}
}

var ManageNotebookSharesResult__Errors_DEFAULT []*ManageNotebookSharesError

func (p *ManageNotebookSharesResult_) GetErrors() []*ManageNotebookSharesError {
  return p.Errors
}
func (p *ManageNotebookSharesResult_) IsSetErrors() bool {
  return p.Errors != nil
}

func (p *ManageNotebookSharesResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ManageNotebookSharesResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ManageNotebookSharesError, 0, size)
  p.Errors =  tSlice
  for i := 0; i < size; i ++ {
    _elem74 := &ManageNotebookSharesError{}
    if err := _elem74.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem74), err)
    }
    p.Errors = append(p.Errors, _elem74)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNotebookSharesResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ManageNotebookSharesResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ManageNotebookSharesResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetErrors() {
    if err := oprot.WriteFieldBegin(ctx, "errors", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:errors: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Errors)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Errors {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:errors: ", p), err) }
  }
  return err
}

func (p *ManageNotebookSharesResult_) Equals(other *ManageNotebookSharesResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Errors) != len(other.Errors) { return false }
  for i, _tgt := range p.Errors {
    _src75 := other.Errors[i]
    if !_tgt.Equals(_src75) { return false }
  }
  return true
}

func (p *ManageNotebookSharesResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ManageNotebookSharesResult_(%+v)", *p)
}

// A structure used to share a note with one or more recipients at a given privilege.
// 
// <dl>
//   <dt>noteGuid</dt>
//   <dd>The GUID of the note.</dd>
// 
//   <dt>recipientThreadId</dt>
//   <dd>The recipients of the note share specified as a messaging thread ID. If you
//       have an existing messaging thread to share the note with, specify its ID
//       here instead of recipientContacts in order to properly support defunct
//       identities. The sharer must be a participant of the thread. Either this
//       field or recipientContacts must be set.</dd>
// 
//   <dt>recipientContacts</dt>
//   <dd>The recipients of the note share specified as a list of contacts. This should
//       only be set if the sharing takes place before the thread is created. Use
//       recipientThreadId instead when sharing with an existing thread. Either this
//       field or recipientThreadId must be set.</dd>
// 
//   <dt>privilege</dt>
//   <dd>The privilege level to be granted.</dd>
// </dl>
// 
// Attributes:
//  - NoteGuid
//  - RecipientThreadId
//  - RecipientContacts
//  - Privilege
type SharedNoteTemplate struct {
  NoteGuid *GUID `thrift:"noteGuid,1" db:"noteGuid" json:"noteGuid,omitempty"`
  RecipientContacts []*Contact `thrift:"recipientContacts,2" db:"recipientContacts" json:"recipientContacts,omitempty"`
  Privilege *SharedNotePrivilegeLevel `thrift:"privilege,3" db:"privilege" json:"privilege,omitempty"`
  RecipientThreadId *MessageThreadID `thrift:"recipientThreadId,4" db:"recipientThreadId" json:"recipientThreadId,omitempty"`
}

func NewSharedNoteTemplate() *SharedNoteTemplate {
  return &SharedNoteTemplate{}
}

var SharedNoteTemplate_NoteGuid_DEFAULT GUID
func (p *SharedNoteTemplate) GetNoteGuid() GUID {
  if !p.IsSetNoteGuid() {
    return SharedNoteTemplate_NoteGuid_DEFAULT
  }
return *p.NoteGuid
}
var SharedNoteTemplate_RecipientThreadId_DEFAULT MessageThreadID
func (p *SharedNoteTemplate) GetRecipientThreadId() MessageThreadID {
  if !p.IsSetRecipientThreadId() {
    return SharedNoteTemplate_RecipientThreadId_DEFAULT
  }
return *p.RecipientThreadId
}
var SharedNoteTemplate_RecipientContacts_DEFAULT []*Contact

func (p *SharedNoteTemplate) GetRecipientContacts() []*Contact {
  return p.RecipientContacts
}
var SharedNoteTemplate_Privilege_DEFAULT SharedNotePrivilegeLevel
func (p *SharedNoteTemplate) GetPrivilege() SharedNotePrivilegeLevel {
  if !p.IsSetPrivilege() {
    return SharedNoteTemplate_Privilege_DEFAULT
  }
return *p.Privilege
}
func (p *SharedNoteTemplate) IsSetNoteGuid() bool {
  return p.NoteGuid != nil
}

func (p *SharedNoteTemplate) IsSetRecipientThreadId() bool {
  return p.RecipientThreadId != nil
}

func (p *SharedNoteTemplate) IsSetRecipientContacts() bool {
  return p.RecipientContacts != nil
}

func (p *SharedNoteTemplate) IsSetPrivilege() bool {
  return p.Privilege != nil
}

func (p *SharedNoteTemplate) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SharedNoteTemplate)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := GUID(v)
  p.NoteGuid = &temp
}
  return nil
}

func (p *SharedNoteTemplate)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := MessageThreadID(v)
  p.RecipientThreadId = &temp
}
  return nil
}

func (p *SharedNoteTemplate)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Contact, 0, size)
  p.RecipientContacts =  tSlice
  for i := 0; i < size; i ++ {
    _elem76 := &Contact{}
    if err := _elem76.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem76), err)
    }
    p.RecipientContacts = append(p.RecipientContacts, _elem76)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SharedNoteTemplate)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := SharedNotePrivilegeLevel(v)
  p.Privilege = &temp
}
  return nil
}

func (p *SharedNoteTemplate) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SharedNoteTemplate"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SharedNoteTemplate) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoteGuid() {
    if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:noteGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NoteGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noteGuid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:noteGuid: ", p), err) }
  }
  return err
}

func (p *SharedNoteTemplate) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientContacts() {
    if err := oprot.WriteFieldBegin(ctx, "recipientContacts", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:recipientContacts: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.RecipientContacts)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.RecipientContacts {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:recipientContacts: ", p), err) }
  }
  return err
}

func (p *SharedNoteTemplate) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "privilege", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:privilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Privilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.privilege (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:privilege: ", p), err) }
  }
  return err
}

func (p *SharedNoteTemplate) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientThreadId() {
    if err := oprot.WriteFieldBegin(ctx, "recipientThreadId", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:recipientThreadId: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.RecipientThreadId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.recipientThreadId (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:recipientThreadId: ", p), err) }
  }
  return err
}

func (p *SharedNoteTemplate) Equals(other *SharedNoteTemplate) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NoteGuid != other.NoteGuid {
    if p.NoteGuid == nil || other.NoteGuid == nil {
      return false
    }
    if (*p.NoteGuid) != (*other.NoteGuid) { return false }
  }
  if len(p.RecipientContacts) != len(other.RecipientContacts) { return false }
  for i, _tgt := range p.RecipientContacts {
    _src77 := other.RecipientContacts[i]
    if !_tgt.Equals(_src77) { return false }
  }
  if p.Privilege != other.Privilege {
    if p.Privilege == nil || other.Privilege == nil {
      return false
    }
    if (*p.Privilege) != (*other.Privilege) { return false }
  }
  if p.RecipientThreadId != other.RecipientThreadId {
    if p.RecipientThreadId == nil || other.RecipientThreadId == nil {
      return false
    }
    if (*p.RecipientThreadId) != (*other.RecipientThreadId) { return false }
  }
  return true
}

func (p *SharedNoteTemplate) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SharedNoteTemplate(%+v)", *p)
}

// A structure used to share a notebook with one or more recipients at a given privilege.
// 
// <dl>
//   <dt>notebookGuid</dt>
//   <dd>The GUID of the notebook.</dd>
// 
//   <dt>recipientThreadId</dt>
//   <dd>The recipients of the notebook share specified as a messaging thread ID. If you
//       have an existing messaging thread to share the note with, specify its ID
//       here instead of recipientContacts in order to properly support defunct
//       identities. The sharer must be a participant of the thread. Either this field
//       or recipientContacts must be set.</dd>
// 
//   <dt>recipientContacts</dt>
//   <dd>The recipients of the notebook share specified as a list of contacts. This should
//       only be set if the sharing takes place before the thread is created. Use
//       recipientThreadId instead when sharing with an existing thread. Either this
//       field or recipientThreadId must be set.</dd>
// 
//   <dt>privilege</dt>
//   <dd>The privilege level to be granted.</dd>
// </dl>
// 
// Attributes:
//  - NotebookGuid
//  - RecipientThreadId
//  - RecipientContacts
//  - Privilege
type NotebookShareTemplate struct {
  NotebookGuid *GUID `thrift:"notebookGuid,1" db:"notebookGuid" json:"notebookGuid,omitempty"`
  RecipientContacts []*Contact `thrift:"recipientContacts,2" db:"recipientContacts" json:"recipientContacts,omitempty"`
  Privilege *SharedNotebookPrivilegeLevel `thrift:"privilege,3" db:"privilege" json:"privilege,omitempty"`
  RecipientThreadId *MessageThreadID `thrift:"recipientThreadId,4" db:"recipientThreadId" json:"recipientThreadId,omitempty"`
}

func NewNotebookShareTemplate() *NotebookShareTemplate {
  return &NotebookShareTemplate{}
}

var NotebookShareTemplate_NotebookGuid_DEFAULT GUID
func (p *NotebookShareTemplate) GetNotebookGuid() GUID {
  if !p.IsSetNotebookGuid() {
    return NotebookShareTemplate_NotebookGuid_DEFAULT
  }
return *p.NotebookGuid
}
var NotebookShareTemplate_RecipientThreadId_DEFAULT MessageThreadID
func (p *NotebookShareTemplate) GetRecipientThreadId() MessageThreadID {
  if !p.IsSetRecipientThreadId() {
    return NotebookShareTemplate_RecipientThreadId_DEFAULT
  }
return *p.RecipientThreadId
}
var NotebookShareTemplate_RecipientContacts_DEFAULT []*Contact

func (p *NotebookShareTemplate) GetRecipientContacts() []*Contact {
  return p.RecipientContacts
}
var NotebookShareTemplate_Privilege_DEFAULT SharedNotebookPrivilegeLevel
func (p *NotebookShareTemplate) GetPrivilege() SharedNotebookPrivilegeLevel {
  if !p.IsSetPrivilege() {
    return NotebookShareTemplate_Privilege_DEFAULT
  }
return *p.Privilege
}
func (p *NotebookShareTemplate) IsSetNotebookGuid() bool {
  return p.NotebookGuid != nil
}

func (p *NotebookShareTemplate) IsSetRecipientThreadId() bool {
  return p.RecipientThreadId != nil
}

func (p *NotebookShareTemplate) IsSetRecipientContacts() bool {
  return p.RecipientContacts != nil
}

func (p *NotebookShareTemplate) IsSetPrivilege() bool {
  return p.Privilege != nil
}

func (p *NotebookShareTemplate) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NotebookShareTemplate)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := GUID(v)
  p.NotebookGuid = &temp
}
  return nil
}

func (p *NotebookShareTemplate)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := MessageThreadID(v)
  p.RecipientThreadId = &temp
}
  return nil
}

func (p *NotebookShareTemplate)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Contact, 0, size)
  p.RecipientContacts =  tSlice
  for i := 0; i < size; i ++ {
    _elem78 := &Contact{}
    if err := _elem78.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem78), err)
    }
    p.RecipientContacts = append(p.RecipientContacts, _elem78)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NotebookShareTemplate)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := SharedNotebookPrivilegeLevel(v)
  p.Privilege = &temp
}
  return nil
}

func (p *NotebookShareTemplate) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NotebookShareTemplate"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NotebookShareTemplate) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotebookGuid() {
    if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notebookGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NotebookGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notebookGuid: ", p), err) }
  }
  return err
}

func (p *NotebookShareTemplate) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientContacts() {
    if err := oprot.WriteFieldBegin(ctx, "recipientContacts", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:recipientContacts: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.RecipientContacts)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.RecipientContacts {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:recipientContacts: ", p), err) }
  }
  return err
}

func (p *NotebookShareTemplate) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "privilege", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:privilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Privilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.privilege (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:privilege: ", p), err) }
  }
  return err
}

func (p *NotebookShareTemplate) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientThreadId() {
    if err := oprot.WriteFieldBegin(ctx, "recipientThreadId", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:recipientThreadId: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.RecipientThreadId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.recipientThreadId (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:recipientThreadId: ", p), err) }
  }
  return err
}

func (p *NotebookShareTemplate) Equals(other *NotebookShareTemplate) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NotebookGuid != other.NotebookGuid {
    if p.NotebookGuid == nil || other.NotebookGuid == nil {
      return false
    }
    if (*p.NotebookGuid) != (*other.NotebookGuid) { return false }
  }
  if len(p.RecipientContacts) != len(other.RecipientContacts) { return false }
  for i, _tgt := range p.RecipientContacts {
    _src79 := other.RecipientContacts[i]
    if !_tgt.Equals(_src79) { return false }
  }
  if p.Privilege != other.Privilege {
    if p.Privilege == nil || other.Privilege == nil {
      return false
    }
    if (*p.Privilege) != (*other.Privilege) { return false }
  }
  if p.RecipientThreadId != other.RecipientThreadId {
    if p.RecipientThreadId == nil || other.RecipientThreadId == nil {
      return false
    }
    if (*p.RecipientThreadId) != (*other.RecipientThreadId) { return false }
  }
  return true
}

func (p *NotebookShareTemplate) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NotebookShareTemplate(%+v)", *p)
}

// A structure containing the results of a call to createOrUpdateNotebookShares.
// 
// <dl>
//   <dt>updateSequenceNum</dt>
//   <dd>The USN of the notebook after the call.</dd>
// 
//   <dt>matchingShares</dt>
//   <dd>A list of SharedNotebook records that match the desired recipients. These
//       records may have been either created or updated by the call to
//       createOrUpdateNotebookShares, or they may have been at the desired privilege
//       privilege level prior to the call.</dd>
// </dl>
// 
// Attributes:
//  - UpdateSequenceNum
//  - MatchingShares
type CreateOrUpdateNotebookSharesResult_ struct {
  UpdateSequenceNum *int32 `thrift:"updateSequenceNum,1" db:"updateSequenceNum" json:"updateSequenceNum,omitempty"`
  MatchingShares []*SharedNotebook `thrift:"matchingShares,2" db:"matchingShares" json:"matchingShares,omitempty"`
}

func NewCreateOrUpdateNotebookSharesResult_() *CreateOrUpdateNotebookSharesResult_ {
  return &CreateOrUpdateNotebookSharesResult_{}
}

var CreateOrUpdateNotebookSharesResult__UpdateSequenceNum_DEFAULT int32
func (p *CreateOrUpdateNotebookSharesResult_) GetUpdateSequenceNum() int32 {
  if !p.IsSetUpdateSequenceNum() {
    return CreateOrUpdateNotebookSharesResult__UpdateSequenceNum_DEFAULT
  }
return *p.UpdateSequenceNum
}
var CreateOrUpdateNotebookSharesResult__MatchingShares_DEFAULT []*SharedNotebook

func (p *CreateOrUpdateNotebookSharesResult_) GetMatchingShares() []*SharedNotebook {
  return p.MatchingShares
}
func (p *CreateOrUpdateNotebookSharesResult_) IsSetUpdateSequenceNum() bool {
  return p.UpdateSequenceNum != nil
}

func (p *CreateOrUpdateNotebookSharesResult_) IsSetMatchingShares() bool {
  return p.MatchingShares != nil
}

func (p *CreateOrUpdateNotebookSharesResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CreateOrUpdateNotebookSharesResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.UpdateSequenceNum = &v
}
  return nil
}

func (p *CreateOrUpdateNotebookSharesResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SharedNotebook, 0, size)
  p.MatchingShares =  tSlice
  for i := 0; i < size; i ++ {
    _elem80 := &SharedNotebook{}
    if err := _elem80.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem80), err)
    }
    p.MatchingShares = append(p.MatchingShares, _elem80)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CreateOrUpdateNotebookSharesResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CreateOrUpdateNotebookSharesResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CreateOrUpdateNotebookSharesResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateSequenceNum() {
    if err := oprot.WriteFieldBegin(ctx, "updateSequenceNum", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:updateSequenceNum: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.UpdateSequenceNum)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.updateSequenceNum (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:updateSequenceNum: ", p), err) }
  }
  return err
}

func (p *CreateOrUpdateNotebookSharesResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMatchingShares() {
    if err := oprot.WriteFieldBegin(ctx, "matchingShares", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:matchingShares: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.MatchingShares)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.MatchingShares {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:matchingShares: ", p), err) }
  }
  return err
}

func (p *CreateOrUpdateNotebookSharesResult_) Equals(other *CreateOrUpdateNotebookSharesResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.UpdateSequenceNum != other.UpdateSequenceNum {
    if p.UpdateSequenceNum == nil || other.UpdateSequenceNum == nil {
      return false
    }
    if (*p.UpdateSequenceNum) != (*other.UpdateSequenceNum) { return false }
  }
  if len(p.MatchingShares) != len(other.MatchingShares) { return false }
  for i, _tgt := range p.MatchingShares {
    _src81 := other.MatchingShares[i]
    if !_tgt.Equals(_src81) { return false }
  }
  return true
}

func (p *CreateOrUpdateNotebookSharesResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CreateOrUpdateNotebookSharesResult_(%+v)", *p)
}

// This structure is used by the service to communicate to clients, via
// getNoteShareRelationships, which privilege levels are assignable to the
// target of a note share relationship.
// 
// <dl>
// <dt>noSetReadNote</dt>
// <dd>This value is true if the user is not allowed to set the privilege
// level to SharedNotePrivilegeLevel.READ_NOTE.</dd>
// 
// <dt>noSetModifyNote</dt>
// <dd>This value is true if the user is not allowed to set the privilege
// level to SharedNotePrivilegeLevel.MODIFY_NOTE.</dd>
// 
// <dt>noSetFullAccess</dt>
// <dd>This value is true if the user is not allowed to set the
// privilege level to SharedNotePrivilegeLevel.FULL_ACCESS.</dd>
// </dl>
// 
// Attributes:
//  - NoSetReadNote
//  - NoSetModifyNote
//  - NoSetFullAccess
type NoteShareRelationshipRestrictions struct {
  NoSetReadNote *bool `thrift:"noSetReadNote,1" db:"noSetReadNote" json:"noSetReadNote,omitempty"`
  NoSetModifyNote *bool `thrift:"noSetModifyNote,2" db:"noSetModifyNote" json:"noSetModifyNote,omitempty"`
  NoSetFullAccess *bool `thrift:"noSetFullAccess,3" db:"noSetFullAccess" json:"noSetFullAccess,omitempty"`
}

func NewNoteShareRelationshipRestrictions() *NoteShareRelationshipRestrictions {
  return &NoteShareRelationshipRestrictions{}
}

var NoteShareRelationshipRestrictions_NoSetReadNote_DEFAULT bool
func (p *NoteShareRelationshipRestrictions) GetNoSetReadNote() bool {
  if !p.IsSetNoSetReadNote() {
    return NoteShareRelationshipRestrictions_NoSetReadNote_DEFAULT
  }
return *p.NoSetReadNote
}
var NoteShareRelationshipRestrictions_NoSetModifyNote_DEFAULT bool
func (p *NoteShareRelationshipRestrictions) GetNoSetModifyNote() bool {
  if !p.IsSetNoSetModifyNote() {
    return NoteShareRelationshipRestrictions_NoSetModifyNote_DEFAULT
  }
return *p.NoSetModifyNote
}
var NoteShareRelationshipRestrictions_NoSetFullAccess_DEFAULT bool
func (p *NoteShareRelationshipRestrictions) GetNoSetFullAccess() bool {
  if !p.IsSetNoSetFullAccess() {
    return NoteShareRelationshipRestrictions_NoSetFullAccess_DEFAULT
  }
return *p.NoSetFullAccess
}
func (p *NoteShareRelationshipRestrictions) IsSetNoSetReadNote() bool {
  return p.NoSetReadNote != nil
}

func (p *NoteShareRelationshipRestrictions) IsSetNoSetModifyNote() bool {
  return p.NoSetModifyNote != nil
}

func (p *NoteShareRelationshipRestrictions) IsSetNoSetFullAccess() bool {
  return p.NoSetFullAccess != nil
}

func (p *NoteShareRelationshipRestrictions) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteShareRelationshipRestrictions)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NoSetReadNote = &v
}
  return nil
}

func (p *NoteShareRelationshipRestrictions)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NoSetModifyNote = &v
}
  return nil
}

func (p *NoteShareRelationshipRestrictions)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NoSetFullAccess = &v
}
  return nil
}

func (p *NoteShareRelationshipRestrictions) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteShareRelationshipRestrictions"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteShareRelationshipRestrictions) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetReadNote() {
    if err := oprot.WriteFieldBegin(ctx, "noSetReadNote", thrift.BOOL, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:noSetReadNote: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetReadNote)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetReadNote (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:noSetReadNote: ", p), err) }
  }
  return err
}

func (p *NoteShareRelationshipRestrictions) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetModifyNote() {
    if err := oprot.WriteFieldBegin(ctx, "noSetModifyNote", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noSetModifyNote: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetModifyNote)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetModifyNote (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noSetModifyNote: ", p), err) }
  }
  return err
}

func (p *NoteShareRelationshipRestrictions) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoSetFullAccess() {
    if err := oprot.WriteFieldBegin(ctx, "noSetFullAccess", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:noSetFullAccess: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.NoSetFullAccess)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noSetFullAccess (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:noSetFullAccess: ", p), err) }
  }
  return err
}

func (p *NoteShareRelationshipRestrictions) Equals(other *NoteShareRelationshipRestrictions) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NoSetReadNote != other.NoSetReadNote {
    if p.NoSetReadNote == nil || other.NoSetReadNote == nil {
      return false
    }
    if (*p.NoSetReadNote) != (*other.NoSetReadNote) { return false }
  }
  if p.NoSetModifyNote != other.NoSetModifyNote {
    if p.NoSetModifyNote == nil || other.NoSetModifyNote == nil {
      return false
    }
    if (*p.NoSetModifyNote) != (*other.NoSetModifyNote) { return false }
  }
  if p.NoSetFullAccess != other.NoSetFullAccess {
    if p.NoSetFullAccess == nil || other.NoSetFullAccess == nil {
      return false
    }
    if (*p.NoSetFullAccess) != (*other.NoSetFullAccess) { return false }
  }
  return true
}

func (p *NoteShareRelationshipRestrictions) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteShareRelationshipRestrictions(%+v)", *p)
}

// Describes the association between a Note and an Evernote User who is
// a member of that note.
// 
// <dl>
// <dt>displayName</dt>
// <dd>The string that clients should show to users to represent this
// member.</dd>
// 
// <dt>recipientUserId</dt>
// <dd>The Evernote UserID of the user who is a member to the note.</dd>
// 
// <dt>privilege</dt>
// <dd>The privilege at which the member can access the note,
// which is the best privilege granted to the user across all of their
// individual shares for this note. This field is used by the service
// to convey information to the user, so clients should treat it as
// read-only.</dd>
// 
// <dt>restrictions</dt>
// <dd>The restrictions on which privileges may be individually
// assigned to the recipient of this share relationship. This field
// is used by the service to convey information to the user, so
// clients should treat it as read-only.</dd>
// 
// <dt>sharerUserId</dt>
// <dd>The user id of the user who most recently shared the note with
// this user. This field is used by the service to convey information
// to the user, so clients should treat it as read-only.</dd>
// </dl>
// 
// Attributes:
//  - DisplayName
//  - RecipientUserId
//  - Privilege
//  - Restrictions
//  - SharerUserId
type NoteMemberShareRelationship struct {
  DisplayName *string `thrift:"displayName,1" db:"displayName" json:"displayName,omitempty"`
  RecipientUserId *UserID `thrift:"recipientUserId,2" db:"recipientUserId" json:"recipientUserId,omitempty"`
  Privilege *SharedNotePrivilegeLevel `thrift:"privilege,3" db:"privilege" json:"privilege,omitempty"`
  Restrictions *NoteShareRelationshipRestrictions `thrift:"restrictions,4" db:"restrictions" json:"restrictions,omitempty"`
  SharerUserId *UserID `thrift:"sharerUserId,5" db:"sharerUserId" json:"sharerUserId,omitempty"`
}

func NewNoteMemberShareRelationship() *NoteMemberShareRelationship {
  return &NoteMemberShareRelationship{}
}

var NoteMemberShareRelationship_DisplayName_DEFAULT string
func (p *NoteMemberShareRelationship) GetDisplayName() string {
  if !p.IsSetDisplayName() {
    return NoteMemberShareRelationship_DisplayName_DEFAULT
  }
return *p.DisplayName
}
var NoteMemberShareRelationship_RecipientUserId_DEFAULT UserID
func (p *NoteMemberShareRelationship) GetRecipientUserId() UserID {
  if !p.IsSetRecipientUserId() {
    return NoteMemberShareRelationship_RecipientUserId_DEFAULT
  }
return *p.RecipientUserId
}
var NoteMemberShareRelationship_Privilege_DEFAULT SharedNotePrivilegeLevel
func (p *NoteMemberShareRelationship) GetPrivilege() SharedNotePrivilegeLevel {
  if !p.IsSetPrivilege() {
    return NoteMemberShareRelationship_Privilege_DEFAULT
  }
return *p.Privilege
}
var NoteMemberShareRelationship_Restrictions_DEFAULT *NoteShareRelationshipRestrictions
func (p *NoteMemberShareRelationship) GetRestrictions() *NoteShareRelationshipRestrictions {
  if !p.IsSetRestrictions() {
    return NoteMemberShareRelationship_Restrictions_DEFAULT
  }
return p.Restrictions
}
var NoteMemberShareRelationship_SharerUserId_DEFAULT UserID
func (p *NoteMemberShareRelationship) GetSharerUserId() UserID {
  if !p.IsSetSharerUserId() {
    return NoteMemberShareRelationship_SharerUserId_DEFAULT
  }
return *p.SharerUserId
}
func (p *NoteMemberShareRelationship) IsSetDisplayName() bool {
  return p.DisplayName != nil
}

func (p *NoteMemberShareRelationship) IsSetRecipientUserId() bool {
  return p.RecipientUserId != nil
}

func (p *NoteMemberShareRelationship) IsSetPrivilege() bool {
  return p.Privilege != nil
}

func (p *NoteMemberShareRelationship) IsSetRestrictions() bool {
  return p.Restrictions != nil
}

func (p *NoteMemberShareRelationship) IsSetSharerUserId() bool {
  return p.SharerUserId != nil
}

func (p *NoteMemberShareRelationship) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteMemberShareRelationship)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DisplayName = &v
}
  return nil
}

func (p *NoteMemberShareRelationship)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := UserID(v)
  p.RecipientUserId = &temp
}
  return nil
}

func (p *NoteMemberShareRelationship)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := SharedNotePrivilegeLevel(v)
  p.Privilege = &temp
}
  return nil
}

func (p *NoteMemberShareRelationship)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Restrictions = &NoteShareRelationshipRestrictions{}
  if err := p.Restrictions.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Restrictions), err)
  }
  return nil
}

func (p *NoteMemberShareRelationship)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := UserID(v)
  p.SharerUserId = &temp
}
  return nil
}

func (p *NoteMemberShareRelationship) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteMemberShareRelationship"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteMemberShareRelationship) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDisplayName() {
    if err := oprot.WriteFieldBegin(ctx, "displayName", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:displayName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DisplayName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.displayName (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:displayName: ", p), err) }
  }
  return err
}

func (p *NoteMemberShareRelationship) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientUserId() {
    if err := oprot.WriteFieldBegin(ctx, "recipientUserId", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:recipientUserId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.RecipientUserId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.recipientUserId (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:recipientUserId: ", p), err) }
  }
  return err
}

func (p *NoteMemberShareRelationship) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "privilege", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:privilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Privilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.privilege (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:privilege: ", p), err) }
  }
  return err
}

func (p *NoteMemberShareRelationship) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRestrictions() {
    if err := oprot.WriteFieldBegin(ctx, "restrictions", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:restrictions: ", p), err) }
    if err := p.Restrictions.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Restrictions), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:restrictions: ", p), err) }
  }
  return err
}

func (p *NoteMemberShareRelationship) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSharerUserId() {
    if err := oprot.WriteFieldBegin(ctx, "sharerUserId", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:sharerUserId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.SharerUserId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.sharerUserId (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:sharerUserId: ", p), err) }
  }
  return err
}

func (p *NoteMemberShareRelationship) Equals(other *NoteMemberShareRelationship) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DisplayName != other.DisplayName {
    if p.DisplayName == nil || other.DisplayName == nil {
      return false
    }
    if (*p.DisplayName) != (*other.DisplayName) { return false }
  }
  if p.RecipientUserId != other.RecipientUserId {
    if p.RecipientUserId == nil || other.RecipientUserId == nil {
      return false
    }
    if (*p.RecipientUserId) != (*other.RecipientUserId) { return false }
  }
  if p.Privilege != other.Privilege {
    if p.Privilege == nil || other.Privilege == nil {
      return false
    }
    if (*p.Privilege) != (*other.Privilege) { return false }
  }
  if !p.Restrictions.Equals(other.Restrictions) { return false }
  if p.SharerUserId != other.SharerUserId {
    if p.SharerUserId == nil || other.SharerUserId == nil {
      return false
    }
    if (*p.SharerUserId) != (*other.SharerUserId) { return false }
  }
  return true
}

func (p *NoteMemberShareRelationship) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteMemberShareRelationship(%+v)", *p)
}

// Describes an invitation to a person to use their Evernote credentials
// to gain access to a note belonging to another user.
// 
// <dl>
// <dt>displayName</dt>
// <dd>The string that clients should show to users to represent this
// invitation.</dd>
// 
// <dt>recipientIdentityId</dt>
// <dd>Identifies the identity of the invitation recipient. Once the
// identity has been claimed by an Evernote user and they have accessed
// the note at least once, the invitation will be used up and will no
// longer be returned by the service to clients. Instead, that recipient
// will be included in the list of NoteMemberShareRelationships.</dd>
// 
// <dt>privilege</dt>
// <dd>The privilege level that the recipient will be granted when they
// accept this invitation. If the user already has a higher privilege to
// access this note then this will not affect the recipient's privileges.</dd>
// 
// <dt>sharerUserId</dt>
// <dd>The user id of the user who most recently shared this note to this
// recipient. This field is used by the service to convey information
// to the user, so clients should treat it as read-only.</dd>
// 
// Attributes:
//  - DisplayName
//  - RecipientIdentityId
//  - Privilege
//  - SharerUserId
type NoteInvitationShareRelationship struct {
  DisplayName *string `thrift:"displayName,1" db:"displayName" json:"displayName,omitempty"`
  RecipientIdentityId *IdentityID `thrift:"recipientIdentityId,2" db:"recipientIdentityId" json:"recipientIdentityId,omitempty"`
  Privilege *SharedNotePrivilegeLevel `thrift:"privilege,3" db:"privilege" json:"privilege,omitempty"`
  // unused field # 4
  SharerUserId *UserID `thrift:"sharerUserId,5" db:"sharerUserId" json:"sharerUserId,omitempty"`
}

func NewNoteInvitationShareRelationship() *NoteInvitationShareRelationship {
  return &NoteInvitationShareRelationship{}
}

var NoteInvitationShareRelationship_DisplayName_DEFAULT string
func (p *NoteInvitationShareRelationship) GetDisplayName() string {
  if !p.IsSetDisplayName() {
    return NoteInvitationShareRelationship_DisplayName_DEFAULT
  }
return *p.DisplayName
}
var NoteInvitationShareRelationship_RecipientIdentityId_DEFAULT IdentityID
func (p *NoteInvitationShareRelationship) GetRecipientIdentityId() IdentityID {
  if !p.IsSetRecipientIdentityId() {
    return NoteInvitationShareRelationship_RecipientIdentityId_DEFAULT
  }
return *p.RecipientIdentityId
}
var NoteInvitationShareRelationship_Privilege_DEFAULT SharedNotePrivilegeLevel
func (p *NoteInvitationShareRelationship) GetPrivilege() SharedNotePrivilegeLevel {
  if !p.IsSetPrivilege() {
    return NoteInvitationShareRelationship_Privilege_DEFAULT
  }
return *p.Privilege
}
var NoteInvitationShareRelationship_SharerUserId_DEFAULT UserID
func (p *NoteInvitationShareRelationship) GetSharerUserId() UserID {
  if !p.IsSetSharerUserId() {
    return NoteInvitationShareRelationship_SharerUserId_DEFAULT
  }
return *p.SharerUserId
}
func (p *NoteInvitationShareRelationship) IsSetDisplayName() bool {
  return p.DisplayName != nil
}

func (p *NoteInvitationShareRelationship) IsSetRecipientIdentityId() bool {
  return p.RecipientIdentityId != nil
}

func (p *NoteInvitationShareRelationship) IsSetPrivilege() bool {
  return p.Privilege != nil
}

func (p *NoteInvitationShareRelationship) IsSetSharerUserId() bool {
  return p.SharerUserId != nil
}

func (p *NoteInvitationShareRelationship) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteInvitationShareRelationship)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DisplayName = &v
}
  return nil
}

func (p *NoteInvitationShareRelationship)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := IdentityID(v)
  p.RecipientIdentityId = &temp
}
  return nil
}

func (p *NoteInvitationShareRelationship)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := SharedNotePrivilegeLevel(v)
  p.Privilege = &temp
}
  return nil
}

func (p *NoteInvitationShareRelationship)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := UserID(v)
  p.SharerUserId = &temp
}
  return nil
}

func (p *NoteInvitationShareRelationship) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteInvitationShareRelationship"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteInvitationShareRelationship) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDisplayName() {
    if err := oprot.WriteFieldBegin(ctx, "displayName", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:displayName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.DisplayName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.displayName (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:displayName: ", p), err) }
  }
  return err
}

func (p *NoteInvitationShareRelationship) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRecipientIdentityId() {
    if err := oprot.WriteFieldBegin(ctx, "recipientIdentityId", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:recipientIdentityId: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.RecipientIdentityId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.recipientIdentityId (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:recipientIdentityId: ", p), err) }
  }
  return err
}

func (p *NoteInvitationShareRelationship) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPrivilege() {
    if err := oprot.WriteFieldBegin(ctx, "privilege", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:privilege: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Privilege)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.privilege (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:privilege: ", p), err) }
  }
  return err
}

func (p *NoteInvitationShareRelationship) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSharerUserId() {
    if err := oprot.WriteFieldBegin(ctx, "sharerUserId", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:sharerUserId: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.SharerUserId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.sharerUserId (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:sharerUserId: ", p), err) }
  }
  return err
}

func (p *NoteInvitationShareRelationship) Equals(other *NoteInvitationShareRelationship) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DisplayName != other.DisplayName {
    if p.DisplayName == nil || other.DisplayName == nil {
      return false
    }
    if (*p.DisplayName) != (*other.DisplayName) { return false }
  }
  if p.RecipientIdentityId != other.RecipientIdentityId {
    if p.RecipientIdentityId == nil || other.RecipientIdentityId == nil {
      return false
    }
    if (*p.RecipientIdentityId) != (*other.RecipientIdentityId) { return false }
  }
  if p.Privilege != other.Privilege {
    if p.Privilege == nil || other.Privilege == nil {
      return false
    }
    if (*p.Privilege) != (*other.Privilege) { return false }
  }
  if p.SharerUserId != other.SharerUserId {
    if p.SharerUserId == nil || other.SharerUserId == nil {
      return false
    }
    if (*p.SharerUserId) != (*other.SharerUserId) { return false }
  }
  return true
}

func (p *NoteInvitationShareRelationship) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteInvitationShareRelationship(%+v)", *p)
}

// Captures a collection of share relationships for a single note,
// for example, as returned by the getNoteShares method. The share
// relationships fall into two broad categories: members, and
// invitations that can be used to become members.
// 
// <dl>
// <dt>invitations</dt>
// <dd>A list of open invitations that can be redeemed into
// memberships to the note.</dd>
// 
// <dt>memberships</dt>
// <dd>A list of memberships of the noteb. A member is identified
// by their Evernote UserID and has rights to access the
// note.</dd>
// 
// <dt>restrictions</dt>
// <dd>The restrictions on which privileges may be assigned to the recipient
// of an open invitation. These restrictions only apply to invitations;
// restrictions on memberships are specified on the NoteMemberShareRelationship.
// This field is used by the service to convey information to the user, so
// clients should treat it as read-only.</dd>
// 
// </dl>
// 
// Attributes:
//  - Invitations
//  - Memberships
//  - InvitationRestrictions
type NoteShareRelationships struct {
  Invitations []*NoteInvitationShareRelationship `thrift:"invitations,1" db:"invitations" json:"invitations,omitempty"`
  Memberships []*NoteMemberShareRelationship `thrift:"memberships,2" db:"memberships" json:"memberships,omitempty"`
  InvitationRestrictions *NoteShareRelationshipRestrictions `thrift:"invitationRestrictions,3" db:"invitationRestrictions" json:"invitationRestrictions,omitempty"`
}

func NewNoteShareRelationships() *NoteShareRelationships {
  return &NoteShareRelationships{}
}

var NoteShareRelationships_Invitations_DEFAULT []*NoteInvitationShareRelationship

func (p *NoteShareRelationships) GetInvitations() []*NoteInvitationShareRelationship {
  return p.Invitations
}
var NoteShareRelationships_Memberships_DEFAULT []*NoteMemberShareRelationship

func (p *NoteShareRelationships) GetMemberships() []*NoteMemberShareRelationship {
  return p.Memberships
}
var NoteShareRelationships_InvitationRestrictions_DEFAULT *NoteShareRelationshipRestrictions
func (p *NoteShareRelationships) GetInvitationRestrictions() *NoteShareRelationshipRestrictions {
  if !p.IsSetInvitationRestrictions() {
    return NoteShareRelationships_InvitationRestrictions_DEFAULT
  }
return p.InvitationRestrictions
}
func (p *NoteShareRelationships) IsSetInvitations() bool {
  return p.Invitations != nil
}

func (p *NoteShareRelationships) IsSetMemberships() bool {
  return p.Memberships != nil
}

func (p *NoteShareRelationships) IsSetInvitationRestrictions() bool {
  return p.InvitationRestrictions != nil
}

func (p *NoteShareRelationships) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteShareRelationships)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NoteInvitationShareRelationship, 0, size)
  p.Invitations =  tSlice
  for i := 0; i < size; i ++ {
    _elem82 := &NoteInvitationShareRelationship{}
    if err := _elem82.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem82), err)
    }
    p.Invitations = append(p.Invitations, _elem82)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteShareRelationships)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NoteMemberShareRelationship, 0, size)
  p.Memberships =  tSlice
  for i := 0; i < size; i ++ {
    _elem83 := &NoteMemberShareRelationship{}
    if err := _elem83.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem83), err)
    }
    p.Memberships = append(p.Memberships, _elem83)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteShareRelationships)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.InvitationRestrictions = &NoteShareRelationshipRestrictions{}
  if err := p.InvitationRestrictions.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.InvitationRestrictions), err)
  }
  return nil
}

func (p *NoteShareRelationships) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NoteShareRelationships"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteShareRelationships) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitations() {
    if err := oprot.WriteFieldBegin(ctx, "invitations", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:invitations: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Invitations)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Invitations {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:invitations: ", p), err) }
  }
  return err
}

func (p *NoteShareRelationships) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMemberships() {
    if err := oprot.WriteFieldBegin(ctx, "memberships", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:memberships: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Memberships)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Memberships {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:memberships: ", p), err) }
  }
  return err
}

func (p *NoteShareRelationships) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitationRestrictions() {
    if err := oprot.WriteFieldBegin(ctx, "invitationRestrictions", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:invitationRestrictions: ", p), err) }
    if err := p.InvitationRestrictions.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.InvitationRestrictions), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:invitationRestrictions: ", p), err) }
  }
  return err
}

func (p *NoteShareRelationships) Equals(other *NoteShareRelationships) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Invitations) != len(other.Invitations) { return false }
  for i, _tgt := range p.Invitations {
    _src84 := other.Invitations[i]
    if !_tgt.Equals(_src84) { return false }
  }
  if len(p.Memberships) != len(other.Memberships) { return false }
  for i, _tgt := range p.Memberships {
    _src85 := other.Memberships[i]
    if !_tgt.Equals(_src85) { return false }
  }
  if !p.InvitationRestrictions.Equals(other.InvitationRestrictions) { return false }
  return true
}

func (p *NoteShareRelationships) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteShareRelationships(%+v)", *p)
}

// Captures parameters used by clients to manage the shares for a given
// note via the manageNoteShares function. This is used only to manage
// the existing memberships and invitations for a note. To invite a new
// recipient, use NoteStore.createOrUpdateSharedNotes.
// 
// The only field of an existing membership or invitation that can be
// updated by this function is the share privilege.
// 
// <dl>
//   <dt>noteGuid</dt>
//   <dd>The GUID of the note whose shares are being managed.</dd>
// 
//   <dt>membershipsToUpdate</dt>
//   <dd>A list of existing memberships to update. This field is not
//     meant to be the full set of memberships for the note. Clients
//     should only include those existing memberships that they wish
//     to modify. To remove an existing membership, see the unshares
//     field.</dd>
// 
//   <dt>invitationsToUpdate</dt>
//   <dd>The list of outstanding invitations to update, as matched by the
//     identity field of the NoteInvitationShareRelatioship instances.
//     This field is not meant to be the full set of invitations for the
//     note. Clients should only include those existing invitations that
//     they wish to modify.</dd>
// 
//   <dt>membershipsToUnshare</dt>
//   <dd>A list of existing memberships to expunge from the service.</dd>
// 
//   <dt>invitationsToUnshare</dt>
//   <dd>A list of outstanding invitations to expunge from the service.</dd>
// </dl>
// 
// Attributes:
//  - NoteGuid
//  - MembershipsToUpdate
//  - InvitationsToUpdate
//  - MembershipsToUnshare
//  - InvitationsToUnshare
type ManageNoteSharesParameters struct {
  NoteGuid *string `thrift:"noteGuid,1" db:"noteGuid" json:"noteGuid,omitempty"`
  MembershipsToUpdate []*NoteMemberShareRelationship `thrift:"membershipsToUpdate,2" db:"membershipsToUpdate" json:"membershipsToUpdate,omitempty"`
  InvitationsToUpdate []*NoteInvitationShareRelationship `thrift:"invitationsToUpdate,3" db:"invitationsToUpdate" json:"invitationsToUpdate,omitempty"`
  MembershipsToUnshare []UserID `thrift:"membershipsToUnshare,4" db:"membershipsToUnshare" json:"membershipsToUnshare,omitempty"`
  InvitationsToUnshare []IdentityID `thrift:"invitationsToUnshare,5" db:"invitationsToUnshare" json:"invitationsToUnshare,omitempty"`
}

func NewManageNoteSharesParameters() *ManageNoteSharesParameters {
  return &ManageNoteSharesParameters{}
}

var ManageNoteSharesParameters_NoteGuid_DEFAULT string
func (p *ManageNoteSharesParameters) GetNoteGuid() string {
  if !p.IsSetNoteGuid() {
    return ManageNoteSharesParameters_NoteGuid_DEFAULT
  }
return *p.NoteGuid
}
var ManageNoteSharesParameters_MembershipsToUpdate_DEFAULT []*NoteMemberShareRelationship

func (p *ManageNoteSharesParameters) GetMembershipsToUpdate() []*NoteMemberShareRelationship {
  return p.MembershipsToUpdate
}
var ManageNoteSharesParameters_InvitationsToUpdate_DEFAULT []*NoteInvitationShareRelationship

func (p *ManageNoteSharesParameters) GetInvitationsToUpdate() []*NoteInvitationShareRelationship {
  return p.InvitationsToUpdate
}
var ManageNoteSharesParameters_MembershipsToUnshare_DEFAULT []UserID

func (p *ManageNoteSharesParameters) GetMembershipsToUnshare() []UserID {
  return p.MembershipsToUnshare
}
var ManageNoteSharesParameters_InvitationsToUnshare_DEFAULT []IdentityID

func (p *ManageNoteSharesParameters) GetInvitationsToUnshare() []IdentityID {
  return p.InvitationsToUnshare
}
func (p *ManageNoteSharesParameters) IsSetNoteGuid() bool {
  return p.NoteGuid != nil
}

func (p *ManageNoteSharesParameters) IsSetMembershipsToUpdate() bool {
  return p.MembershipsToUpdate != nil
}

func (p *ManageNoteSharesParameters) IsSetInvitationsToUpdate() bool {
  return p.InvitationsToUpdate != nil
}

func (p *ManageNoteSharesParameters) IsSetMembershipsToUnshare() bool {
  return p.MembershipsToUnshare != nil
}

func (p *ManageNoteSharesParameters) IsSetInvitationsToUnshare() bool {
  return p.InvitationsToUnshare != nil
}

func (p *ManageNoteSharesParameters) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ManageNoteSharesParameters)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NoteGuid = &v
}
  return nil
}

func (p *ManageNoteSharesParameters)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NoteMemberShareRelationship, 0, size)
  p.MembershipsToUpdate =  tSlice
  for i := 0; i < size; i ++ {
    _elem86 := &NoteMemberShareRelationship{}
    if err := _elem86.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem86), err)
    }
    p.MembershipsToUpdate = append(p.MembershipsToUpdate, _elem86)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNoteSharesParameters)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NoteInvitationShareRelationship, 0, size)
  p.InvitationsToUpdate =  tSlice
  for i := 0; i < size; i ++ {
    _elem87 := &NoteInvitationShareRelationship{}
    if err := _elem87.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem87), err)
    }
    p.InvitationsToUpdate = append(p.InvitationsToUpdate, _elem87)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNoteSharesParameters)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]UserID, 0, size)
  p.MembershipsToUnshare =  tSlice
  for i := 0; i < size; i ++ {
var _elem88 UserID
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := UserID(v)
    _elem88 = temp
}
    p.MembershipsToUnshare = append(p.MembershipsToUnshare, _elem88)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNoteSharesParameters)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]IdentityID, 0, size)
  p.InvitationsToUnshare =  tSlice
  for i := 0; i < size; i ++ {
var _elem89 IdentityID
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := IdentityID(v)
    _elem89 = temp
}
    p.InvitationsToUnshare = append(p.InvitationsToUnshare, _elem89)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNoteSharesParameters) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ManageNoteSharesParameters"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ManageNoteSharesParameters) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoteGuid() {
    if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:noteGuid: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NoteGuid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noteGuid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:noteGuid: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesParameters) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMembershipsToUpdate() {
    if err := oprot.WriteFieldBegin(ctx, "membershipsToUpdate", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:membershipsToUpdate: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.MembershipsToUpdate)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.MembershipsToUpdate {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:membershipsToUpdate: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesParameters) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitationsToUpdate() {
    if err := oprot.WriteFieldBegin(ctx, "invitationsToUpdate", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:invitationsToUpdate: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.InvitationsToUpdate)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.InvitationsToUpdate {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:invitationsToUpdate: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesParameters) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMembershipsToUnshare() {
    if err := oprot.WriteFieldBegin(ctx, "membershipsToUnshare", thrift.LIST, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:membershipsToUnshare: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.I32, len(p.MembershipsToUnshare)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.MembershipsToUnshare {
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:membershipsToUnshare: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesParameters) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvitationsToUnshare() {
    if err := oprot.WriteFieldBegin(ctx, "invitationsToUnshare", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:invitationsToUnshare: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.InvitationsToUnshare)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.InvitationsToUnshare {
      if err := oprot.WriteI64(ctx, int64(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:invitationsToUnshare: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesParameters) Equals(other *ManageNoteSharesParameters) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NoteGuid != other.NoteGuid {
    if p.NoteGuid == nil || other.NoteGuid == nil {
      return false
    }
    if (*p.NoteGuid) != (*other.NoteGuid) { return false }
  }
  if len(p.MembershipsToUpdate) != len(other.MembershipsToUpdate) { return false }
  for i, _tgt := range p.MembershipsToUpdate {
    _src90 := other.MembershipsToUpdate[i]
    if !_tgt.Equals(_src90) { return false }
  }
  if len(p.InvitationsToUpdate) != len(other.InvitationsToUpdate) { return false }
  for i, _tgt := range p.InvitationsToUpdate {
    _src91 := other.InvitationsToUpdate[i]
    if !_tgt.Equals(_src91) { return false }
  }
  if len(p.MembershipsToUnshare) != len(other.MembershipsToUnshare) { return false }
  for i, _tgt := range p.MembershipsToUnshare {
    _src92 := other.MembershipsToUnshare[i]
    if _tgt != _src92 { return false }
  }
  if len(p.InvitationsToUnshare) != len(other.InvitationsToUnshare) { return false }
  for i, _tgt := range p.InvitationsToUnshare {
    _src93 := other.InvitationsToUnshare[i]
    if _tgt != _src93 { return false }
  }
  return true
}

func (p *ManageNoteSharesParameters) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ManageNoteSharesParameters(%+v)", *p)
}

// Captures errors that occur during a call to manageNoteShares. That
// function can be run best-effort, meaning that some change requests can
// be applied while others fail. Note that some errors such as system
// exceptions may still cause the entire call to fail.
// 
// Only one of the two ID fields will be set on a given error.
// 
// Only one of the two exception fields will be set on a given error.
// 
// <dl>
//   <dt>identityID</dt>
//   <dd>The identity ID of an outstanding invitation that was not updated
//     due to the error.</dd>
// 
//   <dt>userID</dt>
//   <dd>The user ID of an existing membership that was not updated due
//     to the error.</dd>
// 
//   <dt>userException</dt>
//   <dd>If the error is represented as an EDAMUserException that would
//     have otherwise been thrown without best-effort execution.</dd>
// 
//   <dt>notFoundException</dt>
//   <dd>If the error is represented as an EDAMNotFoundException that
//     would have otherwise been thrown without best-effort execution.
//     The identifier field of the exception will be either "Identity.id"
//     or "User.id", indicating that no existing share could be found for
//     the specified recipient.</dd>
// </dl>
// 
// Attributes:
//  - IdentityID
//  - UserID
//  - UserException
//  - NotFoundException
type ManageNoteSharesError struct {
  IdentityID *IdentityID `thrift:"identityID,1" db:"identityID" json:"identityID,omitempty"`
  UserID *UserID `thrift:"userID,2" db:"userID" json:"userID,omitempty"`
  UserException *EDAMUserException `thrift:"userException,3" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,4" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewManageNoteSharesError() *ManageNoteSharesError {
  return &ManageNoteSharesError{}
}

var ManageNoteSharesError_IdentityID_DEFAULT IdentityID
func (p *ManageNoteSharesError) GetIdentityID() IdentityID {
  if !p.IsSetIdentityID() {
    return ManageNoteSharesError_IdentityID_DEFAULT
  }
return *p.IdentityID
}
var ManageNoteSharesError_UserID_DEFAULT UserID
func (p *ManageNoteSharesError) GetUserID() UserID {
  if !p.IsSetUserID() {
    return ManageNoteSharesError_UserID_DEFAULT
  }
return *p.UserID
}
var ManageNoteSharesError_UserException_DEFAULT *EDAMUserException
func (p *ManageNoteSharesError) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return ManageNoteSharesError_UserException_DEFAULT
  }
return p.UserException
}
var ManageNoteSharesError_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *ManageNoteSharesError) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return ManageNoteSharesError_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *ManageNoteSharesError) IsSetIdentityID() bool {
  return p.IdentityID != nil
}

func (p *ManageNoteSharesError) IsSetUserID() bool {
  return p.UserID != nil
}

func (p *ManageNoteSharesError) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *ManageNoteSharesError) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *ManageNoteSharesError) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ManageNoteSharesError)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := IdentityID(v)
  p.IdentityID = &temp
}
  return nil
}

func (p *ManageNoteSharesError)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := UserID(v)
  p.UserID = &temp
}
  return nil
}

func (p *ManageNoteSharesError)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *ManageNoteSharesError)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *ManageNoteSharesError) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ManageNoteSharesError"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ManageNoteSharesError) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIdentityID() {
    if err := oprot.WriteFieldBegin(ctx, "identityID", thrift.I64, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:identityID: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.IdentityID)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.identityID (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:identityID: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesError) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserID() {
    if err := oprot.WriteFieldBegin(ctx, "userID", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:userID: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.UserID)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.userID (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:userID: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesError) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:userException: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesError) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:notFoundException: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesError) Equals(other *ManageNoteSharesError) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IdentityID != other.IdentityID {
    if p.IdentityID == nil || other.IdentityID == nil {
      return false
    }
    if (*p.IdentityID) != (*other.IdentityID) { return false }
  }
  if p.UserID != other.UserID {
    if p.UserID == nil || other.UserID == nil {
      return false
    }
    if (*p.UserID) != (*other.UserID) { return false }
  }
  if !p.UserException.Equals(other.UserException) { return false }
  if !p.NotFoundException.Equals(other.NotFoundException) { return false }
  return true
}

func (p *ManageNoteSharesError) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ManageNoteSharesError(%+v)", *p)
}

// The return value of a call to the manageNoteShares function.
// 
// <dl>
//   <dt>errors</dt>
//   <dd>If the call succeeded without throwing an exception, some errors
//     might still have occurred. In that case, this field will contain the
//     list of errors.</dd>
// </dl>
// 
// Attributes:
//  - Errors
type ManageNoteSharesResult_ struct {
  Errors []*ManageNoteSharesError `thrift:"errors,1" db:"errors" json:"errors,omitempty"`
}

func NewManageNoteSharesResult_() *ManageNoteSharesResult_ {
  return &ManageNoteSharesResult_{}
}

var ManageNoteSharesResult__Errors_DEFAULT []*ManageNoteSharesError

func (p *ManageNoteSharesResult_) GetErrors() []*ManageNoteSharesError {
  return p.Errors
}
func (p *ManageNoteSharesResult_) IsSetErrors() bool {
  return p.Errors != nil
}

func (p *ManageNoteSharesResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ManageNoteSharesResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ManageNoteSharesError, 0, size)
  p.Errors =  tSlice
  for i := 0; i < size; i ++ {
    _elem94 := &ManageNoteSharesError{}
    if err := _elem94.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem94), err)
    }
    p.Errors = append(p.Errors, _elem94)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ManageNoteSharesResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ManageNoteSharesResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ManageNoteSharesResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetErrors() {
    if err := oprot.WriteFieldBegin(ctx, "errors", thrift.LIST, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:errors: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Errors)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Errors {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:errors: ", p), err) }
  }
  return err
}

func (p *ManageNoteSharesResult_) Equals(other *ManageNoteSharesResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Errors) != len(other.Errors) { return false }
  for i, _tgt := range p.Errors {
    _src95 := other.Errors[i]
    if !_tgt.Equals(_src95) { return false }
  }
  return true
}

func (p *ManageNoteSharesResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ManageNoteSharesResult_(%+v)", *p)
}

type NoteStore interface {  //Service:  NoteStore
  //<p>
  //The NoteStore service is used by EDAM clients to exchange information
  //about the collection of notes in an account. This is primarily used for
  //synchronization, but could also be used by a "thin" client without a full
  //local cache.
  //</p><p>
  //Most functions take an "authenticationToken" parameter, which is the
  //value returned by the UserStore which permits access to the account.
  //</p>
  //
  //Calls which require an authenticationToken may throw an EDAMUserException
  //for the following reasons:
  // <ul>
  //  <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
  //  <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
  //  <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
  //  <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
  //  <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
  //      to perform the requested action</li>
  //  <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
  //      that requires single sign-on, and must complete SSO before accessing business
  //      content.
  //</ul>

  // Asks the NoteStore to provide information about the status of the user
  // account corresponding to the provided authentication token.
  // 
  // Parameters:
  //  - AuthenticationToken
  GetSyncState(ctx context.Context, authenticationToken string) (_r *SyncState, _err error)
  // Asks the NoteStore to provide the state of the account in order of
  // last modification.  This request retrieves one block of the server's
  // state so that a client can make several small requests against a large
  // account rather than getting the entire state in one big message.
  // This call gives fine-grained control of the data that will
  // be received by a client by omitting data elements that a client doesn't
  // need. This may reduce network traffic and sync times.
  // 
  // @param afterUSN
  //   The client can pass this value to ask only for objects that
  //   have been updated after a certain point.  This allows the client to
  //   receive updates after its last checkpoint rather than doing a full
  //   synchronization on every pass.  The default value of "0" indicates
  //   that the client wants to get objects from the start of the account.
  // 
  // @param maxEntries
  //   The maximum number of modified objects that should be
  //   returned in the result SyncChunk.  This can be used to limit the size
  //   of each individual message to be friendly for network transfer.
  // 
  // @param filter
  //   The caller must set some of the flags in this structure to specify which
  //   data types should be returned during the synchronization.  See
  //   the SyncChunkFilter structure for information on each flag.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "afterUSN" - if negative
  //   </li>
  //   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - AfterUSN
  //  - MaxEntries
  //  - Filter
  GetFilteredSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, filter *SyncChunkFilter) (_r *SyncChunk, _err error)
  // Asks the NoteStore to provide information about the status of a linked
  // notebook that has been shared with the caller, or that is public to the
  // world.
  // This will return a result that is similar to getSyncState, but may omit
  // SyncState.uploaded if the caller doesn't have permission to write to
  // the linked notebook.
  // 
  // This function must be called on the shard that owns the referenced
  // notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
  // same as LinkedNotebook.shardId.)
  // 
  // @param authenticationToken
  //   This should be an authenticationToken for the guest who has received
  //   the invitation to the share.  (I.e. this should not be the result of
  //   NoteStore.authenticateToSharedNotebook)
  // 
  // @param linkedNotebook
  //   This structure should contain identifying information and permissions
  //   to access the notebook in question.
  // 
  // @throws EDAMUserException <ul>
  //   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
  //       populated with the current username of the owner of the notebook for which
  //       you are obtaining sync state.
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
  //       correspond to a current user on the service.
  //   </li>
  // </ul>
  // 
  // @throws SystemException <ul>
  //   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
  //       user whose account is on a shard other than that on which this method was
  //       invoked.
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - LinkedNotebook
  GetLinkedNotebookSyncState(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook) (_r *SyncState, _err error)
  // Asks the NoteStore to provide information about the contents of a linked
  // notebook that has been shared with the caller, or that is public to the
  // world.
  // This will return a result that is similar to getSyncChunk, but will only
  // contain entries that are visible to the caller.  I.e. only that particular
  // Notebook will be visible, along with its Notes, and Tags on those Notes.
  // 
  // This function must be called on the shard that owns the referenced
  // notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
  // same as LinkedNotebook.shardId.)
  // 
  // @param authenticationToken
  //   This should be an authenticationToken for the guest who has received
  //   the invitation to the share.  (I.e. this should not be the result of
  //   NoteStore.authenticateToSharedNotebook)
  // 
  // @param linkedNotebook
  //   This structure should contain identifying information and permissions
  //   to access the notebook in question.  This must contain the valid fields
  //   for either a shared notebook (e.g. shareKey)
  //   or a public notebook (e.g. username, uri)
  // 
  // @param afterUSN
  //   The client can pass this value to ask only for objects that
  //   have been updated after a certain point.  This allows the client to
  //   receive updates after its last checkpoint rather than doing a full
  //   synchronization on every pass.  The default value of "0" indicates
  //   that the client wants to get objects from the start of the account.
  // 
  // @param maxEntries
  //   The maximum number of modified objects that should be
  //   returned in the result SyncChunk.  This can be used to limit the size
  //   of each individual message to be friendly for network transfer.
  //   Applications should not request more than 256 objects at a time,
  //   and must handle the case where the service returns less than the
  //   requested number of objects in a given request even though more
  //   objects are available on the service.
  // 
  // @param fullSyncOnly
  //   If true, then the client only wants initial data for a full sync.
  //   In this case, the service will not return any expunged objects,
  //   and will not return any Resources, since these are also provided
  //   in their corresponding Notes.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "afterUSN" - if negative
  //   </li>
  //   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "LinkedNotebook" - if the provided information doesn't match any
  //     valid notebook
  //   </li>
  //   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
  //     valid notebook
  //   </li>
  //   <li> "SharedNotebook.id" - if the provided information indicates a
  //      shared notebook that no longer exists
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - LinkedNotebook
  //  - AfterUSN
  //  - MaxEntries
  //  - FullSyncOnly
  GetLinkedNotebookSyncChunk(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook, afterUSN int32, maxEntries int32, fullSyncOnly bool) (_r *SyncChunk, _err error)
  // Returns a list of all of the notebooks in the account.
  // 
  // Parameters:
  //  - AuthenticationToken
  ListNotebooks(ctx context.Context, authenticationToken string) (_r []*Notebook, _err error)
  // Returns a list of all the notebooks in a business that the user has permission to access,
  // regardless of whether the user has joined them. This includes notebooks that have been shared
  // with the entire business as well as notebooks that have been shared directly with the user.
  // 
  // @param authenticationToken A business authentication token obtained by calling
  //   UserStore.authenticateToBusiness.
  // 
  // @throws EDAMUserException <ul>
  //   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
  //     business auth token.</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  ListAccessibleBusinessNotebooks(ctx context.Context, authenticationToken string) (_r []*Notebook, _err error)
  // Returns the current state of the notebook with the provided GUID.
  // The notebook may be active or deleted (but not expunged).
  // 
  // @param guid
  //   The GUID of the notebook to be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - tag not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetNotebook(ctx context.Context, authenticationToken string, guid GUID) (_r *Notebook, _err error)
  // Returns the notebook that should be used to store new notes in the
  // user's account when no other notebooks are specified.
  // 
  // Parameters:
  //  - AuthenticationToken
  GetDefaultNotebook(ctx context.Context, authenticationToken string) (_r *Notebook, _err error)
  // Asks the service to make a notebook with the provided name.
  // 
  // @param notebook
  //   The desired fields for the notebook must be provided on this
  //   object.  The name of the notebook must be set, and either the 'active'
  //   or 'defaultNotebook' fields may be set by the client at creation.
  //   If a notebook exists in the account with the same name (via
  //   case-insensitive compare), this will throw an EDAMUserException.
  // 
  // @return
  //   The newly created Notebook.  The server-side GUID will be
  //   saved in this object's 'guid' field.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
  //   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
  //   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
  //   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
  //   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
  //   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
  //   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
  //   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
  //   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
  //        is set to 'true' for a Notebook that is not owned by the user identified by
  //        the passed authenticationToken.</li>
  //   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Notebook
  CreateNotebook(ctx context.Context, authenticationToken string, notebook *Notebook) (_r *Notebook, _err error)
  // Submits notebook changes to the service. The provided data must include the
  // notebook's guid field for identification.
  // <p />
  // The Notebook will be moved to the specified Workspace, if a non empty
  // Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
  // Notebook is in a Workspace, then it will be removed from the Workspace and a full
  // access SharedNotebook record will be ensured for the caller. If the caller does not
  // already have a full access share, either the privilege of an existing share will be
  // upgraded or a new share will be created. It is illegal to set a
  // Notebook.workspaceGuid on a Workspace backing Notebook.
  // 
  // @param notebook
  //   The notebook object containing the requested changes.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
  //   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
  //   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
  //   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
  //   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
  //   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
  //   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
  //   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
  //   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
  //        is set to 'true' for a Notebook that is not owned by the user identified by
  //        the passed authenticationToken.</li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - not found, by GUID</li>
  //   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
  //        for the GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Notebook
  UpdateNotebook(ctx context.Context, authenticationToken string, notebook *Notebook) (_r int32, _err error)
  // Permanently removes the notebook from the user's account.
  // After this action, the notebook is no longer available for undeletion, etc.
  // If the notebook contains any Notes, they will be moved to the current
  // default notebook and moved into the trash (i.e. Note.active=false).
  // <p/>
  // NOTE: This function is generally not available to third party applications.
  // Calls will result in an EDAMUserException with the error code
  // PERMISSION_DENIED.
  // 
  // @param guid
  //   The GUID of the notebook to delete.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
  //   </li>
  //   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
  //   </li>
  //   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  ExpungeNotebook(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error)
  // Returns a list of the tags in the account.  Evernote does not support
  // the undeletion of tags, so this will only include active tags.
  // 
  // Parameters:
  //  - AuthenticationToken
  ListTags(ctx context.Context, authenticationToken string) (_r []*Tag, _err error)
  // Returns a list of the tags that are applied to at least one note within
  // the provided notebook.  If the notebook is public, the authenticationToken
  // may be ignored.
  // 
  // @param notebookGuid
  //    the GUID of the notebook to use to find tags
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - notebook not found by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NotebookGuid
  ListTagsByNotebook(ctx context.Context, authenticationToken string, notebookGuid GUID) (_r []*Tag, _err error)
  // Returns the current state of the Tag with the provided GUID.
  // 
  // @param guid
  //   The GUID of the tag to be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Tag.guid" - tag not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetTag(ctx context.Context, authenticationToken string, guid GUID) (_r *Tag, _err error)
  // Asks the service to make a tag with a set of information.
  // 
  // @param tag
  //   The desired list of fields for the tag are specified in this
  //   object.  The caller must specify the tag name, and may provide
  //   the parentGUID.
  // 
  // @return
  //   The newly created Tag.  The server-side GUID will be
  //   saved in this object.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
  //   </li>
  //   <li> DATA_CONFLICT "Tag.name" - name already in use
  //   </li>
  //   <li> LIMIT_REACHED "Tag" - at max number of tags
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Tag.parentGuid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Tag
  CreateTag(ctx context.Context, authenticationToken string, tag *Tag) (_r *Tag, _err error)
  // Submits tag changes to the service.  The provided data must include
  // the tag's guid field for identification.  The service will apply
  // updates to the following tag fields:  name, parentGuid
  // 
  // @param tag
  //   The tag object containing the requested changes.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
  //   </li>
  //   <li> DATA_CONFLICT "Tag.name" - name already in use
  //   </li>
  //   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
  //   </li>
  //   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Tag.guid" - tag not found, by GUID
  //   </li>
  //   <li> "Tag.parentGuid" - parent not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Tag
  UpdateTag(ctx context.Context, authenticationToken string, tag *Tag) (_r int32, _err error)
  // Removes the provided tag from every note that is currently tagged with
  // this tag.  If this operation is successful, the tag will still be in
  // the account, but it will not be tagged on any notes.
  // 
  // This function is not indended for use by full synchronizing clients, since
  // it does not provide enough result information to the client to reconcile
  // the local state without performing a follow-up sync from the service.  This
  // is intended for "thin clients" that need to efficiently support this as
  // a UI operation.
  // 
  // @param guid
  //   The GUID of the tag to remove from all notes.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Tag.guid" - tag not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  UntagAll(ctx context.Context, authenticationToken string, guid GUID) (_err error)
  // Permanently deletes the tag with the provided GUID, if present.
  // <p/>
  // NOTE: This function is not generally available to third party applications.
  // Calls will result in an EDAMUserException with the error code
  // PERMISSION_DENIED.
  // 
  // @param guid
  //   The GUID of the tag to delete.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Tag.guid" - tag not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  ExpungeTag(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error)
  // Returns a list of the searches in the account.  Evernote does not support
  // the undeletion of searches, so this will only include active searches.
  // 
  // Parameters:
  //  - AuthenticationToken
  ListSearches(ctx context.Context, authenticationToken string) (_r []*SavedSearch, _err error)
  // Returns the current state of the search with the provided GUID.
  // 
  // @param guid
  //   The GUID of the search to be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
  //   </li>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "SavedSearch.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetSearch(ctx context.Context, authenticationToken string, guid GUID) (_r *SavedSearch, _err error)
  // Asks the service to make a saved search with a set of information.
  // 
  // @param search
  //   The desired list of fields for the search are specified in this
  //   object. The caller must specify the name and query for the
  //   search, and may optionally specify a search scope.
  //   The SavedSearch.format field is ignored by the service.
  // 
  // @return
  //   The newly created SavedSearch.  The server-side GUID will be
  //   saved in this object.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
  //   </li>
  //   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
  //   </li>
  //   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Search
  CreateSearch(ctx context.Context, authenticationToken string, search *SavedSearch) (_r *SavedSearch, _err error)
  // Submits search changes to the service. The provided data must include
  // the search's guid field for identification. The service will apply
  // updates to the following search fields: name, query, and scope.
  // 
  // @param search
  //   The search object containing the requested changes.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
  //   </li>
  //   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
  //   </li>
  //   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "SavedSearch.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Search
  UpdateSearch(ctx context.Context, authenticationToken string, search *SavedSearch) (_r int32, _err error)
  // Permanently deletes the saved search with the provided GUID, if present.
  // <p/>
  // NOTE: This function is generally not available to third party applications.
  // Calls will result in an EDAMUserException with the error code
  // PERMISSION_DENIED.
  // 
  // @param guid
  //   The GUID of the search to delete.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
  //   </li>
  //   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "SavedSearch.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  ExpungeSearch(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error)
  // Finds the position of a note within a sorted subset of all of the user's
  // notes. This may be useful for thin clients that are displaying a paginated
  // listing of a large account, which need to know where a particular note
  // sits in the list without retrieving all notes first.
  // 
  // @param authenticationToken
  //   Must be a valid token for the user's account unless the NoteFilter
  //   'notebookGuid' is the GUID of a public notebook.
  // 
  // @param filter
  //   The list of criteria that will constrain the notes to be returned.
  // 
  // @param guid
  //   The GUID of the note to be retrieved.
  // 
  // @return
  //   If the note with the provided GUID is found within the matching note
  //   list, this will return the offset of that note within that list (where
  //   the first offset is 0).  If the note is not found within the set of
  //   notes, this will return -1.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
  //   </li>
  //   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  //   </li>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - not found, by GUID
  //   </li>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Filter
  //  - GUID
  FindNoteOffset(ctx context.Context, authenticationToken string, filter *NoteFilter, guid GUID) (_r int32, _err error)
  // Used to find the high-level information about a set of the notes from a
  // user's account based on various criteria specified via a NoteFilter object.
  // <p/>
  // Web applications that wish to periodically check for new content in a user's
  // Evernote account should consider using webhooks instead of polling this API.
  // See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
  // for more information.
  // 
  // @param authenticationToken
  //   Must be a valid token for the user's account unless the NoteFilter
  //   'notebookGuid' is the GUID of a public notebook.
  // 
  // @param filter
  //   The list of criteria that will constrain the notes to be returned.
  // 
  // @param offset
  //   The numeric index of the first note to show within the sorted
  //   results.  The numbering scheme starts with "0".  This can be used for
  //   pagination.
  // 
  // @param maxNotes
  //   The maximum notes to return in this query.  The service will return a set
  //   of notes that is no larger than this number, but may return fewer notes
  //   if needed.  The NoteList.totalNotes field in the return value will
  //   indicate whether there are more values available after the returned set.
  //   Currently, the service will not return more than 250 notes in a single request,
  //   but this number may change in the future.
  // 
  // @param resultSpec
  //   This specifies which information should be returned for each matching
  //   Note. The fields on this structure can be used to eliminate data that
  //   the client doesn't need, which will reduce the time and bandwidth
  //   to receive and process the reply.
  // 
  // @return
  //   The list of notes that match the criteria.
  //   The Notes.sharedNotes field will not be set.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
  //   </li>
  //   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Filter
  //  - Offset
  //  - MaxNotes
  //  - ResultSpec
  FindNotesMetadata(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32, resultSpec *NotesMetadataResultSpec) (_r *NotesMetadataList, _err error)
  // This function is used to determine how many notes are found for each
  // notebook and tag in the user's account, given a current set of filter
  // parameters that determine the current selection.  This function will
  // return a structure that gives the note count for each notebook and tag
  // that has at least one note under the requested filter.  Any notebook or
  // tag that has zero notes in the filtered set will not be listed in the
  // reply to this function (so they can be assumed to be 0).
  // 
  // @param authenticationToken
  //   Must be a valid token for the user's account unless the NoteFilter
  //   'notebookGuid' is the GUID of a public notebook.
  // 
  // @param filter
  //   The note selection filter that is currently being applied.  The note
  //   counts are to be calculated with this filter applied to the total set
  //   of notes in the user's account.
  // 
  // @param withTrash
  //   If true, then the NoteCollectionCounts.trashCount will be calculated
  //   and supplied in the reply. Otherwise, the trash value will be omitted.
  // 
  // @throws EDAMUserException <ul>
  //   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
  //   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
  //   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - not found, by GUID</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Filter
  //  - WithTrash
  FindNoteCounts(ctx context.Context, authenticationToken string, filter *NoteFilter, withTrash bool) (_r *NoteCollectionCounts, _err error)
  // Returns the current state of the note in the service with the provided
  // GUID.  The ENML contents of the note will only be provided if the
  // 'withContent' parameter is true.  The service will include the meta-data
  // for each resource in the note, but the binary content depends
  // on whether it is explicitly requested in resultSpec parameter.
  // If the Note is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).  The applicationData
  // fields are returned as keysOnly.
  // 
  // @param authenticationToken
  //   An authentication token that grants the caller access to the requested note.
  // 
  // @param guid
  //   The GUID of the note to be retrieved.
  // 
  // @param resultSpec
  //   A structure specifying the fields of the note that the caller would like to get.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - ResultSpec
  GetNoteWithResultSpec(ctx context.Context, authenticationToken string, guid GUID, resultSpec *NoteResultSpec) (_r *Note, _err error)
  // DEPRECATED. See getNoteWithResultSpec.
  // 
  // This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
  // mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
  // populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - WithContent
  //  - WithResourcesData
  //  - WithResourcesRecognition
  //  - WithResourcesAlternateData
  GetNote(ctx context.Context, authenticationToken string, guid GUID, withContent bool, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (_r *Note, _err error)
  // Get all of the application data for the note identified by GUID,
  // with values returned within the LazyMap fullMap field.
  // If there are no applicationData entries, then a LazyMap
  // with an empty fullMap will be returned. If your application
  // only needs to fetch its own applicationData entry, use
  // getNoteApplicationDataEntry instead.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetNoteApplicationData(ctx context.Context, authenticationToken string, guid GUID) (_r *LazyMap, _err error)
  // Get the value of a single entry in the applicationData map
  // for the note identified by GUID.
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - note not found, by GUID</li>
  //   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - Key
  GetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r string, _err error)
  // Update, or create, an entry in the applicationData map for
  // the note identified by guid.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - Key
  //  - Value
  SetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string, value string) (_r int32, _err error)
  // Remove an entry identified by 'key' from the applicationData map for
  // the note identified by 'guid'. Silently ignores an unset of a
  // non-existing key.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - Key
  UnsetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r int32, _err error)
  // Returns XHTML contents of the note with the provided GUID.
  // If the Note is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).
  // 
  // @param guid
  //   The GUID of the note to be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetNoteContent(ctx context.Context, authenticationToken string, guid GUID) (_r string, _err error)
  // Returns a block of the extracted plain text contents of the note with the
  // provided GUID.  This text can be indexed for search purposes by a light
  // client that doesn't have capabilities to extract all of the searchable
  // text content from the note and its resources.
  // 
  // If the Note is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).
  // 
  // @param guid
  //   The GUID of the note to be retrieved.
  // 
  // @param noteOnly
  //   If true, this will only return the text extracted from the ENML contents
  //   of the note itself.  If false, this will also include the extracted text
  //   from any text-bearing resources (PDF, recognized images)
  // 
  // @param tokenizeForIndexing
  //   If true, this will break the text into cleanly separated and sanitized
  //   tokens.  If false, this will return the more raw text extraction, with
  //   its original punctuation, capitalization, spacing, etc.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - NoteOnly
  //  - TokenizeForIndexing
  GetNoteSearchText(ctx context.Context, authenticationToken string, guid GUID, noteOnly bool, tokenizeForIndexing bool) (_r string, _err error)
  // Returns a block of the extracted plain text contents of the resource with
  // the provided GUID.  This text can be indexed for search purposes by a light
  // client that doesn't have capability to extract all of the searchable
  // text content from a resource.
  // 
  // If the Resource is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).
  // 
  // @param guid
  //   The GUID of the resource to be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetResourceSearchText(ctx context.Context, authenticationToken string, guid GUID) (_r string, _err error)
  // Returns a list of the names of the tags for the note with the provided
  // guid.  This can be used with authentication to get the tags for a
  // user's own note, or can be used without valid authentication to retrieve
  // the names of the tags for a note in a public notebook.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetNoteTagNames(ctx context.Context, authenticationToken string, guid GUID) (_r []string, _err error)
  // Asks the service to make a note with the provided set of information.
  // 
  // @param note
  //   A Note object containing the desired fields to be populated on
  //   the service.
  // 
  // @return
  //   The newly created Note from the service.  The server-side
  //   GUIDs for the Note and any Resources will be saved in this object.
  //   The service will include the meta-data
  //   for each resource in the note, but the binary contents of the resources
  //   and their recognition data will be omitted (except Recognition Resource body,
  //   for which the behavior is unspecified).
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
  //   </li>
  //   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
  //   </li>
  //   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  //   </li>
  //   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
  //   </li>
  //   <li> DATA_REQUIRED "Resource.data" - resource data body missing
  //   </li>
  //   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  //   </li>
  //   <li> LIMIT_REACHED "Note" - at max number per account
  //   </li>
  //   <li> LIMIT_REACHED "Note.size" - total note size too large
  //   </li>
  //   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
  //   </li>
  //   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
  //   </li>
  //   <li> LIMIT_REACHED "Resource.data.size" - resource too large
  //   </li>
  //   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
  //   </li>
  //   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  //   </li>
  //   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
  //   </li>
  //   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  //   </li>
  //   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
  //     of the specified tags had an invalid length or pattern
  //   </li>
  //   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
  //     new tags would exceed the maximum number per account
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.notebookGuid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Note
  CreateNote(ctx context.Context, authenticationToken string, note *Note) (_r *Note, _err error)
  // Submit a set of changes to a note to the service.  The provided data
  // must include the note's guid field for identification. The note's
  // title must also be set.
  // 
  // @param note
  //   A Note object containing the desired fields to be populated on
  //   the service. With the exception of the note's title and guid, fields
  //   that are not being changed do not need to be set. If the content is not
  //   being modified, note.content should be left unset. If the list of
  //   resources is not being modified, note.resources should be left unset.
  // 
  // @return
  //   The Note.sharedNotes field will not be set.
  //   The service will include the meta-data
  //   for each resource in the note, but the binary contents of the resources
  //   and their recognition data will be omitted.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
  //   </li>
  //   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  //   </li>
  //   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  //   </li>
  //   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
  //   </li>
  //   <li> DATA_REQUIRED "Resource.data" - resource data body missing
  //   </li>
  //   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  //   </li>
  //   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
  //   </li>
  //   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
  //   </li>
  //   <li> LIMIT_REACHED "Note.size" - total note size too large
  //   </li>
  //   <li> LIMIT_REACHED "Resource.data.size" - resource too large
  //   </li>
  //   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
  //   </li>
  //   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  //   </li>
  //   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
  //   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
  //     modify the note's tags. note.tags must be unset.
  //   </li>
  //   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
  //     to modify the note's attributes. note.attributes must be unset.
  //   </li>
  //   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  //   </li>
  //   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
  //     of the specified tags had an invalid length or pattern
  //   </li>
  //   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
  //     new tags would exceed the maximum number per account
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - note not found, by GUID
  //   </li>
  //   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Note
  UpdateNote(ctx context.Context, authenticationToken string, note *Note) (_r *Note, _err error)
  // Moves the note into the trash. The note may still be undeleted, unless it
  // is expunged.  This is equivalent to calling updateNote() after setting
  // Note.active = false
  // 
  // @param guid
  //   The GUID of the note to delete.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
  //          update the note.
  //   </li>
  // </ul>
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
  //   </li>
  // </ul>
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  DeleteNote(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error)
  // Permanently removes a Note, and all of its Resources,
  // from the service.
  // <p/>
  // NOTE: This function is not available to third party applications.
  // Calls will result in an EDAMUserException with the error code
  // PERMISSION_DENIED.
  // 
  // @param guid
  //   The GUID of the note to delete.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> PERMISSION_DENIED "Note" - user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  ExpungeNote(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error)
  // Performs a deep copy of the Note with the provided GUID 'noteGuid' into
  // the Notebook with the provided GUID 'toNotebookGuid'.
  // The caller must be the owner of both the Note and the Notebook.
  // This creates a new Note in the destination Notebook with new content and
  // Resources that match all of the content and Resources from the original
  // Note, but with new GUID identifiers.
  // The original Note is not modified by this operation.
  // The copied note is considered as an "upload" for the purpose of upload
  // transfer limit calculation, so its size is added to the upload count for
  // the owner.
  // 
  // If the original note has been shared and has SharedNote records, the shares
  // are NOT copied.
  // 
  // @param noteGuid
  //   The GUID of the Note to copy.
  // 
  // @param toNotebookGuid
  //   The GUID of the Notebook that should receive the new Note.
  // 
  // @return
  //   The metadata for the new Note that was created.  This will include the
  //   new GUID for this Note (and any copied Resources), but will not include
  //   the content body or the binary bodies of any Resources.
  // 
  // @throws EDAMUserException <ul>
  //   <li> LIMIT_REACHED "Note" - at max number per account
  //   </li>
  //   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
  //   </li>
  //   <li> PERMISSION_DENIED "Note" - user doesn't own
  //   </li>
  //   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Notebook.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NoteGuid
  //  - ToNotebookGuid
  CopyNote(ctx context.Context, authenticationToken string, noteGuid GUID, toNotebookGuid GUID) (_r *Note, _err error)
  // Returns a list of the prior versions of a particular note that are
  // saved within the service.  These prior versions are stored to provide a
  // recovery from unintentional removal of content from a note. The identifiers
  // that are returned by this call can be used with getNoteVersion to retrieve
  // the previous note.
  // The identifiers will be listed from the most recent versions to the oldest.
  // This call is only available for notes in Premium accounts. (I.e. access
  // to past versions of Notes is a Premium-only feature.)
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
  //   </li>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID.
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NoteGuid
  ListNoteVersions(ctx context.Context, authenticationToken string, noteGuid GUID) (_r []*NoteVersionId, _err error)
  // This can be used to retrieve a previous version of a Note after it has been
  // updated within the service.  The caller must identify the note (via its
  // guid) and the version (via the updateSequenceNumber of that version).
  // to find a listing of the stored version USNs for a note, call
  // listNoteVersions.
  // This call is only available for notes in Premium accounts. (I.e. access
  // to past versions of Notes is a Premium-only feature.)
  // 
  // @param noteGuid
  //   The GUID of the note to be retrieved.
  // 
  // @param updateSequenceNum
  //   The USN of the version of the note that is being retrieved
  // 
  // @param withResourcesData
  //   If true, any Resource elements in this Note will include the binary
  //   contents of their 'data' field's body.
  // 
  // @param withResourcesRecognition
  //   If true, any Resource elements will include the binary contents of the
  //   'recognition' field's body if recognition data is present.
  // 
  // @param withResourcesAlternateData
  //   If true, any Resource elements in this Note will include the binary
  //   contents of their 'alternateData' fields' body, if an alternate form
  //   is present.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
  //   </li>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID.
  //   </li>
  //   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
  //      the corresponding USN.
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NoteGuid
  //  - UpdateSequenceNum
  //  - WithResourcesData
  //  - WithResourcesRecognition
  //  - WithResourcesAlternateData
  GetNoteVersion(ctx context.Context, authenticationToken string, noteGuid GUID, updateSequenceNum int32, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (_r *Note, _err error)
  // Returns the current state of the resource in the service with the
  // provided GUID.
  // If the Resource is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).  Only the
  // keys for the applicationData will be returned.
  // 
  // @param guid
  //   The GUID of the resource to be retrieved.
  // 
  // @param withData
  //   If true, the Resource will include the binary contents of the
  //   'data' field's body.
  // 
  // @param withRecognition
  //   If true, the Resource will include the binary contents of the
  //   'recognition' field's body if recognition data is present.
  // 
  // @param withAttributes
  //   If true, the Resource will include the attributes
  // 
  // @param withAlternateData
  //   If true, the Resource will include the binary contents of the
  //   'alternateData' field's body, if an alternate form is present.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - WithData
  //  - WithRecognition
  //  - WithAttributes
  //  - WithAlternateData
  GetResource(ctx context.Context, authenticationToken string, guid GUID, withData bool, withRecognition bool, withAttributes bool, withAlternateData bool) (_r *Resource, _err error)
  // Get all of the application data for the Resource identified by GUID,
  // with values returned within the LazyMap fullMap field.
  // If there are no applicationData entries, then a LazyMap
  // with an empty fullMap will be returned. If your application
  // only needs to fetch its own applicationData entry, use
  // getResourceApplicationDataEntry instead.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetResourceApplicationData(ctx context.Context, authenticationToken string, guid GUID) (_r *LazyMap, _err error)
  // Get the value of a single entry in the applicationData map
  // for the Resource identified by GUID.
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - Resource not found, by GUID</li>
  //   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - Key
  GetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r string, _err error)
  // Update, or create, an entry in the applicationData map for
  // the Resource identified by guid.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - Key
  //  - Value
  SetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string, value string) (_r int32, _err error)
  // Remove an entry identified by 'key' from the applicationData map for
  // the Resource identified by 'guid'.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  //  - Key
  UnsetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r int32, _err error)
  // Submit a set of changes to a resource to the service.  This can be used
  // to update the meta-data about the resource, but cannot be used to change
  // the binary contents of the resource (including the length and hash).  These
  // cannot be changed directly without creating a new resource and removing the
  // old one via updateNote.
  // 
  // @param resource
  //   A Resource object containing the desired fields to be populated on
  //   the service.  The service will attempt to update the resource with the
  //   following fields from the client:
  //   <ul>
  //      <li>guid:  must be provided to identify the resource
  //      </li>
  //      <li>mime
  //      </li>
  //      <li>width
  //      </li>
  //      <li>height
  //      </li>
  //      <li>duration
  //      </li>
  //      <li>attributes:  optional.  if present, the set of attributes will
  //           be replaced.
  //      </li>
  //   </ul>
  // 
  // @return
  //   The Update Sequence Number of the resource after the changes have been
  //   applied.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  //   </li>
  //   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  //   </li>
  //   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Resource
  UpdateResource(ctx context.Context, authenticationToken string, resource *Resource) (_r int32, _err error)
  // Returns binary data of the resource with the provided GUID.  For
  // example, if this were an image resource, this would contain the
  // raw bits of the image.
  // If the Resource is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).
  // 
  // @param guid
  //   The GUID of the resource to be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetResourceData(ctx context.Context, authenticationToken string, guid GUID) (_r []byte, _err error)
  // Returns the current state of a resource, referenced by containing
  // note GUID and resource content hash.
  // 
  // @param noteGuid
  //   The GUID of the note that holds the resource to be retrieved.
  // 
  // @param contentHash
  //   The MD5 checksum of the resource within that note. Note that
  //   this is the binary checksum, for example from Resource.data.bodyHash,
  //   and not the hex-encoded checksum that is used within an en-media
  //   tag in a note body.
  // 
  // @param withData
  //   If true, the Resource will include the binary contents of the
  //   'data' field's body.
  // 
  // @param withRecognition
  //   If true, the Resource will include the binary contents of the
  //   'recognition' field's body.
  // 
  // @param withAlternateData
  //   If true, the Resource will include the binary contents of the
  //   'alternateData' field's body, if an alternate form is present.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
  //   </li>
  //   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note" - not found, by guid
  //   </li>
  //   <li> "Resource" - not found, by hash
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NoteGuid
  //  - ContentHash
  //  - WithData
  //  - WithRecognition
  //  - WithAlternateData
  GetResourceByHash(ctx context.Context, authenticationToken string, noteGuid GUID, contentHash []byte, withData bool, withRecognition bool, withAlternateData bool) (_r *Resource, _err error)
  // Returns the binary contents of the recognition index for the resource
  // with the provided GUID.  If the caller asks about a resource that has
  // no recognition data, this will throw EDAMNotFoundException.
  // If the Resource is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).
  // 
  // @param guid
  //   The GUID of the resource whose recognition data should be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  //   <li> "Resource.recognition" - resource has no recognition
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetResourceRecognition(ctx context.Context, authenticationToken string, guid GUID) (_r []byte, _err error)
  // If the Resource with the provided GUID has an alternate data representation
  // (indicated via the Resource.alternateData field), then this request can
  // be used to retrieve the binary contents of that alternate data file.
  // If the caller asks about a resource that has no alternate data form, this
  // will throw EDAMNotFoundException.
  // 
  // @param guid
  //    The GUID of the resource whose recognition data should be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  //   <li> "Resource.alternateData" - resource has no recognition
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetResourceAlternateData(ctx context.Context, authenticationToken string, guid GUID) (_r []byte, _err error)
  // Returns the set of attributes for the Resource with the provided GUID.
  // If the Resource is found in a public notebook, the authenticationToken
  // will be ignored (so it could be an empty string).
  // 
  // @param guid
  //   The GUID of the resource whose attributes should be retrieved.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  //   </li>
  //   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Resource.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  GetResourceAttributes(ctx context.Context, authenticationToken string, guid GUID) (_r *ResourceAttributes, _err error)
  // <p>
  // Looks for a user account with the provided userId on this NoteStore
  // shard and determines whether that account contains a public notebook
  // with the given URI.  If the account is not found, or no public notebook
  // exists with this URI, this will throw an EDAMNotFoundException,
  // otherwise this will return the information for that Notebook.
  // </p>
  // <p>
  // If a notebook is visible on the web with a full URL like
  // http://www.evernote.com/pub/sethdemo/api
  // Then 'sethdemo' is the username that can be used to look up the userId,
  // and 'api' is the publicUri.
  // </p>
  // 
  // @param userId
  //    The numeric identifier for the user who owns the public notebook.
  //    To find this value based on a username string, you can invoke
  //    UserStore.getPublicUserInfo
  // 
  // @param publicUri
  //    The uri string for the public notebook, from Notebook.publishing.uri.
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li>"Publishing.uri" - not found, by URI</li>
  // </ul>
  // 
  // @throws EDAMSystemException <ul>
  //   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
  //     taken down (for all requesters).</li>
  //   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
  //     down for the requester because of an IP-based country lookup.</li>
  // </ul>
  // 
  // Parameters:
  //  - UserId
  //  - PublicUri
  GetPublicNotebook(ctx context.Context, userId UserID, publicUri string) (_r *Notebook, _err error)
  // * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
  // *
  // * Share a notebook with an email address, and optionally to a specific
  // * recipient. If an existing SharedNotebook associated with
  // * sharedNotebook.notebookGuid is found by recipientUsername or email, then
  // * the values of sharedNotebook will be used to update the existing record,
  // * else a new record will be created.
  // *
  // * If recipientUsername is set and there is already a SharedNotebook
  // * for that Notebook with that recipientUsername and the privileges on the
  // * existing notebook are lower, than on this one, this will update the
  // * privileges and sharerUserId. If there isn't an existing SharedNotebook for
  // * recipientUsername, this will create and return a shared notebook for that
  // * email and recipientUsername. If recipientUsername is not set and there
  // * already is a SharedNotebook for a Notebook for that email address and the
  // * privileges on the existing SharedNotebook are lower than on this one, this
  // * will update the privileges and sharerUserId, and return the updated
  // * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
  // * the email address.
  // *
  // * If the authenticationToken is a Business auth token, recipientUsername is
  // * set and the recipient is in the same business as the business auth token,
  // * this method will also auto-join the business user to the SharedNotebook -
  // * that is it will set serviceJoined on the SharedNotebook and create a
  // * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
  // * The LinkedNotebook creation happens out-of-band, so there will be a delay
  // * on the order of half a minute between the SharedNotebook and LinkedNotebook
  // * creation.
  // *
  // * Also handles sending an email to the email addresses: if a SharedNotebook
  // * is being created, this will send the shared notebook invite email, and
  // * if a SharedNotebook already exists, it will send the shared notebook
  // * reminder email. Both these emails contain a link to join the notebook.
  // * If the notebook is being auto-joined, it sends an email with that
  // * information to the recipient.
  // *
  // * @param authenticationToken
  // *   Must be an authentication token from the owner or a shared notebook
  // *   authentication token or business authentication token with sufficient
  // *   permissions to change invitations for a notebook.
  // *
  // * @param sharedNotebook
  // *   A shared notebook object populated with the email address of the share
  // *   recipient, the notebook guid and the access permissions. All other
  // *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
  // *   field must be explicitly set with either a true or false value.
  // *
  // * @param message
  // *   The sharer-defined message to put in the email sent out.
  // *
  // * @return
  // *   The fully populated SharedNotebook object including the server assigned
  // *   globalId which can both be used to uniquely identify the SharedNotebook.
  // *
  // * @throws EDAMUserException <ul>
  // *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
  // *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
  // *       SharedNotebook.privilegeLevel was not set.</li>
  // *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
  // *       set. requireLogin is deprecated.</li>
  // *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
  // *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
  // *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
  //         owner's account is not confirmed.</li>
  // *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
  // *       recipientSettings is set in the sharedNotebook.  Only the recipient
  // *       can set these values via the setSharedNotebookRecipientSettings
  // *       method.</li>
  // *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
  // *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
  // *   </ul>
  // * @throws EDAMNotFoundException <ul>
  // *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
  // *   </li>
  // *   </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - SharedNotebook
  //  - Message
  ShareNotebook(ctx context.Context, authenticationToken string, sharedNotebook *SharedNotebook, message string) (_r *SharedNotebook, _err error)
  // Share a notebook by a messaging thread ID or a list of contacts. This function is
  // intended to be used in conjunction with Evernote messaging, and as such does not
  // notify the recipient that a notebook has been shared with them.
  // 
  // Sharing with a subset of participants on a thread is accomplished by specifying both
  // a thread ID and a list of contacts. This ensures that even if those contacts are
  // on the thread under a deactivated identity, the correct user (the one who has the
  // given contact on the thread) receives the share.
  // 
  // @param authenticationToken
  //   An authentication token that grants the caller permission to share the notebook.
  //   This should be an owner token if the notebook is owned by the caller.
  //   If the notebook is a business notebook to which the caller has full access,
  //   this should be their business authentication token. If the notebook is a shared
  //   (non-business) notebook to which the caller has full access, this should be the
  //   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
  // 
  // @param shareTemplate
  //   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
  //   should be shared, and the recipient information.
  // 
  // @return
  //   A structure containing the USN of the Notebook after the change and a list of created
  //   or updated SharedNotebooks.
  // 
  // @throws EDAMUserException <ul>
  //   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
  //   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
  //     valid GUID</li>
  //   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
  //   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
  //     specified</li>
  //   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
  //     is not allowed.</li>
  //   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
  //     specified, either by thread ID or as a list of contacts</li>
  //   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
  //     number of shares</li>
  // </ul>
  // 
  // @throws EDAMInvalidContactsException <ul>
  //   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
  //     in shareTemplate.recipients was not syntactically valid, or if attempting to
  //     share a notebook with an Evernote identity that the sharer does not have a
  //     connection to. The exception will specify which recipients were invalid.</li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
  //   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
  //     specified, but no thread with that ID exists</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - ShareTemplate
  CreateOrUpdateNotebookShares(ctx context.Context, authenticationToken string, shareTemplate *NotebookShareTemplate) (_r *CreateOrUpdateNotebookSharesResult_, _err error)
  // @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - SharedNotebook
  UpdateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *SharedNotebook) (_r int32, _err error)
  // Set values for the recipient settings associated with a notebook share. Only the
  // recipient of the share can update their recipient settings.
  // 
  // If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
  // you must leave that field unset in recipientSettings.
  // This method will skip that field for updates and attempt to leave the existing value as
  // it is.
  // 
  // If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
  // will be either left as null or converted to false (if currently true).
  // 
  // To unset a notebook's stack, pass in the empty string for the stack field.
  // 
  // @param authenticationToken The owner authentication token for the recipient of the share.
  // 
  // @return The updated Notebook with the new recipient settings. Note that some of the
  // recipient settings may differ from what was requested. Clients should update their state
  // based on this return value.
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
  //       notebookGuid on the given shard.</li>
  //   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
  //       user and is also not published to their business.</li>
  // </ul>
  // 
  // @throws EDAMUserException <ul>
  //   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
  //       allowed to set recipient settings on the specified notebook.</li>
  //   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
  //       is allowed only for notebooks which belong to the same business as the user.</li>
  //   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
  //       to false and any of reminder* settings to true.</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NotebookGuid
  //  - RecipientSettings
  SetNotebookRecipientSettings(ctx context.Context, authenticationToken string, notebookGuid string, recipientSettings *NotebookRecipientSettings) (_r *Notebook, _err error)
  // Lists the collection of shared notebooks for all notebooks in the
  // users account.
  // 
  // @return
  //  The list of all SharedNotebooks for the user
  // 
  // Parameters:
  //  - AuthenticationToken
  ListSharedNotebooks(ctx context.Context, authenticationToken string) (_r []*SharedNotebook, _err error)
  // Asks the service to make a linked notebook with the provided name, username
  // of the owner and identifiers provided. A linked notebook can be either a
  // link to a public notebook or to a private shared notebook.
  // 
  // @param linkedNotebook
  //   The desired fields for the linked notebook must be provided on this
  //   object.  The name of the linked notebook must be set. Either a username
  //   uri or a shard id and share key must be provided otherwise a
  //   EDAMUserException is thrown.
  // 
  // @return
  //   The newly created LinkedNotebook.  The server-side id will be
  //   saved in this object's 'id' field.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
  //   </li>
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
  //     if public notebook set but bad uri
  //   </li>
  //   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
  //     if private notebook but shard id not provided
  //   </li>
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
  //   </li>
  // </ul>
  // 
  // @throws EDAMSystemException <ul>
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
  //     if a bad global identifer was set on a private notebook
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - LinkedNotebook
  CreateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook) (_r *LinkedNotebook, _err error)
  // @param linkedNotebook
  //   Updates the name of a linked notebook.
  // 
  // @return
  //   The Update Sequence Number for this change within the account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
  //   </li>
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
  //   </li>
  //   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - LinkedNotebook
  UpdateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook) (_r int32, _err error)
  // Returns a list of linked notebooks
  // 
  // Parameters:
  //  - AuthenticationToken
  ListLinkedNotebooks(ctx context.Context, authenticationToken string) (_r []*LinkedNotebook, _err error)
  // Permanently expunges the linked notebook from the account.
  // <p/>
  // NOTE: This function is generally not available to third party applications.
  // Calls will result in an EDAMUserException with the error code
  // PERMISSION_DENIED.
  // 
  // @param guid
  //   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
  //   from the account.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  ExpungeLinkedNotebook(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error)
  // Asks the service to produce an authentication token that can be used to
  // access the contents of a shared notebook from someone else's account.
  // This authenticationToken can be used with the various other NoteStore
  // calls to find and retrieve notes, and if the permissions in the shared
  // notebook are sufficient, to make changes to the contents of the notebook.
  // 
  // @param shareKeyOrGlobalId
  //   May be one of the following:
  //   <ul>
  //     <li>A share key for a shared notebook that was granted to some recipient
  //         Must be used if you are joining a notebook unless it was shared via
  //         createOrUpdateNotebookShares. Share keys are delivered out-of-band
  //         and are generally not available to clients. For security reasons,
  //         share keys may be invalidated at the discretion of the service.
  //     </li>
  //     <li>The shared notebook global identifier. May be used to access a
  //         notebook that is already joined.
  //     </li>
  //     <li>The Notebook GUID. May be used to access a notebook that was already
  //         joined, or to access a notebook that was shared with the recipient
  //         via createOrUpdateNotebookShares.
  //     </li>
  //   </ul>
  // 
  // @param authenticationToken
  //   If a non-empty string is provided, this is the full user-based
  //   authentication token that identifies the user who is currently logged in
  //   and trying to access the shared notebook.
  //   If this string is empty, the service will attempt to authenticate to the
  //   shared notebook without any logged in user.
  // 
  // @throws EDAMSystemException <ul>
  //   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
  //   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
  // </ul>
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
  //          no valid authentication token was provided.
  //   </li>
  //   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
  //          and another username has already been bound to this notebook.
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - ShareKeyOrGlobalId
  //  - AuthenticationToken
  AuthenticateToSharedNotebook(ctx context.Context, shareKeyOrGlobalId string, authenticationToken string) (_r *AuthenticationResult_, _err error)
  // This function is used to retrieve extended information about a shared
  // notebook by a guest who has already authenticated to access that notebook.
  // This requires an 'authenticationToken' parameter which should be the
  // resut of a call to authenticateToSharedNotebook(...).
  // I.e. this is the token that gives access to the particular shared notebook
  // in someone else's account -- it's not the authenticationToken for the
  // owner of the notebook itself.
  // 
  // @param authenticationToken
  //   Should be the authentication token retrieved from the reply of
  //   authenticateToSharedNotebook(), proving access to a particular shared
  //   notebook.
  // 
  // @throws EDAMUserException <ul>
  //   <li> PERMISSION_DENIED "authenticationToken" -
  //          authentication token doesn't correspond to a valid shared notebook
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "SharedNotebook.id" - the shared notebook no longer exists
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  GetSharedNotebookByAuth(ctx context.Context, authenticationToken string) (_r *SharedNotebook, _err error)
  // Attempts to send a single note to one or more email recipients.
  // <p/>
  // NOTE: This function is generally not available to third party applications.
  // Calls will result in an EDAMUserException with the error code
  // PERMISSION_DENIED.
  // 
  // @param authenticationToken
  //    The note will be sent as the user logged in via this token, using that
  //    user's registered email address.  If the authenticated user doesn't
  //    have permission to read that note, the emailing will fail.
  // 
  // @param parameters
  //    The note must be specified either by GUID (in which case it will be
  //    sent using the existing data in the service), or else the full Note
  //    must be passed to this call.  This also specifies the additional
  //    email fields that will be used in the email.
  // 
  // @throws EDAMUserException <ul>
  //   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
  //     The email can't be sent because this would exceed the user's daily
  //     email limit.
  //   </li>
  //   <li> BAD_DATA_FORMAT "(email address)" -
  //     email address malformed
  //   </li>
  //   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
  //     if there are no To: or Cc: addresses provided.
  //   </li>
  //   <li> DATA_REQUIRED "Note.title" -
  //     if the caller provides a Note parameter with no title
  //   </li>
  //   <li> DATA_REQUIRED "Note.content" -
  //     if the caller provides a Note parameter with no content
  //   </li>
  //   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  //   </li>
  //   <li> DATA_REQUIRED "NoteEmailParameters.note" -
  //     if no guid or note provided
  //   </li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Parameters
  EmailNote(ctx context.Context, authenticationToken string, parameters *NoteEmailParameters) (_err error)
  // If this note is not already shared publicly (via its own direct URL), then this
  // will start sharing that note.
  // This will return the secret "Note Key" for this note that
  // can currently be used in conjunction with the Note's GUID to gain direct
  // read-only access to the Note.
  // If the note is already shared, then this won't make any changes to the
  // note, and the existing "Note Key" will be returned.  The only way to change
  // the Note Key for an existing note is to stopSharingNote first, and then
  // call this function.
  // 
  // @param guid
  //   The GUID of the note to be shared.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "Note.guid" - not found, by GUID</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  ShareNote(ctx context.Context, authenticationToken string, guid GUID) (_r string, _err error)
  // If this note is shared publicly then this will stop sharing that note
  // and invalidate its "Note Key", so any existing URLs to access that Note
  // will stop working.
  // 
  // If the Note is not shared, then this function will do nothing.
  // 
  // This function does not remove invididual shares for the note. To remove
  // individual shares, see stopSharingNoteWithRecipients.
  // 
  // @param guid
  //   The GUID of the note to be un-shared.
  // 
  // @throws EDAMUserException <ul>
  //   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
  //   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li>"Note.guid" - not found, by GUID</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - GUID
  StopSharingNote(ctx context.Context, authenticationToken string, guid GUID) (_err error)
  // Asks the service to produce an authentication token that can be used to
  // access the contents of a single Note which was individually shared
  // from someone's account.
  // This authenticationToken can be used with the various other NoteStore
  // calls to find and retrieve the Note and its directly-referenced children.
  // 
  // @param guid
  //   The GUID identifying this Note on this shard.
  // 
  // @param noteKey
  //   The 'noteKey' identifier from the Note that was originally created via
  //   a call to shareNote() and then given to a recipient to access.
  // 
  // @param authenticationToken
  //   An optional authenticationToken that identifies the user accessing the
  //   shared note. This parameter may be required to access some shared notes.
  // 
  // @throws EDAMUserException <ul>
  //   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
  //     shared, or the noteKey doesn't match the current key for this note
  //   </li>
  //   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
  //     required to access this Note, but either no authentication token or a
  //     "non-owner" authentication token was provided.
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li> "guid" - the note with that GUID is not found
  //   </li>
  // </ul>
  // 
  // @throws EDAMSystemException <ul>
  //   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
  //     all requesters).
  //   </li>
  //   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
  //     for the requester because of an IP-based country lookup.
  //   </ul>
  // </ul>
  // 
  // Parameters:
  //  - GUID
  //  - NoteKey
  //  - AuthenticationToken
  AuthenticateToSharedNote(ctx context.Context, guid string, noteKey string, authenticationToken string) (_r *AuthenticationResult_, _err error)
  // Identify related entities on the service, such as notes,
  // notebooks, tags and users in a business related to notes or content.
  // 
  // @param query
  //   The information about which we are finding related entities.
  // 
  // @param resultSpec
  //   Allows the client to indicate the type and quantity of
  //   information to be returned, allowing a saving of time and
  //   bandwidth.
  // 
  // @return
  //   The result of the query, with information considered
  //   to likely be relevantly related to the information
  //   described by the query.
  // 
  // @throws EDAMUserException <ul>
  //   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
  //     a zero-length plain text value.
  //   </li>
  //   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
  //     invalid Note GUID, that is, one that does not match the constraints
  //     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  //   </li>
  //   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  //   </li>
  //   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
  //     the note identified by RelatedQuery.noteGuid.
  //   </li>
  //   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
  //     findExperts in the context of a non business user (i.e. The authenticationToken
  //     is not a business auth token).
  //   </li>
  //   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
  //     in the result spec.
  //   </li>
  // </ul>
  // 
  // @throws EDAMNotFoundException <ul>
  //   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
  //     found, if that field has been set in the query.
  //   </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Query
  //  - ResultSpec
  FindRelated(ctx context.Context, authenticationToken string, query *RelatedQuery, resultSpec *RelatedResultSpec) (_r *RelatedResult_, _err error)
  // Perform the same operation as updateNote() would provided that the update
  // sequence number on the parameter Note object matches the current update sequence
  // number that the service has for the note.  If they do <i>not</i> match, then
  // <i>no</i> update is performed and the return value will have the current server
  // state in the note field and updated will be false.  If the update sequence
  // numbers between the client and server do match, then the note will be updated
  // and the note field of the return value will be returned as it would be for the
  // updateNote method.  This method allows you to check for an update to the note
  // on the service, by another client instance, from when you obtained the
  // note state as a baseline for your edits and the time when you wish to save your
  // edits.  If your client can merge the conflict, you can avoid overwriting changes
  // that were saved to the service by the other client.
  // 
  // See the updateNote method for information on the exceptions and parameters for
  // this method.  The only difference is that you must have an update sequence number
  // defined on the note parameter (equal to the USN of the note as synched to the
  // client), and the following additional exceptions might be thrown.
  // 
  // @throws EDAMUserException <ul>
  //   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
  //       not provided.  This includes a value that is set as 0.</li>
  //   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
  //       sequence number that is larger than the current server value, which should
  //       not happen if your client is working correctly.</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Note
  UpdateNoteIfUsnMatches(ctx context.Context, authenticationToken string, note *Note) (_r *UpdateNoteIfUsnMatchesResult_, _err error)
  // Manage invitations and memberships associated with a given notebook.
  // 
  // <i>Note:</i> Beta method! This method is currently intended for
  // limited use by Evernote clients that have discussed using this
  // routine with the platform team.
  // 
  // @param parameters A structure containing all parameters for the updates.
  //    See the structure documentation for details.
  // 
  // @throws EDAMUserException <ul>
  //   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
  //    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
  //    shares.</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - Parameters
  ManageNotebookShares(ctx context.Context, authenticationToken string, parameters *ManageNotebookSharesParameters) (_r *ManageNotebookSharesResult_, _err error)
  // Return the share relationships for the given notebook, including
  // both the invitations and the memberships.
  // 
  // <i>Note:</i> Beta method! This method is currently intended for
  // limited use by Evernote clients that have discussed using this
  // routine with the platform team.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - NotebookGuid
  GetNotebookShares(ctx context.Context, authenticationToken string, notebookGuid string) (_r *ShareRelationships, _err error)
}

//Service:  NoteStore
//<p>
//The NoteStore service is used by EDAM clients to exchange information
//about the collection of notes in an account. This is primarily used for
//synchronization, but could also be used by a "thin" client without a full
//local cache.
//</p><p>
//Most functions take an "authenticationToken" parameter, which is the
//value returned by the UserStore which permits access to the account.
//</p>
//
//Calls which require an authenticationToken may throw an EDAMUserException
//for the following reasons:
// <ul>
//  <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
//  <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
//  <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
//  <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
//  <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
//      to perform the requested action</li>
//  <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
//      that requires single sign-on, and must complete SSO before accessing business
//      content.
//</ul>
type NoteStoreClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewNoteStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *NoteStoreClient {
  return &NoteStoreClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewNoteStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *NoteStoreClient {
  return &NoteStoreClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewNoteStoreClient(c thrift.TClient) *NoteStoreClient {
  return &NoteStoreClient{
    c: c,
  }
}

func (p *NoteStoreClient) Client_() thrift.TClient {
  return p.c
}

func (p *NoteStoreClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *NoteStoreClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Asks the NoteStore to provide information about the status of the user
// account corresponding to the provided authentication token.
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) GetSyncState(ctx context.Context, authenticationToken string) (_r *SyncState, _err error) {
  var _args96 NoteStoreGetSyncStateArgs
  _args96.AuthenticationToken = authenticationToken
  var _result98 NoteStoreGetSyncStateResult
  var _meta97 thrift.ResponseMeta
  _meta97, _err = p.Client_().Call(ctx, "getSyncState", &_args96, &_result98)
  p.SetLastResponseMeta_(_meta97)
  if _err != nil {
    return
  }
  switch {
  case _result98.UserException!= nil:
    return _r, _result98.UserException
  case _result98.SystemException!= nil:
    return _r, _result98.SystemException
  }

  if _ret99 := _result98.GetSuccess(); _ret99 != nil {
    return _ret99, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getSyncState failed: unknown result")
}

// Asks the NoteStore to provide the state of the account in order of
// last modification.  This request retrieves one block of the server's
// state so that a client can make several small requests against a large
// account rather than getting the entire state in one big message.
// This call gives fine-grained control of the data that will
// be received by a client by omitting data elements that a client doesn't
// need. This may reduce network traffic and sync times.
// 
// @param afterUSN
//   The client can pass this value to ask only for objects that
//   have been updated after a certain point.  This allows the client to
//   receive updates after its last checkpoint rather than doing a full
//   synchronization on every pass.  The default value of "0" indicates
//   that the client wants to get objects from the start of the account.
// 
// @param maxEntries
//   The maximum number of modified objects that should be
//   returned in the result SyncChunk.  This can be used to limit the size
//   of each individual message to be friendly for network transfer.
// 
// @param filter
//   The caller must set some of the flags in this structure to specify which
//   data types should be returned during the synchronization.  See
//   the SyncChunkFilter structure for information on each flag.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "afterUSN" - if negative
//   </li>
//   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - AfterUSN
//  - MaxEntries
//  - Filter
func (p *NoteStoreClient) GetFilteredSyncChunk(ctx context.Context, authenticationToken string, afterUSN int32, maxEntries int32, filter *SyncChunkFilter) (_r *SyncChunk, _err error) {
  var _args100 NoteStoreGetFilteredSyncChunkArgs
  _args100.AuthenticationToken = authenticationToken
  _args100.AfterUSN = afterUSN
  _args100.MaxEntries = maxEntries
  _args100.Filter = filter
  var _result102 NoteStoreGetFilteredSyncChunkResult
  var _meta101 thrift.ResponseMeta
  _meta101, _err = p.Client_().Call(ctx, "getFilteredSyncChunk", &_args100, &_result102)
  p.SetLastResponseMeta_(_meta101)
  if _err != nil {
    return
  }
  switch {
  case _result102.UserException!= nil:
    return _r, _result102.UserException
  case _result102.SystemException!= nil:
    return _r, _result102.SystemException
  }

  if _ret103 := _result102.GetSuccess(); _ret103 != nil {
    return _ret103, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getFilteredSyncChunk failed: unknown result")
}

// Asks the NoteStore to provide information about the status of a linked
// notebook that has been shared with the caller, or that is public to the
// world.
// This will return a result that is similar to getSyncState, but may omit
// SyncState.uploaded if the caller doesn't have permission to write to
// the linked notebook.
// 
// This function must be called on the shard that owns the referenced
// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
// same as LinkedNotebook.shardId.)
// 
// @param authenticationToken
//   This should be an authenticationToken for the guest who has received
//   the invitation to the share.  (I.e. this should not be the result of
//   NoteStore.authenticateToSharedNotebook)
// 
// @param linkedNotebook
//   This structure should contain identifying information and permissions
//   to access the notebook in question.
// 
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
//       populated with the current username of the owner of the notebook for which
//       you are obtaining sync state.
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
//       correspond to a current user on the service.
//   </li>
// </ul>
// 
// @throws SystemException <ul>
//   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
//       user whose account is on a shard other than that on which this method was
//       invoked.
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
func (p *NoteStoreClient) GetLinkedNotebookSyncState(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook) (_r *SyncState, _err error) {
  var _args104 NoteStoreGetLinkedNotebookSyncStateArgs
  _args104.AuthenticationToken = authenticationToken
  _args104.LinkedNotebook = linkedNotebook
  var _result106 NoteStoreGetLinkedNotebookSyncStateResult
  var _meta105 thrift.ResponseMeta
  _meta105, _err = p.Client_().Call(ctx, "getLinkedNotebookSyncState", &_args104, &_result106)
  p.SetLastResponseMeta_(_meta105)
  if _err != nil {
    return
  }
  switch {
  case _result106.UserException!= nil:
    return _r, _result106.UserException
  case _result106.SystemException!= nil:
    return _r, _result106.SystemException
  case _result106.NotFoundException!= nil:
    return _r, _result106.NotFoundException
  }

  if _ret107 := _result106.GetSuccess(); _ret107 != nil {
    return _ret107, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getLinkedNotebookSyncState failed: unknown result")
}

// Asks the NoteStore to provide information about the contents of a linked
// notebook that has been shared with the caller, or that is public to the
// world.
// This will return a result that is similar to getSyncChunk, but will only
// contain entries that are visible to the caller.  I.e. only that particular
// Notebook will be visible, along with its Notes, and Tags on those Notes.
// 
// This function must be called on the shard that owns the referenced
// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
// same as LinkedNotebook.shardId.)
// 
// @param authenticationToken
//   This should be an authenticationToken for the guest who has received
//   the invitation to the share.  (I.e. this should not be the result of
//   NoteStore.authenticateToSharedNotebook)
// 
// @param linkedNotebook
//   This structure should contain identifying information and permissions
//   to access the notebook in question.  This must contain the valid fields
//   for either a shared notebook (e.g. shareKey)
//   or a public notebook (e.g. username, uri)
// 
// @param afterUSN
//   The client can pass this value to ask only for objects that
//   have been updated after a certain point.  This allows the client to
//   receive updates after its last checkpoint rather than doing a full
//   synchronization on every pass.  The default value of "0" indicates
//   that the client wants to get objects from the start of the account.
// 
// @param maxEntries
//   The maximum number of modified objects that should be
//   returned in the result SyncChunk.  This can be used to limit the size
//   of each individual message to be friendly for network transfer.
//   Applications should not request more than 256 objects at a time,
//   and must handle the case where the service returns less than the
//   requested number of objects in a given request even though more
//   objects are available on the service.
// 
// @param fullSyncOnly
//   If true, then the client only wants initial data for a full sync.
//   In this case, the service will not return any expunged objects,
//   and will not return any Resources, since these are also provided
//   in their corresponding Notes.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "afterUSN" - if negative
//   </li>
//   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "LinkedNotebook" - if the provided information doesn't match any
//     valid notebook
//   </li>
//   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
//     valid notebook
//   </li>
//   <li> "SharedNotebook.id" - if the provided information indicates a
//      shared notebook that no longer exists
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
//  - AfterUSN
//  - MaxEntries
//  - FullSyncOnly
func (p *NoteStoreClient) GetLinkedNotebookSyncChunk(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook, afterUSN int32, maxEntries int32, fullSyncOnly bool) (_r *SyncChunk, _err error) {
  var _args108 NoteStoreGetLinkedNotebookSyncChunkArgs
  _args108.AuthenticationToken = authenticationToken
  _args108.LinkedNotebook = linkedNotebook
  _args108.AfterUSN = afterUSN
  _args108.MaxEntries = maxEntries
  _args108.FullSyncOnly = fullSyncOnly
  var _result110 NoteStoreGetLinkedNotebookSyncChunkResult
  var _meta109 thrift.ResponseMeta
  _meta109, _err = p.Client_().Call(ctx, "getLinkedNotebookSyncChunk", &_args108, &_result110)
  p.SetLastResponseMeta_(_meta109)
  if _err != nil {
    return
  }
  switch {
  case _result110.UserException!= nil:
    return _r, _result110.UserException
  case _result110.SystemException!= nil:
    return _r, _result110.SystemException
  case _result110.NotFoundException!= nil:
    return _r, _result110.NotFoundException
  }

  if _ret111 := _result110.GetSuccess(); _ret111 != nil {
    return _ret111, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getLinkedNotebookSyncChunk failed: unknown result")
}

// Returns a list of all of the notebooks in the account.
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListNotebooks(ctx context.Context, authenticationToken string) (_r []*Notebook, _err error) {
  var _args112 NoteStoreListNotebooksArgs
  _args112.AuthenticationToken = authenticationToken
  var _result114 NoteStoreListNotebooksResult
  var _meta113 thrift.ResponseMeta
  _meta113, _err = p.Client_().Call(ctx, "listNotebooks", &_args112, &_result114)
  p.SetLastResponseMeta_(_meta113)
  if _err != nil {
    return
  }
  switch {
  case _result114.UserException!= nil:
    return _r, _result114.UserException
  case _result114.SystemException!= nil:
    return _r, _result114.SystemException
  }

  return _result114.GetSuccess(), nil
}

// Returns a list of all the notebooks in a business that the user has permission to access,
// regardless of whether the user has joined them. This includes notebooks that have been shared
// with the entire business as well as notebooks that have been shared directly with the user.
// 
// @param authenticationToken A business authentication token obtained by calling
//   UserStore.authenticateToBusiness.
// 
// @throws EDAMUserException <ul>
//   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
//     business auth token.</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListAccessibleBusinessNotebooks(ctx context.Context, authenticationToken string) (_r []*Notebook, _err error) {
  var _args115 NoteStoreListAccessibleBusinessNotebooksArgs
  _args115.AuthenticationToken = authenticationToken
  var _result117 NoteStoreListAccessibleBusinessNotebooksResult
  var _meta116 thrift.ResponseMeta
  _meta116, _err = p.Client_().Call(ctx, "listAccessibleBusinessNotebooks", &_args115, &_result117)
  p.SetLastResponseMeta_(_meta116)
  if _err != nil {
    return
  }
  switch {
  case _result117.UserException!= nil:
    return _r, _result117.UserException
  case _result117.SystemException!= nil:
    return _r, _result117.SystemException
  }

  return _result117.GetSuccess(), nil
}

// Returns the current state of the notebook with the provided GUID.
// The notebook may be active or deleted (but not expunged).
// 
// @param guid
//   The GUID of the notebook to be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - tag not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetNotebook(ctx context.Context, authenticationToken string, guid GUID) (_r *Notebook, _err error) {
  var _args118 NoteStoreGetNotebookArgs
  _args118.AuthenticationToken = authenticationToken
  _args118.GUID = guid
  var _result120 NoteStoreGetNotebookResult
  var _meta119 thrift.ResponseMeta
  _meta119, _err = p.Client_().Call(ctx, "getNotebook", &_args118, &_result120)
  p.SetLastResponseMeta_(_meta119)
  if _err != nil {
    return
  }
  switch {
  case _result120.UserException!= nil:
    return _r, _result120.UserException
  case _result120.SystemException!= nil:
    return _r, _result120.SystemException
  case _result120.NotFoundException!= nil:
    return _r, _result120.NotFoundException
  }

  if _ret121 := _result120.GetSuccess(); _ret121 != nil {
    return _ret121, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNotebook failed: unknown result")
}

// Returns the notebook that should be used to store new notes in the
// user's account when no other notebooks are specified.
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) GetDefaultNotebook(ctx context.Context, authenticationToken string) (_r *Notebook, _err error) {
  var _args122 NoteStoreGetDefaultNotebookArgs
  _args122.AuthenticationToken = authenticationToken
  var _result124 NoteStoreGetDefaultNotebookResult
  var _meta123 thrift.ResponseMeta
  _meta123, _err = p.Client_().Call(ctx, "getDefaultNotebook", &_args122, &_result124)
  p.SetLastResponseMeta_(_meta123)
  if _err != nil {
    return
  }
  switch {
  case _result124.UserException!= nil:
    return _r, _result124.UserException
  case _result124.SystemException!= nil:
    return _r, _result124.SystemException
  }

  if _ret125 := _result124.GetSuccess(); _ret125 != nil {
    return _ret125, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getDefaultNotebook failed: unknown result")
}

// Asks the service to make a notebook with the provided name.
// 
// @param notebook
//   The desired fields for the notebook must be provided on this
//   object.  The name of the notebook must be set, and either the 'active'
//   or 'defaultNotebook' fields may be set by the client at creation.
//   If a notebook exists in the account with the same name (via
//   case-insensitive compare), this will throw an EDAMUserException.
// 
// @return
//   The newly created Notebook.  The server-side GUID will be
//   saved in this object's 'guid' field.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
//   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
//   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
//   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
//   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
//   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
//   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
//   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
//   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
//        is set to 'true' for a Notebook that is not owned by the user identified by
//        the passed authenticationToken.</li>
//   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Notebook
func (p *NoteStoreClient) CreateNotebook(ctx context.Context, authenticationToken string, notebook *Notebook) (_r *Notebook, _err error) {
  var _args126 NoteStoreCreateNotebookArgs
  _args126.AuthenticationToken = authenticationToken
  _args126.Notebook = notebook
  var _result128 NoteStoreCreateNotebookResult
  var _meta127 thrift.ResponseMeta
  _meta127, _err = p.Client_().Call(ctx, "createNotebook", &_args126, &_result128)
  p.SetLastResponseMeta_(_meta127)
  if _err != nil {
    return
  }
  switch {
  case _result128.UserException!= nil:
    return _r, _result128.UserException
  case _result128.SystemException!= nil:
    return _r, _result128.SystemException
  case _result128.NotFoundException!= nil:
    return _r, _result128.NotFoundException
  }

  if _ret129 := _result128.GetSuccess(); _ret129 != nil {
    return _ret129, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createNotebook failed: unknown result")
}

// Submits notebook changes to the service. The provided data must include the
// notebook's guid field for identification.
// <p />
// The Notebook will be moved to the specified Workspace, if a non empty
// Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
// Notebook is in a Workspace, then it will be removed from the Workspace and a full
// access SharedNotebook record will be ensured for the caller. If the caller does not
// already have a full access share, either the privilege of an existing share will be
// upgraded or a new share will be created. It is illegal to set a
// Notebook.workspaceGuid on a Workspace backing Notebook.
// 
// @param notebook
//   The notebook object containing the requested changes.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
//   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
//   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
//   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
//   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
//   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
//   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
//   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
//   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
//        is set to 'true' for a Notebook that is not owned by the user identified by
//        the passed authenticationToken.</li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID</li>
//   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
//        for the GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Notebook
func (p *NoteStoreClient) UpdateNotebook(ctx context.Context, authenticationToken string, notebook *Notebook) (_r int32, _err error) {
  var _args130 NoteStoreUpdateNotebookArgs
  _args130.AuthenticationToken = authenticationToken
  _args130.Notebook = notebook
  var _result132 NoteStoreUpdateNotebookResult
  var _meta131 thrift.ResponseMeta
  _meta131, _err = p.Client_().Call(ctx, "updateNotebook", &_args130, &_result132)
  p.SetLastResponseMeta_(_meta131)
  if _err != nil {
    return
  }
  switch {
  case _result132.UserException!= nil:
    return _r, _result132.UserException
  case _result132.SystemException!= nil:
    return _r, _result132.SystemException
  case _result132.NotFoundException!= nil:
    return _r, _result132.NotFoundException
  }

  return _result132.GetSuccess(), nil
}

// Permanently removes the notebook from the user's account.
// After this action, the notebook is no longer available for undeletion, etc.
// If the notebook contains any Notes, they will be moved to the current
// default notebook and moved into the trash (i.e. Note.active=false).
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
// 
// @param guid
//   The GUID of the notebook to delete.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
//   </li>
//   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
//   </li>
//   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) ExpungeNotebook(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error) {
  var _args133 NoteStoreExpungeNotebookArgs
  _args133.AuthenticationToken = authenticationToken
  _args133.GUID = guid
  var _result135 NoteStoreExpungeNotebookResult
  var _meta134 thrift.ResponseMeta
  _meta134, _err = p.Client_().Call(ctx, "expungeNotebook", &_args133, &_result135)
  p.SetLastResponseMeta_(_meta134)
  if _err != nil {
    return
  }
  switch {
  case _result135.UserException!= nil:
    return _r, _result135.UserException
  case _result135.SystemException!= nil:
    return _r, _result135.SystemException
  case _result135.NotFoundException!= nil:
    return _r, _result135.NotFoundException
  }

  return _result135.GetSuccess(), nil
}

// Returns a list of the tags in the account.  Evernote does not support
// the undeletion of tags, so this will only include active tags.
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListTags(ctx context.Context, authenticationToken string) (_r []*Tag, _err error) {
  var _args136 NoteStoreListTagsArgs
  _args136.AuthenticationToken = authenticationToken
  var _result138 NoteStoreListTagsResult
  var _meta137 thrift.ResponseMeta
  _meta137, _err = p.Client_().Call(ctx, "listTags", &_args136, &_result138)
  p.SetLastResponseMeta_(_meta137)
  if _err != nil {
    return
  }
  switch {
  case _result138.UserException!= nil:
    return _r, _result138.UserException
  case _result138.SystemException!= nil:
    return _r, _result138.SystemException
  }

  return _result138.GetSuccess(), nil
}

// Returns a list of the tags that are applied to at least one note within
// the provided notebook.  If the notebook is public, the authenticationToken
// may be ignored.
// 
// @param notebookGuid
//    the GUID of the notebook to use to find tags
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - notebook not found by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - NotebookGuid
func (p *NoteStoreClient) ListTagsByNotebook(ctx context.Context, authenticationToken string, notebookGuid GUID) (_r []*Tag, _err error) {
  var _args139 NoteStoreListTagsByNotebookArgs
  _args139.AuthenticationToken = authenticationToken
  _args139.NotebookGuid = notebookGuid
  var _result141 NoteStoreListTagsByNotebookResult
  var _meta140 thrift.ResponseMeta
  _meta140, _err = p.Client_().Call(ctx, "listTagsByNotebook", &_args139, &_result141)
  p.SetLastResponseMeta_(_meta140)
  if _err != nil {
    return
  }
  switch {
  case _result141.UserException!= nil:
    return _r, _result141.UserException
  case _result141.SystemException!= nil:
    return _r, _result141.SystemException
  case _result141.NotFoundException!= nil:
    return _r, _result141.NotFoundException
  }

  return _result141.GetSuccess(), nil
}

// Returns the current state of the Tag with the provided GUID.
// 
// @param guid
//   The GUID of the tag to be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetTag(ctx context.Context, authenticationToken string, guid GUID) (_r *Tag, _err error) {
  var _args142 NoteStoreGetTagArgs
  _args142.AuthenticationToken = authenticationToken
  _args142.GUID = guid
  var _result144 NoteStoreGetTagResult
  var _meta143 thrift.ResponseMeta
  _meta143, _err = p.Client_().Call(ctx, "getTag", &_args142, &_result144)
  p.SetLastResponseMeta_(_meta143)
  if _err != nil {
    return
  }
  switch {
  case _result144.UserException!= nil:
    return _r, _result144.UserException
  case _result144.SystemException!= nil:
    return _r, _result144.SystemException
  case _result144.NotFoundException!= nil:
    return _r, _result144.NotFoundException
  }

  if _ret145 := _result144.GetSuccess(); _ret145 != nil {
    return _ret145, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getTag failed: unknown result")
}

// Asks the service to make a tag with a set of information.
// 
// @param tag
//   The desired list of fields for the tag are specified in this
//   object.  The caller must specify the tag name, and may provide
//   the parentGUID.
// 
// @return
//   The newly created Tag.  The server-side GUID will be
//   saved in this object.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
//   </li>
//   <li> DATA_CONFLICT "Tag.name" - name already in use
//   </li>
//   <li> LIMIT_REACHED "Tag" - at max number of tags
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.parentGuid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Tag
func (p *NoteStoreClient) CreateTag(ctx context.Context, authenticationToken string, tag *Tag) (_r *Tag, _err error) {
  var _args146 NoteStoreCreateTagArgs
  _args146.AuthenticationToken = authenticationToken
  _args146.Tag = tag
  var _result148 NoteStoreCreateTagResult
  var _meta147 thrift.ResponseMeta
  _meta147, _err = p.Client_().Call(ctx, "createTag", &_args146, &_result148)
  p.SetLastResponseMeta_(_meta147)
  if _err != nil {
    return
  }
  switch {
  case _result148.UserException!= nil:
    return _r, _result148.UserException
  case _result148.SystemException!= nil:
    return _r, _result148.SystemException
  case _result148.NotFoundException!= nil:
    return _r, _result148.NotFoundException
  }

  if _ret149 := _result148.GetSuccess(); _ret149 != nil {
    return _ret149, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createTag failed: unknown result")
}

// Submits tag changes to the service.  The provided data must include
// the tag's guid field for identification.  The service will apply
// updates to the following tag fields:  name, parentGuid
// 
// @param tag
//   The tag object containing the requested changes.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
//   </li>
//   <li> DATA_CONFLICT "Tag.name" - name already in use
//   </li>
//   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
//   </li>
//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
//   <li> "Tag.parentGuid" - parent not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Tag
func (p *NoteStoreClient) UpdateTag(ctx context.Context, authenticationToken string, tag *Tag) (_r int32, _err error) {
  var _args150 NoteStoreUpdateTagArgs
  _args150.AuthenticationToken = authenticationToken
  _args150.Tag = tag
  var _result152 NoteStoreUpdateTagResult
  var _meta151 thrift.ResponseMeta
  _meta151, _err = p.Client_().Call(ctx, "updateTag", &_args150, &_result152)
  p.SetLastResponseMeta_(_meta151)
  if _err != nil {
    return
  }
  switch {
  case _result152.UserException!= nil:
    return _r, _result152.UserException
  case _result152.SystemException!= nil:
    return _r, _result152.SystemException
  case _result152.NotFoundException!= nil:
    return _r, _result152.NotFoundException
  }

  return _result152.GetSuccess(), nil
}

// Removes the provided tag from every note that is currently tagged with
// this tag.  If this operation is successful, the tag will still be in
// the account, but it will not be tagged on any notes.
// 
// This function is not indended for use by full synchronizing clients, since
// it does not provide enough result information to the client to reconcile
// the local state without performing a follow-up sync from the service.  This
// is intended for "thin clients" that need to efficiently support this as
// a UI operation.
// 
// @param guid
//   The GUID of the tag to remove from all notes.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) UntagAll(ctx context.Context, authenticationToken string, guid GUID) (_err error) {
  var _args153 NoteStoreUntagAllArgs
  _args153.AuthenticationToken = authenticationToken
  _args153.GUID = guid
  var _result155 NoteStoreUntagAllResult
  var _meta154 thrift.ResponseMeta
  _meta154, _err = p.Client_().Call(ctx, "untagAll", &_args153, &_result155)
  p.SetLastResponseMeta_(_meta154)
  if _err != nil {
    return
  }
  switch {
  case _result155.UserException!= nil:
    return _result155.UserException
  case _result155.SystemException!= nil:
    return _result155.SystemException
  case _result155.NotFoundException!= nil:
    return _result155.NotFoundException
  }

  return nil
}

// Permanently deletes the tag with the provided GUID, if present.
// <p/>
// NOTE: This function is not generally available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
// 
// @param guid
//   The GUID of the tag to delete.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Tag.guid" - tag not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) ExpungeTag(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error) {
  var _args156 NoteStoreExpungeTagArgs
  _args156.AuthenticationToken = authenticationToken
  _args156.GUID = guid
  var _result158 NoteStoreExpungeTagResult
  var _meta157 thrift.ResponseMeta
  _meta157, _err = p.Client_().Call(ctx, "expungeTag", &_args156, &_result158)
  p.SetLastResponseMeta_(_meta157)
  if _err != nil {
    return
  }
  switch {
  case _result158.UserException!= nil:
    return _r, _result158.UserException
  case _result158.SystemException!= nil:
    return _r, _result158.SystemException
  case _result158.NotFoundException!= nil:
    return _r, _result158.NotFoundException
  }

  return _result158.GetSuccess(), nil
}

// Returns a list of the searches in the account.  Evernote does not support
// the undeletion of searches, so this will only include active searches.
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListSearches(ctx context.Context, authenticationToken string) (_r []*SavedSearch, _err error) {
  var _args159 NoteStoreListSearchesArgs
  _args159.AuthenticationToken = authenticationToken
  var _result161 NoteStoreListSearchesResult
  var _meta160 thrift.ResponseMeta
  _meta160, _err = p.Client_().Call(ctx, "listSearches", &_args159, &_result161)
  p.SetLastResponseMeta_(_meta160)
  if _err != nil {
    return
  }
  switch {
  case _result161.UserException!= nil:
    return _r, _result161.UserException
  case _result161.SystemException!= nil:
    return _r, _result161.SystemException
  }

  return _result161.GetSuccess(), nil
}

// Returns the current state of the search with the provided GUID.
// 
// @param guid
//   The GUID of the search to be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
//   </li>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "SavedSearch.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetSearch(ctx context.Context, authenticationToken string, guid GUID) (_r *SavedSearch, _err error) {
  var _args162 NoteStoreGetSearchArgs
  _args162.AuthenticationToken = authenticationToken
  _args162.GUID = guid
  var _result164 NoteStoreGetSearchResult
  var _meta163 thrift.ResponseMeta
  _meta163, _err = p.Client_().Call(ctx, "getSearch", &_args162, &_result164)
  p.SetLastResponseMeta_(_meta163)
  if _err != nil {
    return
  }
  switch {
  case _result164.UserException!= nil:
    return _r, _result164.UserException
  case _result164.SystemException!= nil:
    return _r, _result164.SystemException
  case _result164.NotFoundException!= nil:
    return _r, _result164.NotFoundException
  }

  if _ret165 := _result164.GetSuccess(); _ret165 != nil {
    return _ret165, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getSearch failed: unknown result")
}

// Asks the service to make a saved search with a set of information.
// 
// @param search
//   The desired list of fields for the search are specified in this
//   object. The caller must specify the name and query for the
//   search, and may optionally specify a search scope.
//   The SavedSearch.format field is ignored by the service.
// 
// @return
//   The newly created SavedSearch.  The server-side GUID will be
//   saved in this object.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
//   </li>
//   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
//   </li>
//   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Search
func (p *NoteStoreClient) CreateSearch(ctx context.Context, authenticationToken string, search *SavedSearch) (_r *SavedSearch, _err error) {
  var _args166 NoteStoreCreateSearchArgs
  _args166.AuthenticationToken = authenticationToken
  _args166.Search = search
  var _result168 NoteStoreCreateSearchResult
  var _meta167 thrift.ResponseMeta
  _meta167, _err = p.Client_().Call(ctx, "createSearch", &_args166, &_result168)
  p.SetLastResponseMeta_(_meta167)
  if _err != nil {
    return
  }
  switch {
  case _result168.UserException!= nil:
    return _r, _result168.UserException
  case _result168.SystemException!= nil:
    return _r, _result168.SystemException
  }

  if _ret169 := _result168.GetSuccess(); _ret169 != nil {
    return _ret169, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createSearch failed: unknown result")
}

// Submits search changes to the service. The provided data must include
// the search's guid field for identification. The service will apply
// updates to the following search fields: name, query, and scope.
// 
// @param search
//   The search object containing the requested changes.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
//   </li>
//   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
//   </li>
//   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "SavedSearch.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Search
func (p *NoteStoreClient) UpdateSearch(ctx context.Context, authenticationToken string, search *SavedSearch) (_r int32, _err error) {
  var _args170 NoteStoreUpdateSearchArgs
  _args170.AuthenticationToken = authenticationToken
  _args170.Search = search
  var _result172 NoteStoreUpdateSearchResult
  var _meta171 thrift.ResponseMeta
  _meta171, _err = p.Client_().Call(ctx, "updateSearch", &_args170, &_result172)
  p.SetLastResponseMeta_(_meta171)
  if _err != nil {
    return
  }
  switch {
  case _result172.UserException!= nil:
    return _r, _result172.UserException
  case _result172.SystemException!= nil:
    return _r, _result172.SystemException
  case _result172.NotFoundException!= nil:
    return _r, _result172.NotFoundException
  }

  return _result172.GetSuccess(), nil
}

// Permanently deletes the saved search with the provided GUID, if present.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
// 
// @param guid
//   The GUID of the search to delete.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
//   </li>
//   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "SavedSearch.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) ExpungeSearch(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error) {
  var _args173 NoteStoreExpungeSearchArgs
  _args173.AuthenticationToken = authenticationToken
  _args173.GUID = guid
  var _result175 NoteStoreExpungeSearchResult
  var _meta174 thrift.ResponseMeta
  _meta174, _err = p.Client_().Call(ctx, "expungeSearch", &_args173, &_result175)
  p.SetLastResponseMeta_(_meta174)
  if _err != nil {
    return
  }
  switch {
  case _result175.UserException!= nil:
    return _r, _result175.UserException
  case _result175.SystemException!= nil:
    return _r, _result175.SystemException
  case _result175.NotFoundException!= nil:
    return _r, _result175.NotFoundException
  }

  return _result175.GetSuccess(), nil
}

// Finds the position of a note within a sorted subset of all of the user's
// notes. This may be useful for thin clients that are displaying a paginated
// listing of a large account, which need to know where a particular note
// sits in the list without retrieving all notes first.
// 
// @param authenticationToken
//   Must be a valid token for the user's account unless the NoteFilter
//   'notebookGuid' is the GUID of a public notebook.
// 
// @param filter
//   The list of criteria that will constrain the notes to be returned.
// 
// @param guid
//   The GUID of the note to be retrieved.
// 
// @return
//   If the note with the provided GUID is found within the matching note
//   list, this will return the offset of that note within that list (where
//   the first offset is 0).  If the note is not found within the set of
//   notes, this will return -1.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - GUID
func (p *NoteStoreClient) FindNoteOffset(ctx context.Context, authenticationToken string, filter *NoteFilter, guid GUID) (_r int32, _err error) {
  var _args176 NoteStoreFindNoteOffsetArgs
  _args176.AuthenticationToken = authenticationToken
  _args176.Filter = filter
  _args176.GUID = guid
  var _result178 NoteStoreFindNoteOffsetResult
  var _meta177 thrift.ResponseMeta
  _meta177, _err = p.Client_().Call(ctx, "findNoteOffset", &_args176, &_result178)
  p.SetLastResponseMeta_(_meta177)
  if _err != nil {
    return
  }
  switch {
  case _result178.UserException!= nil:
    return _r, _result178.UserException
  case _result178.SystemException!= nil:
    return _r, _result178.SystemException
  case _result178.NotFoundException!= nil:
    return _r, _result178.NotFoundException
  }

  return _result178.GetSuccess(), nil
}

// Used to find the high-level information about a set of the notes from a
// user's account based on various criteria specified via a NoteFilter object.
// <p/>
// Web applications that wish to periodically check for new content in a user's
// Evernote account should consider using webhooks instead of polling this API.
// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
// for more information.
// 
// @param authenticationToken
//   Must be a valid token for the user's account unless the NoteFilter
//   'notebookGuid' is the GUID of a public notebook.
// 
// @param filter
//   The list of criteria that will constrain the notes to be returned.
// 
// @param offset
//   The numeric index of the first note to show within the sorted
//   results.  The numbering scheme starts with "0".  This can be used for
//   pagination.
// 
// @param maxNotes
//   The maximum notes to return in this query.  The service will return a set
//   of notes that is no larger than this number, but may return fewer notes
//   if needed.  The NoteList.totalNotes field in the return value will
//   indicate whether there are more values available after the returned set.
//   Currently, the service will not return more than 250 notes in a single request,
//   but this number may change in the future.
// 
// @param resultSpec
//   This specifies which information should be returned for each matching
//   Note. The fields on this structure can be used to eliminate data that
//   the client doesn't need, which will reduce the time and bandwidth
//   to receive and process the reply.
// 
// @return
//   The list of notes that match the criteria.
//   The Notes.sharedNotes field will not be set.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - Offset
//  - MaxNotes
//  - ResultSpec
func (p *NoteStoreClient) FindNotesMetadata(ctx context.Context, authenticationToken string, filter *NoteFilter, offset int32, maxNotes int32, resultSpec *NotesMetadataResultSpec) (_r *NotesMetadataList, _err error) {
  var _args179 NoteStoreFindNotesMetadataArgs
  _args179.AuthenticationToken = authenticationToken
  _args179.Filter = filter
  _args179.Offset = offset
  _args179.MaxNotes = maxNotes
  _args179.ResultSpec = resultSpec
  var _result181 NoteStoreFindNotesMetadataResult
  var _meta180 thrift.ResponseMeta
  _meta180, _err = p.Client_().Call(ctx, "findNotesMetadata", &_args179, &_result181)
  p.SetLastResponseMeta_(_meta180)
  if _err != nil {
    return
  }
  switch {
  case _result181.UserException!= nil:
    return _r, _result181.UserException
  case _result181.SystemException!= nil:
    return _r, _result181.SystemException
  case _result181.NotFoundException!= nil:
    return _r, _result181.NotFoundException
  }

  if _ret182 := _result181.GetSuccess(); _ret182 != nil {
    return _ret182, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "findNotesMetadata failed: unknown result")
}

// This function is used to determine how many notes are found for each
// notebook and tag in the user's account, given a current set of filter
// parameters that determine the current selection.  This function will
// return a structure that gives the note count for each notebook and tag
// that has at least one note under the requested filter.  Any notebook or
// tag that has zero notes in the filtered set will not be listed in the
// reply to this function (so they can be assumed to be 0).
// 
// @param authenticationToken
//   Must be a valid token for the user's account unless the NoteFilter
//   'notebookGuid' is the GUID of a public notebook.
// 
// @param filter
//   The note selection filter that is currently being applied.  The note
//   counts are to be calculated with this filter applied to the total set
//   of notes in the user's account.
// 
// @param withTrash
//   If true, then the NoteCollectionCounts.trashCount will be calculated
//   and supplied in the reply. Otherwise, the trash value will be omitted.
// 
// @throws EDAMUserException <ul>
//   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
//   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
//   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Filter
//  - WithTrash
func (p *NoteStoreClient) FindNoteCounts(ctx context.Context, authenticationToken string, filter *NoteFilter, withTrash bool) (_r *NoteCollectionCounts, _err error) {
  var _args183 NoteStoreFindNoteCountsArgs
  _args183.AuthenticationToken = authenticationToken
  _args183.Filter = filter
  _args183.WithTrash = withTrash
  var _result185 NoteStoreFindNoteCountsResult
  var _meta184 thrift.ResponseMeta
  _meta184, _err = p.Client_().Call(ctx, "findNoteCounts", &_args183, &_result185)
  p.SetLastResponseMeta_(_meta184)
  if _err != nil {
    return
  }
  switch {
  case _result185.UserException!= nil:
    return _r, _result185.UserException
  case _result185.SystemException!= nil:
    return _r, _result185.SystemException
  case _result185.NotFoundException!= nil:
    return _r, _result185.NotFoundException
  }

  if _ret186 := _result185.GetSuccess(); _ret186 != nil {
    return _ret186, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "findNoteCounts failed: unknown result")
}

// Returns the current state of the note in the service with the provided
// GUID.  The ENML contents of the note will only be provided if the
// 'withContent' parameter is true.  The service will include the meta-data
// for each resource in the note, but the binary content depends
// on whether it is explicitly requested in resultSpec parameter.
// If the Note is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).  The applicationData
// fields are returned as keysOnly.
// 
// @param authenticationToken
//   An authentication token that grants the caller access to the requested note.
// 
// @param guid
//   The GUID of the note to be retrieved.
// 
// @param resultSpec
//   A structure specifying the fields of the note that the caller would like to get.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - ResultSpec
func (p *NoteStoreClient) GetNoteWithResultSpec(ctx context.Context, authenticationToken string, guid GUID, resultSpec *NoteResultSpec) (_r *Note, _err error) {
  var _args187 NoteStoreGetNoteWithResultSpecArgs
  _args187.AuthenticationToken = authenticationToken
  _args187.GUID = guid
  _args187.ResultSpec = resultSpec
  var _result189 NoteStoreGetNoteWithResultSpecResult
  var _meta188 thrift.ResponseMeta
  _meta188, _err = p.Client_().Call(ctx, "getNoteWithResultSpec", &_args187, &_result189)
  p.SetLastResponseMeta_(_meta188)
  if _err != nil {
    return
  }
  switch {
  case _result189.UserException!= nil:
    return _r, _result189.UserException
  case _result189.SystemException!= nil:
    return _r, _result189.SystemException
  case _result189.NotFoundException!= nil:
    return _r, _result189.NotFoundException
  }

  if _ret190 := _result189.GetSuccess(); _ret190 != nil {
    return _ret190, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNoteWithResultSpec failed: unknown result")
}

// DEPRECATED. See getNoteWithResultSpec.
// 
// This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
// mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
// populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - WithContent
//  - WithResourcesData
//  - WithResourcesRecognition
//  - WithResourcesAlternateData
func (p *NoteStoreClient) GetNote(ctx context.Context, authenticationToken string, guid GUID, withContent bool, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (_r *Note, _err error) {
  var _args191 NoteStoreGetNoteArgs
  _args191.AuthenticationToken = authenticationToken
  _args191.GUID = guid
  _args191.WithContent = withContent
  _args191.WithResourcesData = withResourcesData
  _args191.WithResourcesRecognition = withResourcesRecognition
  _args191.WithResourcesAlternateData = withResourcesAlternateData
  var _result193 NoteStoreGetNoteResult
  var _meta192 thrift.ResponseMeta
  _meta192, _err = p.Client_().Call(ctx, "getNote", &_args191, &_result193)
  p.SetLastResponseMeta_(_meta192)
  if _err != nil {
    return
  }
  switch {
  case _result193.UserException!= nil:
    return _r, _result193.UserException
  case _result193.SystemException!= nil:
    return _r, _result193.SystemException
  case _result193.NotFoundException!= nil:
    return _r, _result193.NotFoundException
  }

  if _ret194 := _result193.GetSuccess(); _ret194 != nil {
    return _ret194, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNote failed: unknown result")
}

// Get all of the application data for the note identified by GUID,
// with values returned within the LazyMap fullMap field.
// If there are no applicationData entries, then a LazyMap
// with an empty fullMap will be returned. If your application
// only needs to fetch its own applicationData entry, use
// getNoteApplicationDataEntry instead.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetNoteApplicationData(ctx context.Context, authenticationToken string, guid GUID) (_r *LazyMap, _err error) {
  var _args195 NoteStoreGetNoteApplicationDataArgs
  _args195.AuthenticationToken = authenticationToken
  _args195.GUID = guid
  var _result197 NoteStoreGetNoteApplicationDataResult
  var _meta196 thrift.ResponseMeta
  _meta196, _err = p.Client_().Call(ctx, "getNoteApplicationData", &_args195, &_result197)
  p.SetLastResponseMeta_(_meta196)
  if _err != nil {
    return
  }
  switch {
  case _result197.UserException!= nil:
    return _r, _result197.UserException
  case _result197.SystemException!= nil:
    return _r, _result197.SystemException
  case _result197.NotFoundException!= nil:
    return _r, _result197.NotFoundException
  }

  if _ret198 := _result197.GetSuccess(); _ret198 != nil {
    return _ret198, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNoteApplicationData failed: unknown result")
}

// Get the value of a single entry in the applicationData map
// for the note identified by GUID.
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - note not found, by GUID</li>
//   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - Key
func (p *NoteStoreClient) GetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r string, _err error) {
  var _args199 NoteStoreGetNoteApplicationDataEntryArgs
  _args199.AuthenticationToken = authenticationToken
  _args199.GUID = guid
  _args199.Key = key
  var _result201 NoteStoreGetNoteApplicationDataEntryResult
  var _meta200 thrift.ResponseMeta
  _meta200, _err = p.Client_().Call(ctx, "getNoteApplicationDataEntry", &_args199, &_result201)
  p.SetLastResponseMeta_(_meta200)
  if _err != nil {
    return
  }
  switch {
  case _result201.UserException!= nil:
    return _r, _result201.UserException
  case _result201.SystemException!= nil:
    return _r, _result201.SystemException
  case _result201.NotFoundException!= nil:
    return _r, _result201.NotFoundException
  }

  return _result201.GetSuccess(), nil
}

// Update, or create, an entry in the applicationData map for
// the note identified by guid.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - Key
//  - Value
func (p *NoteStoreClient) SetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string, value string) (_r int32, _err error) {
  var _args202 NoteStoreSetNoteApplicationDataEntryArgs
  _args202.AuthenticationToken = authenticationToken
  _args202.GUID = guid
  _args202.Key = key
  _args202.Value = value
  var _result204 NoteStoreSetNoteApplicationDataEntryResult
  var _meta203 thrift.ResponseMeta
  _meta203, _err = p.Client_().Call(ctx, "setNoteApplicationDataEntry", &_args202, &_result204)
  p.SetLastResponseMeta_(_meta203)
  if _err != nil {
    return
  }
  switch {
  case _result204.UserException!= nil:
    return _r, _result204.UserException
  case _result204.SystemException!= nil:
    return _r, _result204.SystemException
  case _result204.NotFoundException!= nil:
    return _r, _result204.NotFoundException
  }

  return _result204.GetSuccess(), nil
}

// Remove an entry identified by 'key' from the applicationData map for
// the note identified by 'guid'. Silently ignores an unset of a
// non-existing key.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - Key
func (p *NoteStoreClient) UnsetNoteApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r int32, _err error) {
  var _args205 NoteStoreUnsetNoteApplicationDataEntryArgs
  _args205.AuthenticationToken = authenticationToken
  _args205.GUID = guid
  _args205.Key = key
  var _result207 NoteStoreUnsetNoteApplicationDataEntryResult
  var _meta206 thrift.ResponseMeta
  _meta206, _err = p.Client_().Call(ctx, "unsetNoteApplicationDataEntry", &_args205, &_result207)
  p.SetLastResponseMeta_(_meta206)
  if _err != nil {
    return
  }
  switch {
  case _result207.UserException!= nil:
    return _r, _result207.UserException
  case _result207.SystemException!= nil:
    return _r, _result207.SystemException
  case _result207.NotFoundException!= nil:
    return _r, _result207.NotFoundException
  }

  return _result207.GetSuccess(), nil
}

// Returns XHTML contents of the note with the provided GUID.
// If the Note is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
// 
// @param guid
//   The GUID of the note to be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetNoteContent(ctx context.Context, authenticationToken string, guid GUID) (_r string, _err error) {
  var _args208 NoteStoreGetNoteContentArgs
  _args208.AuthenticationToken = authenticationToken
  _args208.GUID = guid
  var _result210 NoteStoreGetNoteContentResult
  var _meta209 thrift.ResponseMeta
  _meta209, _err = p.Client_().Call(ctx, "getNoteContent", &_args208, &_result210)
  p.SetLastResponseMeta_(_meta209)
  if _err != nil {
    return
  }
  switch {
  case _result210.UserException!= nil:
    return _r, _result210.UserException
  case _result210.SystemException!= nil:
    return _r, _result210.SystemException
  case _result210.NotFoundException!= nil:
    return _r, _result210.NotFoundException
  }

  return _result210.GetSuccess(), nil
}

// Returns a block of the extracted plain text contents of the note with the
// provided GUID.  This text can be indexed for search purposes by a light
// client that doesn't have capabilities to extract all of the searchable
// text content from the note and its resources.
// 
// If the Note is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
// 
// @param guid
//   The GUID of the note to be retrieved.
// 
// @param noteOnly
//   If true, this will only return the text extracted from the ENML contents
//   of the note itself.  If false, this will also include the extracted text
//   from any text-bearing resources (PDF, recognized images)
// 
// @param tokenizeForIndexing
//   If true, this will break the text into cleanly separated and sanitized
//   tokens.  If false, this will return the more raw text extraction, with
//   its original punctuation, capitalization, spacing, etc.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - NoteOnly
//  - TokenizeForIndexing
func (p *NoteStoreClient) GetNoteSearchText(ctx context.Context, authenticationToken string, guid GUID, noteOnly bool, tokenizeForIndexing bool) (_r string, _err error) {
  var _args211 NoteStoreGetNoteSearchTextArgs
  _args211.AuthenticationToken = authenticationToken
  _args211.GUID = guid
  _args211.NoteOnly = noteOnly
  _args211.TokenizeForIndexing = tokenizeForIndexing
  var _result213 NoteStoreGetNoteSearchTextResult
  var _meta212 thrift.ResponseMeta
  _meta212, _err = p.Client_().Call(ctx, "getNoteSearchText", &_args211, &_result213)
  p.SetLastResponseMeta_(_meta212)
  if _err != nil {
    return
  }
  switch {
  case _result213.UserException!= nil:
    return _r, _result213.UserException
  case _result213.SystemException!= nil:
    return _r, _result213.SystemException
  case _result213.NotFoundException!= nil:
    return _r, _result213.NotFoundException
  }

  return _result213.GetSuccess(), nil
}

// Returns a block of the extracted plain text contents of the resource with
// the provided GUID.  This text can be indexed for search purposes by a light
// client that doesn't have capability to extract all of the searchable
// text content from a resource.
// 
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
// 
// @param guid
//   The GUID of the resource to be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetResourceSearchText(ctx context.Context, authenticationToken string, guid GUID) (_r string, _err error) {
  var _args214 NoteStoreGetResourceSearchTextArgs
  _args214.AuthenticationToken = authenticationToken
  _args214.GUID = guid
  var _result216 NoteStoreGetResourceSearchTextResult
  var _meta215 thrift.ResponseMeta
  _meta215, _err = p.Client_().Call(ctx, "getResourceSearchText", &_args214, &_result216)
  p.SetLastResponseMeta_(_meta215)
  if _err != nil {
    return
  }
  switch {
  case _result216.UserException!= nil:
    return _r, _result216.UserException
  case _result216.SystemException!= nil:
    return _r, _result216.SystemException
  case _result216.NotFoundException!= nil:
    return _r, _result216.NotFoundException
  }

  return _result216.GetSuccess(), nil
}

// Returns a list of the names of the tags for the note with the provided
// guid.  This can be used with authentication to get the tags for a
// user's own note, or can be used without valid authentication to retrieve
// the names of the tags for a note in a public notebook.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetNoteTagNames(ctx context.Context, authenticationToken string, guid GUID) (_r []string, _err error) {
  var _args217 NoteStoreGetNoteTagNamesArgs
  _args217.AuthenticationToken = authenticationToken
  _args217.GUID = guid
  var _result219 NoteStoreGetNoteTagNamesResult
  var _meta218 thrift.ResponseMeta
  _meta218, _err = p.Client_().Call(ctx, "getNoteTagNames", &_args217, &_result219)
  p.SetLastResponseMeta_(_meta218)
  if _err != nil {
    return
  }
  switch {
  case _result219.UserException!= nil:
    return _r, _result219.UserException
  case _result219.SystemException!= nil:
    return _r, _result219.SystemException
  case _result219.NotFoundException!= nil:
    return _r, _result219.NotFoundException
  }

  return _result219.GetSuccess(), nil
}

// Asks the service to make a note with the provided set of information.
// 
// @param note
//   A Note object containing the desired fields to be populated on
//   the service.
// 
// @return
//   The newly created Note from the service.  The server-side
//   GUIDs for the Note and any Resources will be saved in this object.
//   The service will include the meta-data
//   for each resource in the note, but the binary contents of the resources
//   and their recognition data will be omitted (except Recognition Resource body,
//   for which the behavior is unspecified).
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
//   </li>
//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
//   </li>
//   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
//   </li>
//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
//   </li>
//   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
//   </li>
//   <li> DATA_REQUIRED "Resource.data" - resource data body missing
//   </li>
//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
//   </li>
//   <li> LIMIT_REACHED "Note" - at max number per account
//   </li>
//   <li> LIMIT_REACHED "Note.size" - total note size too large
//   </li>
//   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
//   </li>
//   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
//   </li>
//   <li> LIMIT_REACHED "Resource.data.size" - resource too large
//   </li>
//   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
//   </li>
//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
//   </li>
//   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
//   </li>
//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
//     of the specified tags had an invalid length or pattern
//   </li>
//   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
//     new tags would exceed the maximum number per account
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.notebookGuid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Note
func (p *NoteStoreClient) CreateNote(ctx context.Context, authenticationToken string, note *Note) (_r *Note, _err error) {
  var _args220 NoteStoreCreateNoteArgs
  _args220.AuthenticationToken = authenticationToken
  _args220.Note = note
  var _result222 NoteStoreCreateNoteResult
  var _meta221 thrift.ResponseMeta
  _meta221, _err = p.Client_().Call(ctx, "createNote", &_args220, &_result222)
  p.SetLastResponseMeta_(_meta221)
  if _err != nil {
    return
  }
  switch {
  case _result222.UserException!= nil:
    return _r, _result222.UserException
  case _result222.SystemException!= nil:
    return _r, _result222.SystemException
  case _result222.NotFoundException!= nil:
    return _r, _result222.NotFoundException
  }

  if _ret223 := _result222.GetSuccess(); _ret223 != nil {
    return _ret223, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createNote failed: unknown result")
}

// Submit a set of changes to a note to the service.  The provided data
// must include the note's guid field for identification. The note's
// title must also be set.
// 
// @param note
//   A Note object containing the desired fields to be populated on
//   the service. With the exception of the note's title and guid, fields
//   that are not being changed do not need to be set. If the content is not
//   being modified, note.content should be left unset. If the list of
//   resources is not being modified, note.resources should be left unset.
// 
// @return
//   The Note.sharedNotes field will not be set.
//   The service will include the meta-data
//   for each resource in the note, but the binary contents of the resources
//   and their recognition data will be omitted.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
//   </li>
//   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
//   </li>
//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
//   </li>
//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
//   </li>
//   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
//   </li>
//   <li> DATA_REQUIRED "Resource.data" - resource data body missing
//   </li>
//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
//   </li>
//   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
//   </li>
//   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
//   </li>
//   <li> LIMIT_REACHED "Note.size" - total note size too large
//   </li>
//   <li> LIMIT_REACHED "Resource.data.size" - resource too large
//   </li>
//   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
//   </li>
//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
//   </li>
//   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
//   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
//     modify the note's tags. note.tags must be unset.
//   </li>
//   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
//     to modify the note's attributes. note.attributes must be unset.
//   </li>
//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
//   </li>
//   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
//     of the specified tags had an invalid length or pattern
//   </li>
//   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
//     new tags would exceed the maximum number per account
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - note not found, by GUID
//   </li>
//   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Note
func (p *NoteStoreClient) UpdateNote(ctx context.Context, authenticationToken string, note *Note) (_r *Note, _err error) {
  var _args224 NoteStoreUpdateNoteArgs
  _args224.AuthenticationToken = authenticationToken
  _args224.Note = note
  var _result226 NoteStoreUpdateNoteResult
  var _meta225 thrift.ResponseMeta
  _meta225, _err = p.Client_().Call(ctx, "updateNote", &_args224, &_result226)
  p.SetLastResponseMeta_(_meta225)
  if _err != nil {
    return
  }
  switch {
  case _result226.UserException!= nil:
    return _r, _result226.UserException
  case _result226.SystemException!= nil:
    return _r, _result226.SystemException
  case _result226.NotFoundException!= nil:
    return _r, _result226.NotFoundException
  }

  if _ret227 := _result226.GetSuccess(); _ret227 != nil {
    return _ret227, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "updateNote failed: unknown result")
}

// Moves the note into the trash. The note may still be undeleted, unless it
// is expunged.  This is equivalent to calling updateNote() after setting
// Note.active = false
// 
// @param guid
//   The GUID of the note to delete.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
//          update the note.
//   </li>
// </ul>
// 
// @throws EDAMUserException <ul>
//   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
//   </li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) DeleteNote(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error) {
  var _args228 NoteStoreDeleteNoteArgs
  _args228.AuthenticationToken = authenticationToken
  _args228.GUID = guid
  var _result230 NoteStoreDeleteNoteResult
  var _meta229 thrift.ResponseMeta
  _meta229, _err = p.Client_().Call(ctx, "deleteNote", &_args228, &_result230)
  p.SetLastResponseMeta_(_meta229)
  if _err != nil {
    return
  }
  switch {
  case _result230.UserException!= nil:
    return _r, _result230.UserException
  case _result230.SystemException!= nil:
    return _r, _result230.SystemException
  case _result230.NotFoundException!= nil:
    return _r, _result230.NotFoundException
  }

  return _result230.GetSuccess(), nil
}

// Permanently removes a Note, and all of its Resources,
// from the service.
// <p/>
// NOTE: This function is not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
// 
// @param guid
//   The GUID of the note to delete.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) ExpungeNote(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error) {
  var _args231 NoteStoreExpungeNoteArgs
  _args231.AuthenticationToken = authenticationToken
  _args231.GUID = guid
  var _result233 NoteStoreExpungeNoteResult
  var _meta232 thrift.ResponseMeta
  _meta232, _err = p.Client_().Call(ctx, "expungeNote", &_args231, &_result233)
  p.SetLastResponseMeta_(_meta232)
  if _err != nil {
    return
  }
  switch {
  case _result233.UserException!= nil:
    return _r, _result233.UserException
  case _result233.SystemException!= nil:
    return _r, _result233.SystemException
  case _result233.NotFoundException!= nil:
    return _r, _result233.NotFoundException
  }

  return _result233.GetSuccess(), nil
}

// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
// the Notebook with the provided GUID 'toNotebookGuid'.
// The caller must be the owner of both the Note and the Notebook.
// This creates a new Note in the destination Notebook with new content and
// Resources that match all of the content and Resources from the original
// Note, but with new GUID identifiers.
// The original Note is not modified by this operation.
// The copied note is considered as an "upload" for the purpose of upload
// transfer limit calculation, so its size is added to the upload count for
// the owner.
// 
// If the original note has been shared and has SharedNote records, the shares
// are NOT copied.
// 
// @param noteGuid
//   The GUID of the Note to copy.
// 
// @param toNotebookGuid
//   The GUID of the Notebook that should receive the new Note.
// 
// @return
//   The metadata for the new Note that was created.  This will include the
//   new GUID for this Note (and any copied Resources), but will not include
//   the content body or the binary bodies of any Resources.
// 
// @throws EDAMUserException <ul>
//   <li> LIMIT_REACHED "Note" - at max number per account
//   </li>
//   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
//   </li>
//   <li> PERMISSION_DENIED "Note" - user doesn't own
//   </li>
//   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Notebook.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
//  - ToNotebookGuid
func (p *NoteStoreClient) CopyNote(ctx context.Context, authenticationToken string, noteGuid GUID, toNotebookGuid GUID) (_r *Note, _err error) {
  var _args234 NoteStoreCopyNoteArgs
  _args234.AuthenticationToken = authenticationToken
  _args234.NoteGuid = noteGuid
  _args234.ToNotebookGuid = toNotebookGuid
  var _result236 NoteStoreCopyNoteResult
  var _meta235 thrift.ResponseMeta
  _meta235, _err = p.Client_().Call(ctx, "copyNote", &_args234, &_result236)
  p.SetLastResponseMeta_(_meta235)
  if _err != nil {
    return
  }
  switch {
  case _result236.UserException!= nil:
    return _r, _result236.UserException
  case _result236.SystemException!= nil:
    return _r, _result236.SystemException
  case _result236.NotFoundException!= nil:
    return _r, _result236.NotFoundException
  }

  if _ret237 := _result236.GetSuccess(); _ret237 != nil {
    return _ret237, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "copyNote failed: unknown result")
}

// Returns a list of the prior versions of a particular note that are
// saved within the service.  These prior versions are stored to provide a
// recovery from unintentional removal of content from a note. The identifiers
// that are returned by this call can be used with getNoteVersion to retrieve
// the previous note.
// The identifiers will be listed from the most recent versions to the oldest.
// This call is only available for notes in Premium accounts. (I.e. access
// to past versions of Notes is a Premium-only feature.)
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
//   </li>
//   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID.
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
func (p *NoteStoreClient) ListNoteVersions(ctx context.Context, authenticationToken string, noteGuid GUID) (_r []*NoteVersionId, _err error) {
  var _args238 NoteStoreListNoteVersionsArgs
  _args238.AuthenticationToken = authenticationToken
  _args238.NoteGuid = noteGuid
  var _result240 NoteStoreListNoteVersionsResult
  var _meta239 thrift.ResponseMeta
  _meta239, _err = p.Client_().Call(ctx, "listNoteVersions", &_args238, &_result240)
  p.SetLastResponseMeta_(_meta239)
  if _err != nil {
    return
  }
  switch {
  case _result240.UserException!= nil:
    return _r, _result240.UserException
  case _result240.SystemException!= nil:
    return _r, _result240.SystemException
  case _result240.NotFoundException!= nil:
    return _r, _result240.NotFoundException
  }

  return _result240.GetSuccess(), nil
}

// This can be used to retrieve a previous version of a Note after it has been
// updated within the service.  The caller must identify the note (via its
// guid) and the version (via the updateSequenceNumber of that version).
// to find a listing of the stored version USNs for a note, call
// listNoteVersions.
// This call is only available for notes in Premium accounts. (I.e. access
// to past versions of Notes is a Premium-only feature.)
// 
// @param noteGuid
//   The GUID of the note to be retrieved.
// 
// @param updateSequenceNum
//   The USN of the version of the note that is being retrieved
// 
// @param withResourcesData
//   If true, any Resource elements in this Note will include the binary
//   contents of their 'data' field's body.
// 
// @param withResourcesRecognition
//   If true, any Resource elements will include the binary contents of the
//   'recognition' field's body if recognition data is present.
// 
// @param withResourcesAlternateData
//   If true, any Resource elements in this Note will include the binary
//   contents of their 'alternateData' fields' body, if an alternate form
//   is present.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
//   </li>
//   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID.
//   </li>
//   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
//      the corresponding USN.
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
//  - UpdateSequenceNum
//  - WithResourcesData
//  - WithResourcesRecognition
//  - WithResourcesAlternateData
func (p *NoteStoreClient) GetNoteVersion(ctx context.Context, authenticationToken string, noteGuid GUID, updateSequenceNum int32, withResourcesData bool, withResourcesRecognition bool, withResourcesAlternateData bool) (_r *Note, _err error) {
  var _args241 NoteStoreGetNoteVersionArgs
  _args241.AuthenticationToken = authenticationToken
  _args241.NoteGuid = noteGuid
  _args241.UpdateSequenceNum = updateSequenceNum
  _args241.WithResourcesData = withResourcesData
  _args241.WithResourcesRecognition = withResourcesRecognition
  _args241.WithResourcesAlternateData = withResourcesAlternateData
  var _result243 NoteStoreGetNoteVersionResult
  var _meta242 thrift.ResponseMeta
  _meta242, _err = p.Client_().Call(ctx, "getNoteVersion", &_args241, &_result243)
  p.SetLastResponseMeta_(_meta242)
  if _err != nil {
    return
  }
  switch {
  case _result243.UserException!= nil:
    return _r, _result243.UserException
  case _result243.SystemException!= nil:
    return _r, _result243.SystemException
  case _result243.NotFoundException!= nil:
    return _r, _result243.NotFoundException
  }

  if _ret244 := _result243.GetSuccess(); _ret244 != nil {
    return _ret244, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNoteVersion failed: unknown result")
}

// Returns the current state of the resource in the service with the
// provided GUID.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).  Only the
// keys for the applicationData will be returned.
// 
// @param guid
//   The GUID of the resource to be retrieved.
// 
// @param withData
//   If true, the Resource will include the binary contents of the
//   'data' field's body.
// 
// @param withRecognition
//   If true, the Resource will include the binary contents of the
//   'recognition' field's body if recognition data is present.
// 
// @param withAttributes
//   If true, the Resource will include the attributes
// 
// @param withAlternateData
//   If true, the Resource will include the binary contents of the
//   'alternateData' field's body, if an alternate form is present.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - WithData
//  - WithRecognition
//  - WithAttributes
//  - WithAlternateData
func (p *NoteStoreClient) GetResource(ctx context.Context, authenticationToken string, guid GUID, withData bool, withRecognition bool, withAttributes bool, withAlternateData bool) (_r *Resource, _err error) {
  var _args245 NoteStoreGetResourceArgs
  _args245.AuthenticationToken = authenticationToken
  _args245.GUID = guid
  _args245.WithData = withData
  _args245.WithRecognition = withRecognition
  _args245.WithAttributes = withAttributes
  _args245.WithAlternateData = withAlternateData
  var _result247 NoteStoreGetResourceResult
  var _meta246 thrift.ResponseMeta
  _meta246, _err = p.Client_().Call(ctx, "getResource", &_args245, &_result247)
  p.SetLastResponseMeta_(_meta246)
  if _err != nil {
    return
  }
  switch {
  case _result247.UserException!= nil:
    return _r, _result247.UserException
  case _result247.SystemException!= nil:
    return _r, _result247.SystemException
  case _result247.NotFoundException!= nil:
    return _r, _result247.NotFoundException
  }

  if _ret248 := _result247.GetSuccess(); _ret248 != nil {
    return _ret248, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getResource failed: unknown result")
}

// Get all of the application data for the Resource identified by GUID,
// with values returned within the LazyMap fullMap field.
// If there are no applicationData entries, then a LazyMap
// with an empty fullMap will be returned. If your application
// only needs to fetch its own applicationData entry, use
// getResourceApplicationDataEntry instead.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetResourceApplicationData(ctx context.Context, authenticationToken string, guid GUID) (_r *LazyMap, _err error) {
  var _args249 NoteStoreGetResourceApplicationDataArgs
  _args249.AuthenticationToken = authenticationToken
  _args249.GUID = guid
  var _result251 NoteStoreGetResourceApplicationDataResult
  var _meta250 thrift.ResponseMeta
  _meta250, _err = p.Client_().Call(ctx, "getResourceApplicationData", &_args249, &_result251)
  p.SetLastResponseMeta_(_meta250)
  if _err != nil {
    return
  }
  switch {
  case _result251.UserException!= nil:
    return _r, _result251.UserException
  case _result251.SystemException!= nil:
    return _r, _result251.SystemException
  case _result251.NotFoundException!= nil:
    return _r, _result251.NotFoundException
  }

  if _ret252 := _result251.GetSuccess(); _ret252 != nil {
    return _ret252, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getResourceApplicationData failed: unknown result")
}

// Get the value of a single entry in the applicationData map
// for the Resource identified by GUID.
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - Resource not found, by GUID</li>
//   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - Key
func (p *NoteStoreClient) GetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r string, _err error) {
  var _args253 NoteStoreGetResourceApplicationDataEntryArgs
  _args253.AuthenticationToken = authenticationToken
  _args253.GUID = guid
  _args253.Key = key
  var _result255 NoteStoreGetResourceApplicationDataEntryResult
  var _meta254 thrift.ResponseMeta
  _meta254, _err = p.Client_().Call(ctx, "getResourceApplicationDataEntry", &_args253, &_result255)
  p.SetLastResponseMeta_(_meta254)
  if _err != nil {
    return
  }
  switch {
  case _result255.UserException!= nil:
    return _r, _result255.UserException
  case _result255.SystemException!= nil:
    return _r, _result255.SystemException
  case _result255.NotFoundException!= nil:
    return _r, _result255.NotFoundException
  }

  return _result255.GetSuccess(), nil
}

// Update, or create, an entry in the applicationData map for
// the Resource identified by guid.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - Key
//  - Value
func (p *NoteStoreClient) SetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string, value string) (_r int32, _err error) {
  var _args256 NoteStoreSetResourceApplicationDataEntryArgs
  _args256.AuthenticationToken = authenticationToken
  _args256.GUID = guid
  _args256.Key = key
  _args256.Value = value
  var _result258 NoteStoreSetResourceApplicationDataEntryResult
  var _meta257 thrift.ResponseMeta
  _meta257, _err = p.Client_().Call(ctx, "setResourceApplicationDataEntry", &_args256, &_result258)
  p.SetLastResponseMeta_(_meta257)
  if _err != nil {
    return
  }
  switch {
  case _result258.UserException!= nil:
    return _r, _result258.UserException
  case _result258.SystemException!= nil:
    return _r, _result258.SystemException
  case _result258.NotFoundException!= nil:
    return _r, _result258.NotFoundException
  }

  return _result258.GetSuccess(), nil
}

// Remove an entry identified by 'key' from the applicationData map for
// the Resource identified by 'guid'.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
//  - Key
func (p *NoteStoreClient) UnsetResourceApplicationDataEntry(ctx context.Context, authenticationToken string, guid GUID, key string) (_r int32, _err error) {
  var _args259 NoteStoreUnsetResourceApplicationDataEntryArgs
  _args259.AuthenticationToken = authenticationToken
  _args259.GUID = guid
  _args259.Key = key
  var _result261 NoteStoreUnsetResourceApplicationDataEntryResult
  var _meta260 thrift.ResponseMeta
  _meta260, _err = p.Client_().Call(ctx, "unsetResourceApplicationDataEntry", &_args259, &_result261)
  p.SetLastResponseMeta_(_meta260)
  if _err != nil {
    return
  }
  switch {
  case _result261.UserException!= nil:
    return _r, _result261.UserException
  case _result261.SystemException!= nil:
    return _r, _result261.SystemException
  case _result261.NotFoundException!= nil:
    return _r, _result261.NotFoundException
  }

  return _result261.GetSuccess(), nil
}

// Submit a set of changes to a resource to the service.  This can be used
// to update the meta-data about the resource, but cannot be used to change
// the binary contents of the resource (including the length and hash).  These
// cannot be changed directly without creating a new resource and removing the
// old one via updateNote.
// 
// @param resource
//   A Resource object containing the desired fields to be populated on
//   the service.  The service will attempt to update the resource with the
//   following fields from the client:
//   <ul>
//      <li>guid:  must be provided to identify the resource
//      </li>
//      <li>mime
//      </li>
//      <li>width
//      </li>
//      <li>height
//      </li>
//      <li>duration
//      </li>
//      <li>attributes:  optional.  if present, the set of attributes will
//           be replaced.
//      </li>
//   </ul>
// 
// @return
//   The Update Sequence Number of the resource after the changes have been
//   applied.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
//   </li>
//   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
//   </li>
//   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Resource
func (p *NoteStoreClient) UpdateResource(ctx context.Context, authenticationToken string, resource *Resource) (_r int32, _err error) {
  var _args262 NoteStoreUpdateResourceArgs
  _args262.AuthenticationToken = authenticationToken
  _args262.Resource = resource
  var _result264 NoteStoreUpdateResourceResult
  var _meta263 thrift.ResponseMeta
  _meta263, _err = p.Client_().Call(ctx, "updateResource", &_args262, &_result264)
  p.SetLastResponseMeta_(_meta263)
  if _err != nil {
    return
  }
  switch {
  case _result264.UserException!= nil:
    return _r, _result264.UserException
  case _result264.SystemException!= nil:
    return _r, _result264.SystemException
  case _result264.NotFoundException!= nil:
    return _r, _result264.NotFoundException
  }

  return _result264.GetSuccess(), nil
}

// Returns binary data of the resource with the provided GUID.  For
// example, if this were an image resource, this would contain the
// raw bits of the image.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
// 
// @param guid
//   The GUID of the resource to be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetResourceData(ctx context.Context, authenticationToken string, guid GUID) (_r []byte, _err error) {
  var _args265 NoteStoreGetResourceDataArgs
  _args265.AuthenticationToken = authenticationToken
  _args265.GUID = guid
  var _result267 NoteStoreGetResourceDataResult
  var _meta266 thrift.ResponseMeta
  _meta266, _err = p.Client_().Call(ctx, "getResourceData", &_args265, &_result267)
  p.SetLastResponseMeta_(_meta266)
  if _err != nil {
    return
  }
  switch {
  case _result267.UserException!= nil:
    return _r, _result267.UserException
  case _result267.SystemException!= nil:
    return _r, _result267.SystemException
  case _result267.NotFoundException!= nil:
    return _r, _result267.NotFoundException
  }

  return _result267.GetSuccess(), nil
}

// Returns the current state of a resource, referenced by containing
// note GUID and resource content hash.
// 
// @param noteGuid
//   The GUID of the note that holds the resource to be retrieved.
// 
// @param contentHash
//   The MD5 checksum of the resource within that note. Note that
//   this is the binary checksum, for example from Resource.data.bodyHash,
//   and not the hex-encoded checksum that is used within an en-media
//   tag in a note body.
// 
// @param withData
//   If true, the Resource will include the binary contents of the
//   'data' field's body.
// 
// @param withRecognition
//   If true, the Resource will include the binary contents of the
//   'recognition' field's body.
// 
// @param withAlternateData
//   If true, the Resource will include the binary contents of the
//   'alternateData' field's body, if an alternate form is present.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
//   </li>
//   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note" - not found, by guid
//   </li>
//   <li> "Resource" - not found, by hash
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - NoteGuid
//  - ContentHash
//  - WithData
//  - WithRecognition
//  - WithAlternateData
func (p *NoteStoreClient) GetResourceByHash(ctx context.Context, authenticationToken string, noteGuid GUID, contentHash []byte, withData bool, withRecognition bool, withAlternateData bool) (_r *Resource, _err error) {
  var _args268 NoteStoreGetResourceByHashArgs
  _args268.AuthenticationToken = authenticationToken
  _args268.NoteGuid = noteGuid
  _args268.ContentHash = contentHash
  _args268.WithData = withData
  _args268.WithRecognition = withRecognition
  _args268.WithAlternateData = withAlternateData
  var _result270 NoteStoreGetResourceByHashResult
  var _meta269 thrift.ResponseMeta
  _meta269, _err = p.Client_().Call(ctx, "getResourceByHash", &_args268, &_result270)
  p.SetLastResponseMeta_(_meta269)
  if _err != nil {
    return
  }
  switch {
  case _result270.UserException!= nil:
    return _r, _result270.UserException
  case _result270.SystemException!= nil:
    return _r, _result270.SystemException
  case _result270.NotFoundException!= nil:
    return _r, _result270.NotFoundException
  }

  if _ret271 := _result270.GetSuccess(); _ret271 != nil {
    return _ret271, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getResourceByHash failed: unknown result")
}

// Returns the binary contents of the recognition index for the resource
// with the provided GUID.  If the caller asks about a resource that has
// no recognition data, this will throw EDAMNotFoundException.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
// 
// @param guid
//   The GUID of the resource whose recognition data should be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
//   <li> "Resource.recognition" - resource has no recognition
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetResourceRecognition(ctx context.Context, authenticationToken string, guid GUID) (_r []byte, _err error) {
  var _args272 NoteStoreGetResourceRecognitionArgs
  _args272.AuthenticationToken = authenticationToken
  _args272.GUID = guid
  var _result274 NoteStoreGetResourceRecognitionResult
  var _meta273 thrift.ResponseMeta
  _meta273, _err = p.Client_().Call(ctx, "getResourceRecognition", &_args272, &_result274)
  p.SetLastResponseMeta_(_meta273)
  if _err != nil {
    return
  }
  switch {
  case _result274.UserException!= nil:
    return _r, _result274.UserException
  case _result274.SystemException!= nil:
    return _r, _result274.SystemException
  case _result274.NotFoundException!= nil:
    return _r, _result274.NotFoundException
  }

  return _result274.GetSuccess(), nil
}

// If the Resource with the provided GUID has an alternate data representation
// (indicated via the Resource.alternateData field), then this request can
// be used to retrieve the binary contents of that alternate data file.
// If the caller asks about a resource that has no alternate data form, this
// will throw EDAMNotFoundException.
// 
// @param guid
//    The GUID of the resource whose recognition data should be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
//   <li> "Resource.alternateData" - resource has no recognition
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetResourceAlternateData(ctx context.Context, authenticationToken string, guid GUID) (_r []byte, _err error) {
  var _args275 NoteStoreGetResourceAlternateDataArgs
  _args275.AuthenticationToken = authenticationToken
  _args275.GUID = guid
  var _result277 NoteStoreGetResourceAlternateDataResult
  var _meta276 thrift.ResponseMeta
  _meta276, _err = p.Client_().Call(ctx, "getResourceAlternateData", &_args275, &_result277)
  p.SetLastResponseMeta_(_meta276)
  if _err != nil {
    return
  }
  switch {
  case _result277.UserException!= nil:
    return _r, _result277.UserException
  case _result277.SystemException!= nil:
    return _r, _result277.SystemException
  case _result277.NotFoundException!= nil:
    return _r, _result277.NotFoundException
  }

  return _result277.GetSuccess(), nil
}

// Returns the set of attributes for the Resource with the provided GUID.
// If the Resource is found in a public notebook, the authenticationToken
// will be ignored (so it could be an empty string).
// 
// @param guid
//   The GUID of the resource whose attributes should be retrieved.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
//   </li>
//   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Resource.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) GetResourceAttributes(ctx context.Context, authenticationToken string, guid GUID) (_r *ResourceAttributes, _err error) {
  var _args278 NoteStoreGetResourceAttributesArgs
  _args278.AuthenticationToken = authenticationToken
  _args278.GUID = guid
  var _result280 NoteStoreGetResourceAttributesResult
  var _meta279 thrift.ResponseMeta
  _meta279, _err = p.Client_().Call(ctx, "getResourceAttributes", &_args278, &_result280)
  p.SetLastResponseMeta_(_meta279)
  if _err != nil {
    return
  }
  switch {
  case _result280.UserException!= nil:
    return _r, _result280.UserException
  case _result280.SystemException!= nil:
    return _r, _result280.SystemException
  case _result280.NotFoundException!= nil:
    return _r, _result280.NotFoundException
  }

  if _ret281 := _result280.GetSuccess(); _ret281 != nil {
    return _ret281, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getResourceAttributes failed: unknown result")
}

// <p>
// Looks for a user account with the provided userId on this NoteStore
// shard and determines whether that account contains a public notebook
// with the given URI.  If the account is not found, or no public notebook
// exists with this URI, this will throw an EDAMNotFoundException,
// otherwise this will return the information for that Notebook.
// </p>
// <p>
// If a notebook is visible on the web with a full URL like
// http://www.evernote.com/pub/sethdemo/api
// Then 'sethdemo' is the username that can be used to look up the userId,
// and 'api' is the publicUri.
// </p>
// 
// @param userId
//    The numeric identifier for the user who owns the public notebook.
//    To find this value based on a username string, you can invoke
//    UserStore.getPublicUserInfo
// 
// @param publicUri
//    The uri string for the public notebook, from Notebook.publishing.uri.
// 
// @throws EDAMNotFoundException <ul>
//   <li>"Publishing.uri" - not found, by URI</li>
// </ul>
// 
// @throws EDAMSystemException <ul>
//   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
//     taken down (for all requesters).</li>
//   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
//     down for the requester because of an IP-based country lookup.</li>
// </ul>
// 
// Parameters:
//  - UserId
//  - PublicUri
func (p *NoteStoreClient) GetPublicNotebook(ctx context.Context, userId UserID, publicUri string) (_r *Notebook, _err error) {
  var _args282 NoteStoreGetPublicNotebookArgs
  _args282.UserId = userId
  _args282.PublicUri = publicUri
  var _result284 NoteStoreGetPublicNotebookResult
  var _meta283 thrift.ResponseMeta
  _meta283, _err = p.Client_().Call(ctx, "getPublicNotebook", &_args282, &_result284)
  p.SetLastResponseMeta_(_meta283)
  if _err != nil {
    return
  }
  switch {
  case _result284.SystemException!= nil:
    return _r, _result284.SystemException
  case _result284.NotFoundException!= nil:
    return _r, _result284.NotFoundException
  }

  if _ret285 := _result284.GetSuccess(); _ret285 != nil {
    return _ret285, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getPublicNotebook failed: unknown result")
}

// * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
// *
// * Share a notebook with an email address, and optionally to a specific
// * recipient. If an existing SharedNotebook associated with
// * sharedNotebook.notebookGuid is found by recipientUsername or email, then
// * the values of sharedNotebook will be used to update the existing record,
// * else a new record will be created.
// *
// * If recipientUsername is set and there is already a SharedNotebook
// * for that Notebook with that recipientUsername and the privileges on the
// * existing notebook are lower, than on this one, this will update the
// * privileges and sharerUserId. If there isn't an existing SharedNotebook for
// * recipientUsername, this will create and return a shared notebook for that
// * email and recipientUsername. If recipientUsername is not set and there
// * already is a SharedNotebook for a Notebook for that email address and the
// * privileges on the existing SharedNotebook are lower than on this one, this
// * will update the privileges and sharerUserId, and return the updated
// * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
// * the email address.
// *
// * If the authenticationToken is a Business auth token, recipientUsername is
// * set and the recipient is in the same business as the business auth token,
// * this method will also auto-join the business user to the SharedNotebook -
// * that is it will set serviceJoined on the SharedNotebook and create a
// * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
// * The LinkedNotebook creation happens out-of-band, so there will be a delay
// * on the order of half a minute between the SharedNotebook and LinkedNotebook
// * creation.
// *
// * Also handles sending an email to the email addresses: if a SharedNotebook
// * is being created, this will send the shared notebook invite email, and
// * if a SharedNotebook already exists, it will send the shared notebook
// * reminder email. Both these emails contain a link to join the notebook.
// * If the notebook is being auto-joined, it sends an email with that
// * information to the recipient.
// *
// * @param authenticationToken
// *   Must be an authentication token from the owner or a shared notebook
// *   authentication token or business authentication token with sufficient
// *   permissions to change invitations for a notebook.
// *
// * @param sharedNotebook
// *   A shared notebook object populated with the email address of the share
// *   recipient, the notebook guid and the access permissions. All other
// *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
// *   field must be explicitly set with either a true or false value.
// *
// * @param message
// *   The sharer-defined message to put in the email sent out.
// *
// * @return
// *   The fully populated SharedNotebook object including the server assigned
// *   globalId which can both be used to uniquely identify the SharedNotebook.
// *
// * @throws EDAMUserException <ul>
// *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
// *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
// *       SharedNotebook.privilegeLevel was not set.</li>
// *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
// *       set. requireLogin is deprecated.</li>
// *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
// *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
// *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
//         owner's account is not confirmed.</li>
// *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
// *       recipientSettings is set in the sharedNotebook.  Only the recipient
// *       can set these values via the setSharedNotebookRecipientSettings
// *       method.</li>
// *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
// *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
// *   </ul>
// * @throws EDAMNotFoundException <ul>
// *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
// *   </li>
// *   </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - SharedNotebook
//  - Message
func (p *NoteStoreClient) ShareNotebook(ctx context.Context, authenticationToken string, sharedNotebook *SharedNotebook, message string) (_r *SharedNotebook, _err error) {
  var _args286 NoteStoreShareNotebookArgs
  _args286.AuthenticationToken = authenticationToken
  _args286.SharedNotebook = sharedNotebook
  _args286.Message = message
  var _result288 NoteStoreShareNotebookResult
  var _meta287 thrift.ResponseMeta
  _meta287, _err = p.Client_().Call(ctx, "shareNotebook", &_args286, &_result288)
  p.SetLastResponseMeta_(_meta287)
  if _err != nil {
    return
  }
  switch {
  case _result288.UserException!= nil:
    return _r, _result288.UserException
  case _result288.NotFoundException!= nil:
    return _r, _result288.NotFoundException
  case _result288.SystemException!= nil:
    return _r, _result288.SystemException
  }

  if _ret289 := _result288.GetSuccess(); _ret289 != nil {
    return _ret289, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "shareNotebook failed: unknown result")
}

// Share a notebook by a messaging thread ID or a list of contacts. This function is
// intended to be used in conjunction with Evernote messaging, and as such does not
// notify the recipient that a notebook has been shared with them.
// 
// Sharing with a subset of participants on a thread is accomplished by specifying both
// a thread ID and a list of contacts. This ensures that even if those contacts are
// on the thread under a deactivated identity, the correct user (the one who has the
// given contact on the thread) receives the share.
// 
// @param authenticationToken
//   An authentication token that grants the caller permission to share the notebook.
//   This should be an owner token if the notebook is owned by the caller.
//   If the notebook is a business notebook to which the caller has full access,
//   this should be their business authentication token. If the notebook is a shared
//   (non-business) notebook to which the caller has full access, this should be the
//   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
// 
// @param shareTemplate
//   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
//   should be shared, and the recipient information.
// 
// @return
//   A structure containing the USN of the Notebook after the change and a list of created
//   or updated SharedNotebooks.
// 
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
//   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
//     valid GUID</li>
//   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
//   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
//     specified</li>
//   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
//     is not allowed.</li>
//   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
//     specified, either by thread ID or as a list of contacts</li>
//   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
//     number of shares</li>
// </ul>
// 
// @throws EDAMInvalidContactsException <ul>
//   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
//     in shareTemplate.recipients was not syntactically valid, or if attempting to
//     share a notebook with an Evernote identity that the sharer does not have a
//     connection to. The exception will specify which recipients were invalid.</li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
//   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
//     specified, but no thread with that ID exists</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - ShareTemplate
func (p *NoteStoreClient) CreateOrUpdateNotebookShares(ctx context.Context, authenticationToken string, shareTemplate *NotebookShareTemplate) (_r *CreateOrUpdateNotebookSharesResult_, _err error) {
  var _args290 NoteStoreCreateOrUpdateNotebookSharesArgs
  _args290.AuthenticationToken = authenticationToken
  _args290.ShareTemplate = shareTemplate
  var _result292 NoteStoreCreateOrUpdateNotebookSharesResult
  var _meta291 thrift.ResponseMeta
  _meta291, _err = p.Client_().Call(ctx, "createOrUpdateNotebookShares", &_args290, &_result292)
  p.SetLastResponseMeta_(_meta291)
  if _err != nil {
    return
  }
  switch {
  case _result292.UserException!= nil:
    return _r, _result292.UserException
  case _result292.NotFoundException!= nil:
    return _r, _result292.NotFoundException
  case _result292.SystemException!= nil:
    return _r, _result292.SystemException
  case _result292.InvalidContactsException!= nil:
    return _r, _result292.InvalidContactsException
  }

  if _ret293 := _result292.GetSuccess(); _ret293 != nil {
    return _ret293, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createOrUpdateNotebookShares failed: unknown result")
}

// @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
// 
// Parameters:
//  - AuthenticationToken
//  - SharedNotebook
func (p *NoteStoreClient) UpdateSharedNotebook(ctx context.Context, authenticationToken string, sharedNotebook *SharedNotebook) (_r int32, _err error) {
  var _args294 NoteStoreUpdateSharedNotebookArgs
  _args294.AuthenticationToken = authenticationToken
  _args294.SharedNotebook = sharedNotebook
  var _result296 NoteStoreUpdateSharedNotebookResult
  var _meta295 thrift.ResponseMeta
  _meta295, _err = p.Client_().Call(ctx, "updateSharedNotebook", &_args294, &_result296)
  p.SetLastResponseMeta_(_meta295)
  if _err != nil {
    return
  }
  switch {
  case _result296.UserException!= nil:
    return _r, _result296.UserException
  case _result296.NotFoundException!= nil:
    return _r, _result296.NotFoundException
  case _result296.SystemException!= nil:
    return _r, _result296.SystemException
  }

  return _result296.GetSuccess(), nil
}

// Set values for the recipient settings associated with a notebook share. Only the
// recipient of the share can update their recipient settings.
// 
// If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
// you must leave that field unset in recipientSettings.
// This method will skip that field for updates and attempt to leave the existing value as
// it is.
// 
// If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
// will be either left as null or converted to false (if currently true).
// 
// To unset a notebook's stack, pass in the empty string for the stack field.
// 
// @param authenticationToken The owner authentication token for the recipient of the share.
// 
// @return The updated Notebook with the new recipient settings. Note that some of the
// recipient settings may differ from what was requested. Clients should update their state
// based on this return value.
// 
// @throws EDAMNotFoundException <ul>
//   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
//       notebookGuid on the given shard.</li>
//   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
//       user and is also not published to their business.</li>
// </ul>
// 
// @throws EDAMUserException <ul>
//   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
//       allowed to set recipient settings on the specified notebook.</li>
//   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
//       is allowed only for notebooks which belong to the same business as the user.</li>
//   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
//       to false and any of reminder* settings to true.</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - NotebookGuid
//  - RecipientSettings
func (p *NoteStoreClient) SetNotebookRecipientSettings(ctx context.Context, authenticationToken string, notebookGuid string, recipientSettings *NotebookRecipientSettings) (_r *Notebook, _err error) {
  var _args297 NoteStoreSetNotebookRecipientSettingsArgs
  _args297.AuthenticationToken = authenticationToken
  _args297.NotebookGuid = notebookGuid
  _args297.RecipientSettings = recipientSettings
  var _result299 NoteStoreSetNotebookRecipientSettingsResult
  var _meta298 thrift.ResponseMeta
  _meta298, _err = p.Client_().Call(ctx, "setNotebookRecipientSettings", &_args297, &_result299)
  p.SetLastResponseMeta_(_meta298)
  if _err != nil {
    return
  }
  switch {
  case _result299.UserException!= nil:
    return _r, _result299.UserException
  case _result299.NotFoundException!= nil:
    return _r, _result299.NotFoundException
  case _result299.SystemException!= nil:
    return _r, _result299.SystemException
  }

  if _ret300 := _result299.GetSuccess(); _ret300 != nil {
    return _ret300, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "setNotebookRecipientSettings failed: unknown result")
}

// Lists the collection of shared notebooks for all notebooks in the
// users account.
// 
// @return
//  The list of all SharedNotebooks for the user
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListSharedNotebooks(ctx context.Context, authenticationToken string) (_r []*SharedNotebook, _err error) {
  var _args301 NoteStoreListSharedNotebooksArgs
  _args301.AuthenticationToken = authenticationToken
  var _result303 NoteStoreListSharedNotebooksResult
  var _meta302 thrift.ResponseMeta
  _meta302, _err = p.Client_().Call(ctx, "listSharedNotebooks", &_args301, &_result303)
  p.SetLastResponseMeta_(_meta302)
  if _err != nil {
    return
  }
  switch {
  case _result303.UserException!= nil:
    return _r, _result303.UserException
  case _result303.NotFoundException!= nil:
    return _r, _result303.NotFoundException
  case _result303.SystemException!= nil:
    return _r, _result303.SystemException
  }

  return _result303.GetSuccess(), nil
}

// Asks the service to make a linked notebook with the provided name, username
// of the owner and identifiers provided. A linked notebook can be either a
// link to a public notebook or to a private shared notebook.
// 
// @param linkedNotebook
//   The desired fields for the linked notebook must be provided on this
//   object.  The name of the linked notebook must be set. Either a username
//   uri or a shard id and share key must be provided otherwise a
//   EDAMUserException is thrown.
// 
// @return
//   The newly created LinkedNotebook.  The server-side id will be
//   saved in this object's 'id' field.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
//   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
//     if public notebook set but bad uri
//   </li>
//   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
//     if private notebook but shard id not provided
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
//   </li>
// </ul>
// 
// @throws EDAMSystemException <ul>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
//     if a bad global identifer was set on a private notebook
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
func (p *NoteStoreClient) CreateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook) (_r *LinkedNotebook, _err error) {
  var _args304 NoteStoreCreateLinkedNotebookArgs
  _args304.AuthenticationToken = authenticationToken
  _args304.LinkedNotebook = linkedNotebook
  var _result306 NoteStoreCreateLinkedNotebookResult
  var _meta305 thrift.ResponseMeta
  _meta305, _err = p.Client_().Call(ctx, "createLinkedNotebook", &_args304, &_result306)
  p.SetLastResponseMeta_(_meta305)
  if _err != nil {
    return
  }
  switch {
  case _result306.UserException!= nil:
    return _r, _result306.UserException
  case _result306.NotFoundException!= nil:
    return _r, _result306.NotFoundException
  case _result306.SystemException!= nil:
    return _r, _result306.SystemException
  }

  if _ret307 := _result306.GetSuccess(); _ret307 != nil {
    return _ret307, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "createLinkedNotebook failed: unknown result")
}

// @param linkedNotebook
//   Updates the name of a linked notebook.
// 
// @return
//   The Update Sequence Number for this change within the account.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
//   </li>
//   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - LinkedNotebook
func (p *NoteStoreClient) UpdateLinkedNotebook(ctx context.Context, authenticationToken string, linkedNotebook *LinkedNotebook) (_r int32, _err error) {
  var _args308 NoteStoreUpdateLinkedNotebookArgs
  _args308.AuthenticationToken = authenticationToken
  _args308.LinkedNotebook = linkedNotebook
  var _result310 NoteStoreUpdateLinkedNotebookResult
  var _meta309 thrift.ResponseMeta
  _meta309, _err = p.Client_().Call(ctx, "updateLinkedNotebook", &_args308, &_result310)
  p.SetLastResponseMeta_(_meta309)
  if _err != nil {
    return
  }
  switch {
  case _result310.UserException!= nil:
    return _r, _result310.UserException
  case _result310.NotFoundException!= nil:
    return _r, _result310.NotFoundException
  case _result310.SystemException!= nil:
    return _r, _result310.SystemException
  }

  return _result310.GetSuccess(), nil
}

// Returns a list of linked notebooks
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) ListLinkedNotebooks(ctx context.Context, authenticationToken string) (_r []*LinkedNotebook, _err error) {
  var _args311 NoteStoreListLinkedNotebooksArgs
  _args311.AuthenticationToken = authenticationToken
  var _result313 NoteStoreListLinkedNotebooksResult
  var _meta312 thrift.ResponseMeta
  _meta312, _err = p.Client_().Call(ctx, "listLinkedNotebooks", &_args311, &_result313)
  p.SetLastResponseMeta_(_meta312)
  if _err != nil {
    return
  }
  switch {
  case _result313.UserException!= nil:
    return _r, _result313.UserException
  case _result313.NotFoundException!= nil:
    return _r, _result313.NotFoundException
  case _result313.SystemException!= nil:
    return _r, _result313.SystemException
  }

  return _result313.GetSuccess(), nil
}

// Permanently expunges the linked notebook from the account.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
// 
// @param guid
//   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
//   from the account.
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) ExpungeLinkedNotebook(ctx context.Context, authenticationToken string, guid GUID) (_r int32, _err error) {
  var _args314 NoteStoreExpungeLinkedNotebookArgs
  _args314.AuthenticationToken = authenticationToken
  _args314.GUID = guid
  var _result316 NoteStoreExpungeLinkedNotebookResult
  var _meta315 thrift.ResponseMeta
  _meta315, _err = p.Client_().Call(ctx, "expungeLinkedNotebook", &_args314, &_result316)
  p.SetLastResponseMeta_(_meta315)
  if _err != nil {
    return
  }
  switch {
  case _result316.UserException!= nil:
    return _r, _result316.UserException
  case _result316.NotFoundException!= nil:
    return _r, _result316.NotFoundException
  case _result316.SystemException!= nil:
    return _r, _result316.SystemException
  }

  return _result316.GetSuccess(), nil
}

// Asks the service to produce an authentication token that can be used to
// access the contents of a shared notebook from someone else's account.
// This authenticationToken can be used with the various other NoteStore
// calls to find and retrieve notes, and if the permissions in the shared
// notebook are sufficient, to make changes to the contents of the notebook.
// 
// @param shareKeyOrGlobalId
//   May be one of the following:
//   <ul>
//     <li>A share key for a shared notebook that was granted to some recipient
//         Must be used if you are joining a notebook unless it was shared via
//         createOrUpdateNotebookShares. Share keys are delivered out-of-band
//         and are generally not available to clients. For security reasons,
//         share keys may be invalidated at the discretion of the service.
//     </li>
//     <li>The shared notebook global identifier. May be used to access a
//         notebook that is already joined.
//     </li>
//     <li>The Notebook GUID. May be used to access a notebook that was already
//         joined, or to access a notebook that was shared with the recipient
//         via createOrUpdateNotebookShares.
//     </li>
//   </ul>
// 
// @param authenticationToken
//   If a non-empty string is provided, this is the full user-based
//   authentication token that identifies the user who is currently logged in
//   and trying to access the shared notebook.
//   If this string is empty, the service will attempt to authenticate to the
//   shared notebook without any logged in user.
// 
// @throws EDAMSystemException <ul>
//   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
//   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
// </ul>
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
//          no valid authentication token was provided.
//   </li>
//   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
//          and another username has already been bound to this notebook.
//   </li>
// </ul>
// 
// Parameters:
//  - ShareKeyOrGlobalId
//  - AuthenticationToken
func (p *NoteStoreClient) AuthenticateToSharedNotebook(ctx context.Context, shareKeyOrGlobalId string, authenticationToken string) (_r *AuthenticationResult_, _err error) {
  var _args317 NoteStoreAuthenticateToSharedNotebookArgs
  _args317.ShareKeyOrGlobalId = shareKeyOrGlobalId
  _args317.AuthenticationToken = authenticationToken
  var _result319 NoteStoreAuthenticateToSharedNotebookResult
  var _meta318 thrift.ResponseMeta
  _meta318, _err = p.Client_().Call(ctx, "authenticateToSharedNotebook", &_args317, &_result319)
  p.SetLastResponseMeta_(_meta318)
  if _err != nil {
    return
  }
  switch {
  case _result319.UserException!= nil:
    return _r, _result319.UserException
  case _result319.NotFoundException!= nil:
    return _r, _result319.NotFoundException
  case _result319.SystemException!= nil:
    return _r, _result319.SystemException
  }

  if _ret320 := _result319.GetSuccess(); _ret320 != nil {
    return _ret320, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "authenticateToSharedNotebook failed: unknown result")
}

// This function is used to retrieve extended information about a shared
// notebook by a guest who has already authenticated to access that notebook.
// This requires an 'authenticationToken' parameter which should be the
// resut of a call to authenticateToSharedNotebook(...).
// I.e. this is the token that gives access to the particular shared notebook
// in someone else's account -- it's not the authenticationToken for the
// owner of the notebook itself.
// 
// @param authenticationToken
//   Should be the authentication token retrieved from the reply of
//   authenticateToSharedNotebook(), proving access to a particular shared
//   notebook.
// 
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" -
//          authentication token doesn't correspond to a valid shared notebook
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "SharedNotebook.id" - the shared notebook no longer exists
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
func (p *NoteStoreClient) GetSharedNotebookByAuth(ctx context.Context, authenticationToken string) (_r *SharedNotebook, _err error) {
  var _args321 NoteStoreGetSharedNotebookByAuthArgs
  _args321.AuthenticationToken = authenticationToken
  var _result323 NoteStoreGetSharedNotebookByAuthResult
  var _meta322 thrift.ResponseMeta
  _meta322, _err = p.Client_().Call(ctx, "getSharedNotebookByAuth", &_args321, &_result323)
  p.SetLastResponseMeta_(_meta322)
  if _err != nil {
    return
  }
  switch {
  case _result323.UserException!= nil:
    return _r, _result323.UserException
  case _result323.NotFoundException!= nil:
    return _r, _result323.NotFoundException
  case _result323.SystemException!= nil:
    return _r, _result323.SystemException
  }

  if _ret324 := _result323.GetSuccess(); _ret324 != nil {
    return _ret324, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getSharedNotebookByAuth failed: unknown result")
}

// Attempts to send a single note to one or more email recipients.
// <p/>
// NOTE: This function is generally not available to third party applications.
// Calls will result in an EDAMUserException with the error code
// PERMISSION_DENIED.
// 
// @param authenticationToken
//    The note will be sent as the user logged in via this token, using that
//    user's registered email address.  If the authenticated user doesn't
//    have permission to read that note, the emailing will fail.
// 
// @param parameters
//    The note must be specified either by GUID (in which case it will be
//    sent using the existing data in the service), or else the full Note
//    must be passed to this call.  This also specifies the additional
//    email fields that will be used in the email.
// 
// @throws EDAMUserException <ul>
//   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
//     The email can't be sent because this would exceed the user's daily
//     email limit.
//   </li>
//   <li> BAD_DATA_FORMAT "(email address)" -
//     email address malformed
//   </li>
//   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
//     if there are no To: or Cc: addresses provided.
//   </li>
//   <li> DATA_REQUIRED "Note.title" -
//     if the caller provides a Note parameter with no title
//   </li>
//   <li> DATA_REQUIRED "Note.content" -
//     if the caller provides a Note parameter with no content
//   </li>
//   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
//   </li>
//   <li> DATA_REQUIRED "NoteEmailParameters.note" -
//     if no guid or note provided
//   </li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Parameters
func (p *NoteStoreClient) EmailNote(ctx context.Context, authenticationToken string, parameters *NoteEmailParameters) (_err error) {
  var _args325 NoteStoreEmailNoteArgs
  _args325.AuthenticationToken = authenticationToken
  _args325.Parameters = parameters
  var _result327 NoteStoreEmailNoteResult
  var _meta326 thrift.ResponseMeta
  _meta326, _err = p.Client_().Call(ctx, "emailNote", &_args325, &_result327)
  p.SetLastResponseMeta_(_meta326)
  if _err != nil {
    return
  }
  switch {
  case _result327.UserException!= nil:
    return _result327.UserException
  case _result327.NotFoundException!= nil:
    return _result327.NotFoundException
  case _result327.SystemException!= nil:
    return _result327.SystemException
  }

  return nil
}

// If this note is not already shared publicly (via its own direct URL), then this
// will start sharing that note.
// This will return the secret "Note Key" for this note that
// can currently be used in conjunction with the Note's GUID to gain direct
// read-only access to the Note.
// If the note is already shared, then this won't make any changes to the
// note, and the existing "Note Key" will be returned.  The only way to change
// the Note Key for an existing note is to stopSharingNote first, and then
// call this function.
// 
// @param guid
//   The GUID of the note to be shared.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "Note.guid" - not found, by GUID</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) ShareNote(ctx context.Context, authenticationToken string, guid GUID) (_r string, _err error) {
  var _args328 NoteStoreShareNoteArgs
  _args328.AuthenticationToken = authenticationToken
  _args328.GUID = guid
  var _result330 NoteStoreShareNoteResult
  var _meta329 thrift.ResponseMeta
  _meta329, _err = p.Client_().Call(ctx, "shareNote", &_args328, &_result330)
  p.SetLastResponseMeta_(_meta329)
  if _err != nil {
    return
  }
  switch {
  case _result330.UserException!= nil:
    return _r, _result330.UserException
  case _result330.NotFoundException!= nil:
    return _r, _result330.NotFoundException
  case _result330.SystemException!= nil:
    return _r, _result330.SystemException
  }

  return _result330.GetSuccess(), nil
}

// If this note is shared publicly then this will stop sharing that note
// and invalidate its "Note Key", so any existing URLs to access that Note
// will stop working.
// 
// If the Note is not shared, then this function will do nothing.
// 
// This function does not remove invididual shares for the note. To remove
// individual shares, see stopSharingNoteWithRecipients.
// 
// @param guid
//   The GUID of the note to be un-shared.
// 
// @throws EDAMUserException <ul>
//   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
//   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li>"Note.guid" - not found, by GUID</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - GUID
func (p *NoteStoreClient) StopSharingNote(ctx context.Context, authenticationToken string, guid GUID) (_err error) {
  var _args331 NoteStoreStopSharingNoteArgs
  _args331.AuthenticationToken = authenticationToken
  _args331.GUID = guid
  var _result333 NoteStoreStopSharingNoteResult
  var _meta332 thrift.ResponseMeta
  _meta332, _err = p.Client_().Call(ctx, "stopSharingNote", &_args331, &_result333)
  p.SetLastResponseMeta_(_meta332)
  if _err != nil {
    return
  }
  switch {
  case _result333.UserException!= nil:
    return _result333.UserException
  case _result333.NotFoundException!= nil:
    return _result333.NotFoundException
  case _result333.SystemException!= nil:
    return _result333.SystemException
  }

  return nil
}

// Asks the service to produce an authentication token that can be used to
// access the contents of a single Note which was individually shared
// from someone's account.
// This authenticationToken can be used with the various other NoteStore
// calls to find and retrieve the Note and its directly-referenced children.
// 
// @param guid
//   The GUID identifying this Note on this shard.
// 
// @param noteKey
//   The 'noteKey' identifier from the Note that was originally created via
//   a call to shareNote() and then given to a recipient to access.
// 
// @param authenticationToken
//   An optional authenticationToken that identifies the user accessing the
//   shared note. This parameter may be required to access some shared notes.
// 
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
//     shared, or the noteKey doesn't match the current key for this note
//   </li>
//   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
//     required to access this Note, but either no authentication token or a
//     "non-owner" authentication token was provided.
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li> "guid" - the note with that GUID is not found
//   </li>
// </ul>
// 
// @throws EDAMSystemException <ul>
//   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
//     all requesters).
//   </li>
//   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
//     for the requester because of an IP-based country lookup.
//   </ul>
// </ul>
// 
// Parameters:
//  - GUID
//  - NoteKey
//  - AuthenticationToken
func (p *NoteStoreClient) AuthenticateToSharedNote(ctx context.Context, guid string, noteKey string, authenticationToken string) (_r *AuthenticationResult_, _err error) {
  var _args334 NoteStoreAuthenticateToSharedNoteArgs
  _args334.GUID = guid
  _args334.NoteKey = noteKey
  _args334.AuthenticationToken = authenticationToken
  var _result336 NoteStoreAuthenticateToSharedNoteResult
  var _meta335 thrift.ResponseMeta
  _meta335, _err = p.Client_().Call(ctx, "authenticateToSharedNote", &_args334, &_result336)
  p.SetLastResponseMeta_(_meta335)
  if _err != nil {
    return
  }
  switch {
  case _result336.UserException!= nil:
    return _r, _result336.UserException
  case _result336.NotFoundException!= nil:
    return _r, _result336.NotFoundException
  case _result336.SystemException!= nil:
    return _r, _result336.SystemException
  }

  if _ret337 := _result336.GetSuccess(); _ret337 != nil {
    return _ret337, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "authenticateToSharedNote failed: unknown result")
}

// Identify related entities on the service, such as notes,
// notebooks, tags and users in a business related to notes or content.
// 
// @param query
//   The information about which we are finding related entities.
// 
// @param resultSpec
//   Allows the client to indicate the type and quantity of
//   information to be returned, allowing a saving of time and
//   bandwidth.
// 
// @return
//   The result of the query, with information considered
//   to likely be relevantly related to the information
//   described by the query.
// 
// @throws EDAMUserException <ul>
//   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
//     a zero-length plain text value.
//   </li>
//   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
//     invalid Note GUID, that is, one that does not match the constraints
//     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
//   </li>
//   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
//   </li>
//   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
//     the note identified by RelatedQuery.noteGuid.
//   </li>
//   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
//     findExperts in the context of a non business user (i.e. The authenticationToken
//     is not a business auth token).
//   </li>
//   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
//     in the result spec.
//   </li>
// </ul>
// 
// @throws EDAMNotFoundException <ul>
//   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
//     found, if that field has been set in the query.
//   </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Query
//  - ResultSpec
func (p *NoteStoreClient) FindRelated(ctx context.Context, authenticationToken string, query *RelatedQuery, resultSpec *RelatedResultSpec) (_r *RelatedResult_, _err error) {
  var _args338 NoteStoreFindRelatedArgs
  _args338.AuthenticationToken = authenticationToken
  _args338.Query = query
  _args338.ResultSpec = resultSpec
  var _result340 NoteStoreFindRelatedResult
  var _meta339 thrift.ResponseMeta
  _meta339, _err = p.Client_().Call(ctx, "findRelated", &_args338, &_result340)
  p.SetLastResponseMeta_(_meta339)
  if _err != nil {
    return
  }
  switch {
  case _result340.UserException!= nil:
    return _r, _result340.UserException
  case _result340.SystemException!= nil:
    return _r, _result340.SystemException
  case _result340.NotFoundException!= nil:
    return _r, _result340.NotFoundException
  }

  if _ret341 := _result340.GetSuccess(); _ret341 != nil {
    return _ret341, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "findRelated failed: unknown result")
}

// Perform the same operation as updateNote() would provided that the update
// sequence number on the parameter Note object matches the current update sequence
// number that the service has for the note.  If they do <i>not</i> match, then
// <i>no</i> update is performed and the return value will have the current server
// state in the note field and updated will be false.  If the update sequence
// numbers between the client and server do match, then the note will be updated
// and the note field of the return value will be returned as it would be for the
// updateNote method.  This method allows you to check for an update to the note
// on the service, by another client instance, from when you obtained the
// note state as a baseline for your edits and the time when you wish to save your
// edits.  If your client can merge the conflict, you can avoid overwriting changes
// that were saved to the service by the other client.
// 
// See the updateNote method for information on the exceptions and parameters for
// this method.  The only difference is that you must have an update sequence number
// defined on the note parameter (equal to the USN of the note as synched to the
// client), and the following additional exceptions might be thrown.
// 
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
//       not provided.  This includes a value that is set as 0.</li>
//   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
//       sequence number that is larger than the current server value, which should
//       not happen if your client is working correctly.</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Note
func (p *NoteStoreClient) UpdateNoteIfUsnMatches(ctx context.Context, authenticationToken string, note *Note) (_r *UpdateNoteIfUsnMatchesResult_, _err error) {
  var _args342 NoteStoreUpdateNoteIfUsnMatchesArgs
  _args342.AuthenticationToken = authenticationToken
  _args342.Note = note
  var _result344 NoteStoreUpdateNoteIfUsnMatchesResult
  var _meta343 thrift.ResponseMeta
  _meta343, _err = p.Client_().Call(ctx, "updateNoteIfUsnMatches", &_args342, &_result344)
  p.SetLastResponseMeta_(_meta343)
  if _err != nil {
    return
  }
  switch {
  case _result344.UserException!= nil:
    return _r, _result344.UserException
  case _result344.NotFoundException!= nil:
    return _r, _result344.NotFoundException
  case _result344.SystemException!= nil:
    return _r, _result344.SystemException
  }

  if _ret345 := _result344.GetSuccess(); _ret345 != nil {
    return _ret345, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "updateNoteIfUsnMatches failed: unknown result")
}

// Manage invitations and memberships associated with a given notebook.
// 
// <i>Note:</i> Beta method! This method is currently intended for
// limited use by Evernote clients that have discussed using this
// routine with the platform team.
// 
// @param parameters A structure containing all parameters for the updates.
//    See the structure documentation for details.
// 
// @throws EDAMUserException <ul>
//   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
//    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
//    shares.</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - Parameters
func (p *NoteStoreClient) ManageNotebookShares(ctx context.Context, authenticationToken string, parameters *ManageNotebookSharesParameters) (_r *ManageNotebookSharesResult_, _err error) {
  var _args346 NoteStoreManageNotebookSharesArgs
  _args346.AuthenticationToken = authenticationToken
  _args346.Parameters = parameters
  var _result348 NoteStoreManageNotebookSharesResult
  var _meta347 thrift.ResponseMeta
  _meta347, _err = p.Client_().Call(ctx, "manageNotebookShares", &_args346, &_result348)
  p.SetLastResponseMeta_(_meta347)
  if _err != nil {
    return
  }
  switch {
  case _result348.UserException!= nil:
    return _r, _result348.UserException
  case _result348.NotFoundException!= nil:
    return _r, _result348.NotFoundException
  case _result348.SystemException!= nil:
    return _r, _result348.SystemException
  }

  if _ret349 := _result348.GetSuccess(); _ret349 != nil {
    return _ret349, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "manageNotebookShares failed: unknown result")
}

// Return the share relationships for the given notebook, including
// both the invitations and the memberships.
// 
// <i>Note:</i> Beta method! This method is currently intended for
// limited use by Evernote clients that have discussed using this
// routine with the platform team.
// 
// Parameters:
//  - AuthenticationToken
//  - NotebookGuid
func (p *NoteStoreClient) GetNotebookShares(ctx context.Context, authenticationToken string, notebookGuid string) (_r *ShareRelationships, _err error) {
  var _args350 NoteStoreGetNotebookSharesArgs
  _args350.AuthenticationToken = authenticationToken
  _args350.NotebookGuid = notebookGuid
  var _result352 NoteStoreGetNotebookSharesResult
  var _meta351 thrift.ResponseMeta
  _meta351, _err = p.Client_().Call(ctx, "getNotebookShares", &_args350, &_result352)
  p.SetLastResponseMeta_(_meta351)
  if _err != nil {
    return
  }
  switch {
  case _result352.UserException!= nil:
    return _r, _result352.UserException
  case _result352.NotFoundException!= nil:
    return _r, _result352.NotFoundException
  case _result352.SystemException!= nil:
    return _r, _result352.SystemException
  }

  if _ret353 := _result352.GetSuccess(); _ret353 != nil {
    return _ret353, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getNotebookShares failed: unknown result")
}

type NoteStoreProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler NoteStore
}

func (p *NoteStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *NoteStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *NoteStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewNoteStoreProcessor(handler NoteStore) *NoteStoreProcessor {

  self354 := &NoteStoreProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self354.processorMap["getSyncState"] = &noteStoreProcessorGetSyncState{handler:handler}
  self354.processorMap["getFilteredSyncChunk"] = &noteStoreProcessorGetFilteredSyncChunk{handler:handler}
  self354.processorMap["getLinkedNotebookSyncState"] = &noteStoreProcessorGetLinkedNotebookSyncState{handler:handler}
  self354.processorMap["getLinkedNotebookSyncChunk"] = &noteStoreProcessorGetLinkedNotebookSyncChunk{handler:handler}
  self354.processorMap["listNotebooks"] = &noteStoreProcessorListNotebooks{handler:handler}
  self354.processorMap["listAccessibleBusinessNotebooks"] = &noteStoreProcessorListAccessibleBusinessNotebooks{handler:handler}
  self354.processorMap["getNotebook"] = &noteStoreProcessorGetNotebook{handler:handler}
  self354.processorMap["getDefaultNotebook"] = &noteStoreProcessorGetDefaultNotebook{handler:handler}
  self354.processorMap["createNotebook"] = &noteStoreProcessorCreateNotebook{handler:handler}
  self354.processorMap["updateNotebook"] = &noteStoreProcessorUpdateNotebook{handler:handler}
  self354.processorMap["expungeNotebook"] = &noteStoreProcessorExpungeNotebook{handler:handler}
  self354.processorMap["listTags"] = &noteStoreProcessorListTags{handler:handler}
  self354.processorMap["listTagsByNotebook"] = &noteStoreProcessorListTagsByNotebook{handler:handler}
  self354.processorMap["getTag"] = &noteStoreProcessorGetTag{handler:handler}
  self354.processorMap["createTag"] = &noteStoreProcessorCreateTag{handler:handler}
  self354.processorMap["updateTag"] = &noteStoreProcessorUpdateTag{handler:handler}
  self354.processorMap["untagAll"] = &noteStoreProcessorUntagAll{handler:handler}
  self354.processorMap["expungeTag"] = &noteStoreProcessorExpungeTag{handler:handler}
  self354.processorMap["listSearches"] = &noteStoreProcessorListSearches{handler:handler}
  self354.processorMap["getSearch"] = &noteStoreProcessorGetSearch{handler:handler}
  self354.processorMap["createSearch"] = &noteStoreProcessorCreateSearch{handler:handler}
  self354.processorMap["updateSearch"] = &noteStoreProcessorUpdateSearch{handler:handler}
  self354.processorMap["expungeSearch"] = &noteStoreProcessorExpungeSearch{handler:handler}
  self354.processorMap["findNoteOffset"] = &noteStoreProcessorFindNoteOffset{handler:handler}
  self354.processorMap["findNotesMetadata"] = &noteStoreProcessorFindNotesMetadata{handler:handler}
  self354.processorMap["findNoteCounts"] = &noteStoreProcessorFindNoteCounts{handler:handler}
  self354.processorMap["getNoteWithResultSpec"] = &noteStoreProcessorGetNoteWithResultSpec{handler:handler}
  self354.processorMap["getNote"] = &noteStoreProcessorGetNote{handler:handler}
  self354.processorMap["getNoteApplicationData"] = &noteStoreProcessorGetNoteApplicationData{handler:handler}
  self354.processorMap["getNoteApplicationDataEntry"] = &noteStoreProcessorGetNoteApplicationDataEntry{handler:handler}
  self354.processorMap["setNoteApplicationDataEntry"] = &noteStoreProcessorSetNoteApplicationDataEntry{handler:handler}
  self354.processorMap["unsetNoteApplicationDataEntry"] = &noteStoreProcessorUnsetNoteApplicationDataEntry{handler:handler}
  self354.processorMap["getNoteContent"] = &noteStoreProcessorGetNoteContent{handler:handler}
  self354.processorMap["getNoteSearchText"] = &noteStoreProcessorGetNoteSearchText{handler:handler}
  self354.processorMap["getResourceSearchText"] = &noteStoreProcessorGetResourceSearchText{handler:handler}
  self354.processorMap["getNoteTagNames"] = &noteStoreProcessorGetNoteTagNames{handler:handler}
  self354.processorMap["createNote"] = &noteStoreProcessorCreateNote{handler:handler}
  self354.processorMap["updateNote"] = &noteStoreProcessorUpdateNote{handler:handler}
  self354.processorMap["deleteNote"] = &noteStoreProcessorDeleteNote{handler:handler}
  self354.processorMap["expungeNote"] = &noteStoreProcessorExpungeNote{handler:handler}
  self354.processorMap["copyNote"] = &noteStoreProcessorCopyNote{handler:handler}
  self354.processorMap["listNoteVersions"] = &noteStoreProcessorListNoteVersions{handler:handler}
  self354.processorMap["getNoteVersion"] = &noteStoreProcessorGetNoteVersion{handler:handler}
  self354.processorMap["getResource"] = &noteStoreProcessorGetResource{handler:handler}
  self354.processorMap["getResourceApplicationData"] = &noteStoreProcessorGetResourceApplicationData{handler:handler}
  self354.processorMap["getResourceApplicationDataEntry"] = &noteStoreProcessorGetResourceApplicationDataEntry{handler:handler}
  self354.processorMap["setResourceApplicationDataEntry"] = &noteStoreProcessorSetResourceApplicationDataEntry{handler:handler}
  self354.processorMap["unsetResourceApplicationDataEntry"] = &noteStoreProcessorUnsetResourceApplicationDataEntry{handler:handler}
  self354.processorMap["updateResource"] = &noteStoreProcessorUpdateResource{handler:handler}
  self354.processorMap["getResourceData"] = &noteStoreProcessorGetResourceData{handler:handler}
  self354.processorMap["getResourceByHash"] = &noteStoreProcessorGetResourceByHash{handler:handler}
  self354.processorMap["getResourceRecognition"] = &noteStoreProcessorGetResourceRecognition{handler:handler}
  self354.processorMap["getResourceAlternateData"] = &noteStoreProcessorGetResourceAlternateData{handler:handler}
  self354.processorMap["getResourceAttributes"] = &noteStoreProcessorGetResourceAttributes{handler:handler}
  self354.processorMap["getPublicNotebook"] = &noteStoreProcessorGetPublicNotebook{handler:handler}
  self354.processorMap["shareNotebook"] = &noteStoreProcessorShareNotebook{handler:handler}
  self354.processorMap["createOrUpdateNotebookShares"] = &noteStoreProcessorCreateOrUpdateNotebookShares{handler:handler}
  self354.processorMap["updateSharedNotebook"] = &noteStoreProcessorUpdateSharedNotebook{handler:handler}
  self354.processorMap["setNotebookRecipientSettings"] = &noteStoreProcessorSetNotebookRecipientSettings{handler:handler}
  self354.processorMap["listSharedNotebooks"] = &noteStoreProcessorListSharedNotebooks{handler:handler}
  self354.processorMap["createLinkedNotebook"] = &noteStoreProcessorCreateLinkedNotebook{handler:handler}
  self354.processorMap["updateLinkedNotebook"] = &noteStoreProcessorUpdateLinkedNotebook{handler:handler}
  self354.processorMap["listLinkedNotebooks"] = &noteStoreProcessorListLinkedNotebooks{handler:handler}
  self354.processorMap["expungeLinkedNotebook"] = &noteStoreProcessorExpungeLinkedNotebook{handler:handler}
  self354.processorMap["authenticateToSharedNotebook"] = &noteStoreProcessorAuthenticateToSharedNotebook{handler:handler}
  self354.processorMap["getSharedNotebookByAuth"] = &noteStoreProcessorGetSharedNotebookByAuth{handler:handler}
  self354.processorMap["emailNote"] = &noteStoreProcessorEmailNote{handler:handler}
  self354.processorMap["shareNote"] = &noteStoreProcessorShareNote{handler:handler}
  self354.processorMap["stopSharingNote"] = &noteStoreProcessorStopSharingNote{handler:handler}
  self354.processorMap["authenticateToSharedNote"] = &noteStoreProcessorAuthenticateToSharedNote{handler:handler}
  self354.processorMap["findRelated"] = &noteStoreProcessorFindRelated{handler:handler}
  self354.processorMap["updateNoteIfUsnMatches"] = &noteStoreProcessorUpdateNoteIfUsnMatches{handler:handler}
  self354.processorMap["manageNotebookShares"] = &noteStoreProcessorManageNotebookShares{handler:handler}
  self354.processorMap["getNotebookShares"] = &noteStoreProcessorGetNotebookShares{handler:handler}
return self354
}

func (p *NoteStoreProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x355 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x355.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x355

}

type noteStoreProcessorGetSyncState struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetSyncState) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetSyncStateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getSyncState", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetSyncStateResult{}
  var retval *SyncState
  if retval, err2 = p.handler.GetSyncState(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSyncState: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getSyncState", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getSyncState", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetFilteredSyncChunk struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetFilteredSyncChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetFilteredSyncChunkArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetFilteredSyncChunkResult{}
  var retval *SyncChunk
  if retval, err2 = p.handler.GetFilteredSyncChunk(ctx, args.AuthenticationToken, args.AfterUSN, args.MaxEntries, args.Filter); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getFilteredSyncChunk: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getFilteredSyncChunk", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetLinkedNotebookSyncState struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetLinkedNotebookSyncState) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetLinkedNotebookSyncStateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetLinkedNotebookSyncStateResult{}
  var retval *SyncState
  if retval, err2 = p.handler.GetLinkedNotebookSyncState(ctx, args.AuthenticationToken, args.LinkedNotebook); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getLinkedNotebookSyncState: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncState", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetLinkedNotebookSyncChunk struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetLinkedNotebookSyncChunk) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetLinkedNotebookSyncChunkArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetLinkedNotebookSyncChunkResult{}
  var retval *SyncChunk
  if retval, err2 = p.handler.GetLinkedNotebookSyncChunk(ctx, args.AuthenticationToken, args.LinkedNotebook, args.AfterUSN, args.MaxEntries, args.FullSyncOnly); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getLinkedNotebookSyncChunk: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getLinkedNotebookSyncChunk", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListNotebooks struct {
  handler NoteStore
}

func (p *noteStoreProcessorListNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListNotebooksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListNotebooksResult{}
  var retval []*Notebook
  if retval, err2 = p.handler.ListNotebooks(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNotebooks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listNotebooks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListAccessibleBusinessNotebooks struct {
  handler NoteStore
}

func (p *noteStoreProcessorListAccessibleBusinessNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListAccessibleBusinessNotebooksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listAccessibleBusinessNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListAccessibleBusinessNotebooksResult{}
  var retval []*Notebook
  if retval, err2 = p.handler.ListAccessibleBusinessNotebooks(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listAccessibleBusinessNotebooks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listAccessibleBusinessNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listAccessibleBusinessNotebooks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNotebookResult{}
  var retval *Notebook
  if retval, err2 = p.handler.GetNotebook(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetDefaultNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetDefaultNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetDefaultNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetDefaultNotebookResult{}
  var retval *Notebook
  if retval, err2 = p.handler.GetDefaultNotebook(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getDefaultNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getDefaultNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCreateNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorCreateNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCreateNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCreateNotebookResult{}
  var retval *Notebook
  if retval, err2 = p.handler.CreateNotebook(ctx, args.AuthenticationToken, args.Notebook); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateNotebookResult{}
  var retval int32
  if retval, err2 = p.handler.UpdateNotebook(ctx, args.AuthenticationToken, args.Notebook); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorExpungeNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorExpungeNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreExpungeNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreExpungeNotebookResult{}
  var retval int32
  if retval, err2 = p.handler.ExpungeNotebook(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expungeNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListTags struct {
  handler NoteStore
}

func (p *noteStoreProcessorListTags) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListTagsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listTags", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListTagsResult{}
  var retval []*Tag
  if retval, err2 = p.handler.ListTags(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listTags: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listTags", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listTags", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListTagsByNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorListTagsByNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListTagsByNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListTagsByNotebookResult{}
  var retval []*Tag
  if retval, err2 = p.handler.ListTagsByNotebook(ctx, args.AuthenticationToken, args.NotebookGuid); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listTagsByNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listTagsByNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetTag struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetTagArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetTagResult{}
  var retval *Tag
  if retval, err2 = p.handler.GetTag(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTag: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getTag", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCreateTag struct {
  handler NoteStore
}

func (p *noteStoreProcessorCreateTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCreateTagArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCreateTagResult{}
  var retval *Tag
  if retval, err2 = p.handler.CreateTag(ctx, args.AuthenticationToken, args.Tag); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTag: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createTag", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateTag struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateTagArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateTagResult{}
  var retval int32
  if retval, err2 = p.handler.UpdateTag(ctx, args.AuthenticationToken, args.Tag); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateTag: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateTag", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUntagAll struct {
  handler NoteStore
}

func (p *noteStoreProcessorUntagAll) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUntagAllArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "untagAll", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUntagAllResult{}
  if err2 = p.handler.UntagAll(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing untagAll: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "untagAll", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "untagAll", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorExpungeTag struct {
  handler NoteStore
}

func (p *noteStoreProcessorExpungeTag) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreExpungeTagArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreExpungeTagResult{}
  var retval int32
  if retval, err2 = p.handler.ExpungeTag(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeTag: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeTag", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expungeTag", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListSearches struct {
  handler NoteStore
}

func (p *noteStoreProcessorListSearches) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListSearchesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listSearches", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListSearchesResult{}
  var retval []*SavedSearch
  if retval, err2 = p.handler.ListSearches(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listSearches: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listSearches", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listSearches", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetSearch struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetSearchArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetSearchResult{}
  var retval *SavedSearch
  if retval, err2 = p.handler.GetSearch(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSearch: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getSearch", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCreateSearch struct {
  handler NoteStore
}

func (p *noteStoreProcessorCreateSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCreateSearchArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCreateSearchResult{}
  var retval *SavedSearch
  if retval, err2 = p.handler.CreateSearch(ctx, args.AuthenticationToken, args.Search); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createSearch: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createSearch", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateSearch struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateSearchArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateSearchResult{}
  var retval int32
  if retval, err2 = p.handler.UpdateSearch(ctx, args.AuthenticationToken, args.Search); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateSearch: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateSearch", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorExpungeSearch struct {
  handler NoteStore
}

func (p *noteStoreProcessorExpungeSearch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreExpungeSearchArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreExpungeSearchResult{}
  var retval int32
  if retval, err2 = p.handler.ExpungeSearch(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeSearch: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expungeSearch", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorFindNoteOffset struct {
  handler NoteStore
}

func (p *noteStoreProcessorFindNoteOffset) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreFindNoteOffsetArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreFindNoteOffsetResult{}
  var retval int32
  if retval, err2 = p.handler.FindNoteOffset(ctx, args.AuthenticationToken, args.Filter, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNoteOffset: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "findNoteOffset", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorFindNotesMetadata struct {
  handler NoteStore
}

func (p *noteStoreProcessorFindNotesMetadata) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreFindNotesMetadataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreFindNotesMetadataResult{}
  var retval *NotesMetadataList
  if retval, err2 = p.handler.FindNotesMetadata(ctx, args.AuthenticationToken, args.Filter, args.Offset, args.MaxNotes, args.ResultSpec); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNotesMetadata: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "findNotesMetadata", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorFindNoteCounts struct {
  handler NoteStore
}

func (p *noteStoreProcessorFindNoteCounts) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreFindNoteCountsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreFindNoteCountsResult{}
  var retval *NoteCollectionCounts
  if retval, err2 = p.handler.FindNoteCounts(ctx, args.AuthenticationToken, args.Filter, args.WithTrash); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findNoteCounts: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "findNoteCounts", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteWithResultSpec struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteWithResultSpec) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteWithResultSpecArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteWithResultSpec", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteWithResultSpecResult{}
  var retval *Note
  if retval, err2 = p.handler.GetNoteWithResultSpec(ctx, args.AuthenticationToken, args.GUID, args.ResultSpec); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteWithResultSpec: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteWithResultSpec", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteWithResultSpec", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteResult{}
  var retval *Note
  if retval, err2 = p.handler.GetNote(ctx, args.AuthenticationToken, args.GUID, args.WithContent, args.WithResourcesData, args.WithResourcesRecognition, args.WithResourcesAlternateData); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteApplicationData struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteApplicationData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteApplicationDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteApplicationDataResult{}
  var retval *LazyMap
  if retval, err2 = p.handler.GetNoteApplicationData(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteApplicationData: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteApplicationData", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteApplicationDataEntry struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteApplicationDataEntryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteApplicationDataEntryResult{}
  var retval string
  if retval, err2 = p.handler.GetNoteApplicationDataEntry(ctx, args.AuthenticationToken, args.GUID, args.Key); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteApplicationDataEntry: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorSetNoteApplicationDataEntry struct {
  handler NoteStore
}

func (p *noteStoreProcessorSetNoteApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreSetNoteApplicationDataEntryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreSetNoteApplicationDataEntryResult{}
  var retval int32
  if retval, err2 = p.handler.SetNoteApplicationDataEntry(ctx, args.AuthenticationToken, args.GUID, args.Key, args.Value); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setNoteApplicationDataEntry: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setNoteApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUnsetNoteApplicationDataEntry struct {
  handler NoteStore
}

func (p *noteStoreProcessorUnsetNoteApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUnsetNoteApplicationDataEntryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUnsetNoteApplicationDataEntryResult{}
  var retval int32
  if retval, err2 = p.handler.UnsetNoteApplicationDataEntry(ctx, args.AuthenticationToken, args.GUID, args.Key); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unsetNoteApplicationDataEntry: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "unsetNoteApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteContent struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteContent) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteContentArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteContentResult{}
  var retval string
  if retval, err2 = p.handler.GetNoteContent(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteContent: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteContent", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteSearchText struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteSearchText) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteSearchTextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteSearchTextResult{}
  var retval string
  if retval, err2 = p.handler.GetNoteSearchText(ctx, args.AuthenticationToken, args.GUID, args.NoteOnly, args.TokenizeForIndexing); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteSearchText: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteSearchText", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceSearchText struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceSearchText) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceSearchTextArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceSearchTextResult{}
  var retval string
  if retval, err2 = p.handler.GetResourceSearchText(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceSearchText: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceSearchText", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteTagNames struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteTagNames) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteTagNamesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteTagNamesResult{}
  var retval []string
  if retval, err2 = p.handler.GetNoteTagNames(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteTagNames: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteTagNames", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCreateNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorCreateNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCreateNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCreateNoteResult{}
  var retval *Note
  if retval, err2 = p.handler.CreateNote(ctx, args.AuthenticationToken, args.Note); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateNoteResult{}
  var retval *Note
  if retval, err2 = p.handler.UpdateNote(ctx, args.AuthenticationToken, args.Note); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorDeleteNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorDeleteNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreDeleteNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreDeleteNoteResult{}
  var retval int32
  if retval, err2 = p.handler.DeleteNote(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "deleteNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorExpungeNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorExpungeNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreExpungeNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreExpungeNoteResult{}
  var retval int32
  if retval, err2 = p.handler.ExpungeNote(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expungeNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCopyNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorCopyNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCopyNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "copyNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCopyNoteResult{}
  var retval *Note
  if retval, err2 = p.handler.CopyNote(ctx, args.AuthenticationToken, args.NoteGuid, args.ToNotebookGuid); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing copyNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "copyNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "copyNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListNoteVersions struct {
  handler NoteStore
}

func (p *noteStoreProcessorListNoteVersions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListNoteVersionsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListNoteVersionsResult{}
  var retval []*NoteVersionId
  if retval, err2 = p.handler.ListNoteVersions(ctx, args.AuthenticationToken, args.NoteGuid); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNoteVersions: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listNoteVersions", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNoteVersion struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNoteVersion) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNoteVersionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNoteVersionResult{}
  var retval *Note
  if retval, err2 = p.handler.GetNoteVersion(ctx, args.AuthenticationToken, args.NoteGuid, args.UpdateSequenceNum, args.WithResourcesData, args.WithResourcesRecognition, args.WithResourcesAlternateData); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteVersion: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNoteVersion", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResource struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResource) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResource", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceResult{}
  var retval *Resource
  if retval, err2 = p.handler.GetResource(ctx, args.AuthenticationToken, args.GUID, args.WithData, args.WithRecognition, args.WithAttributes, args.WithAlternateData); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResource: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResource", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResource", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceApplicationData struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceApplicationData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceApplicationDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceApplicationDataResult{}
  var retval *LazyMap
  if retval, err2 = p.handler.GetResourceApplicationData(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceApplicationData: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceApplicationData", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceApplicationDataEntry struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceApplicationDataEntryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceApplicationDataEntryResult{}
  var retval string
  if retval, err2 = p.handler.GetResourceApplicationDataEntry(ctx, args.AuthenticationToken, args.GUID, args.Key); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceApplicationDataEntry: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorSetResourceApplicationDataEntry struct {
  handler NoteStore
}

func (p *noteStoreProcessorSetResourceApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreSetResourceApplicationDataEntryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreSetResourceApplicationDataEntryResult{}
  var retval int32
  if retval, err2 = p.handler.SetResourceApplicationDataEntry(ctx, args.AuthenticationToken, args.GUID, args.Key, args.Value); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setResourceApplicationDataEntry: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setResourceApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUnsetResourceApplicationDataEntry struct {
  handler NoteStore
}

func (p *noteStoreProcessorUnsetResourceApplicationDataEntry) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUnsetResourceApplicationDataEntryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUnsetResourceApplicationDataEntryResult{}
  var retval int32
  if retval, err2 = p.handler.UnsetResourceApplicationDataEntry(ctx, args.AuthenticationToken, args.GUID, args.Key); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unsetResourceApplicationDataEntry: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "unsetResourceApplicationDataEntry", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateResource struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateResource) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateResourceArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateResource", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateResourceResult{}
  var retval int32
  if retval, err2 = p.handler.UpdateResource(ctx, args.AuthenticationToken, args.Resource); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateResource: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateResource", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateResource", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceData struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceDataResult{}
  var retval []byte
  if retval, err2 = p.handler.GetResourceData(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceData: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceData", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceByHash struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceByHash) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceByHashArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceByHashResult{}
  var retval *Resource
  if retval, err2 = p.handler.GetResourceByHash(ctx, args.AuthenticationToken, args.NoteGuid, args.ContentHash, args.WithData, args.WithRecognition, args.WithAlternateData); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceByHash: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceByHash", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceRecognition struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceRecognition) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceRecognitionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceRecognitionResult{}
  var retval []byte
  if retval, err2 = p.handler.GetResourceRecognition(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceRecognition: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceRecognition", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceAlternateData struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceAlternateData) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceAlternateDataArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceAlternateDataResult{}
  var retval []byte
  if retval, err2 = p.handler.GetResourceAlternateData(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceAlternateData: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceAlternateData", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetResourceAttributes struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetResourceAttributes) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetResourceAttributesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetResourceAttributesResult{}
  var retval *ResourceAttributes
  if retval, err2 = p.handler.GetResourceAttributes(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getResourceAttributes: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getResourceAttributes", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetPublicNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetPublicNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetPublicNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetPublicNotebookResult{}
  var retval *Notebook
  if retval, err2 = p.handler.GetPublicNotebook(ctx, args.UserId, args.PublicUri); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPublicNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorShareNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorShareNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreShareNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "shareNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreShareNotebookResult{}
  var retval *SharedNotebook
  if retval, err2 = p.handler.ShareNotebook(ctx, args.AuthenticationToken, args.SharedNotebook, args.Message); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shareNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "shareNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "shareNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCreateOrUpdateNotebookShares struct {
  handler NoteStore
}

func (p *noteStoreProcessorCreateOrUpdateNotebookShares) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCreateOrUpdateNotebookSharesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createOrUpdateNotebookShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCreateOrUpdateNotebookSharesResult{}
  var retval *CreateOrUpdateNotebookSharesResult_
  if retval, err2 = p.handler.CreateOrUpdateNotebookShares(ctx, args.AuthenticationToken, args.ShareTemplate); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMInvalidContactsException:
  result.InvalidContactsException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createOrUpdateNotebookShares: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createOrUpdateNotebookShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createOrUpdateNotebookShares", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateSharedNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateSharedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateSharedNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateSharedNotebookResult{}
  var retval int32
  if retval, err2 = p.handler.UpdateSharedNotebook(ctx, args.AuthenticationToken, args.SharedNotebook); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateSharedNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateSharedNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorSetNotebookRecipientSettings struct {
  handler NoteStore
}

func (p *noteStoreProcessorSetNotebookRecipientSettings) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreSetNotebookRecipientSettingsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setNotebookRecipientSettings", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreSetNotebookRecipientSettingsResult{}
  var retval *Notebook
  if retval, err2 = p.handler.SetNotebookRecipientSettings(ctx, args.AuthenticationToken, args.NotebookGuid, args.RecipientSettings); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setNotebookRecipientSettings: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setNotebookRecipientSettings", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setNotebookRecipientSettings", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListSharedNotebooks struct {
  handler NoteStore
}

func (p *noteStoreProcessorListSharedNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListSharedNotebooksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListSharedNotebooksResult{}
  var retval []*SharedNotebook
  if retval, err2 = p.handler.ListSharedNotebooks(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listSharedNotebooks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listSharedNotebooks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorCreateLinkedNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorCreateLinkedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreCreateLinkedNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreCreateLinkedNotebookResult{}
  var retval *LinkedNotebook
  if retval, err2 = p.handler.CreateLinkedNotebook(ctx, args.AuthenticationToken, args.LinkedNotebook); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createLinkedNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createLinkedNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateLinkedNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateLinkedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateLinkedNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateLinkedNotebookResult{}
  var retval int32
  if retval, err2 = p.handler.UpdateLinkedNotebook(ctx, args.AuthenticationToken, args.LinkedNotebook); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateLinkedNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateLinkedNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorListLinkedNotebooks struct {
  handler NoteStore
}

func (p *noteStoreProcessorListLinkedNotebooks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreListLinkedNotebooksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreListLinkedNotebooksResult{}
  var retval []*LinkedNotebook
  if retval, err2 = p.handler.ListLinkedNotebooks(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listLinkedNotebooks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listLinkedNotebooks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorExpungeLinkedNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorExpungeLinkedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreExpungeLinkedNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreExpungeLinkedNotebookResult{}
  var retval int32
  if retval, err2 = p.handler.ExpungeLinkedNotebook(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing expungeLinkedNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "expungeLinkedNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorAuthenticateToSharedNotebook struct {
  handler NoteStore
}

func (p *noteStoreProcessorAuthenticateToSharedNotebook) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreAuthenticateToSharedNotebookArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreAuthenticateToSharedNotebookResult{}
  var retval *AuthenticationResult_
  if retval, err2 = p.handler.AuthenticateToSharedNotebook(ctx, args.ShareKeyOrGlobalId, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToSharedNotebook: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "authenticateToSharedNotebook", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetSharedNotebookByAuth struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetSharedNotebookByAuth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetSharedNotebookByAuthArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetSharedNotebookByAuthResult{}
  var retval *SharedNotebook
  if retval, err2 = p.handler.GetSharedNotebookByAuth(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSharedNotebookByAuth: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getSharedNotebookByAuth", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorEmailNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorEmailNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreEmailNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "emailNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreEmailNoteResult{}
  if err2 = p.handler.EmailNote(ctx, args.AuthenticationToken, args.Parameters); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing emailNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "emailNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "emailNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorShareNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorShareNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreShareNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "shareNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreShareNoteResult{}
  var retval string
  if retval, err2 = p.handler.ShareNote(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shareNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "shareNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "shareNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorStopSharingNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorStopSharingNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreStopSharingNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreStopSharingNoteResult{}
  if err2 = p.handler.StopSharingNote(ctx, args.AuthenticationToken, args.GUID); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing stopSharingNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "stopSharingNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorAuthenticateToSharedNote struct {
  handler NoteStore
}

func (p *noteStoreProcessorAuthenticateToSharedNote) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreAuthenticateToSharedNoteArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreAuthenticateToSharedNoteResult{}
  var retval *AuthenticationResult_
  if retval, err2 = p.handler.AuthenticateToSharedNote(ctx, args.GUID, args.NoteKey, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToSharedNote: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "authenticateToSharedNote", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorFindRelated struct {
  handler NoteStore
}

func (p *noteStoreProcessorFindRelated) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreFindRelatedArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "findRelated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreFindRelatedResult{}
  var retval *RelatedResult_
  if retval, err2 = p.handler.FindRelated(ctx, args.AuthenticationToken, args.Query, args.ResultSpec); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing findRelated: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "findRelated", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "findRelated", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorUpdateNoteIfUsnMatches struct {
  handler NoteStore
}

func (p *noteStoreProcessorUpdateNoteIfUsnMatches) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreUpdateNoteIfUsnMatchesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateNoteIfUsnMatches", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreUpdateNoteIfUsnMatchesResult{}
  var retval *UpdateNoteIfUsnMatchesResult_
  if retval, err2 = p.handler.UpdateNoteIfUsnMatches(ctx, args.AuthenticationToken, args.Note); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateNoteIfUsnMatches: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateNoteIfUsnMatches", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateNoteIfUsnMatches", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorManageNotebookShares struct {
  handler NoteStore
}

func (p *noteStoreProcessorManageNotebookShares) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreManageNotebookSharesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "manageNotebookShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreManageNotebookSharesResult{}
  var retval *ManageNotebookSharesResult_
  if retval, err2 = p.handler.ManageNotebookShares(ctx, args.AuthenticationToken, args.Parameters); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing manageNotebookShares: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "manageNotebookShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "manageNotebookShares", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type noteStoreProcessorGetNotebookShares struct {
  handler NoteStore
}

func (p *noteStoreProcessorGetNotebookShares) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := NoteStoreGetNotebookSharesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getNotebookShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := NoteStoreGetNotebookSharesResult{}
  var retval *ShareRelationships
  if retval, err2 = p.handler.GetNotebookShares(ctx, args.AuthenticationToken, args.NotebookGuid); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNotebookShares: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getNotebookShares", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getNotebookShares", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - AuthenticationToken
type NoteStoreGetSyncStateArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreGetSyncStateArgs() *NoteStoreGetSyncStateArgs {
  return &NoteStoreGetSyncStateArgs{}
}


func (p *NoteStoreGetSyncStateArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreGetSyncStateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetSyncStateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetSyncStateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSyncState_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetSyncStateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetSyncStateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetSyncStateArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreGetSyncStateResult struct {
  Success *SyncState `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreGetSyncStateResult() *NoteStoreGetSyncStateResult {
  return &NoteStoreGetSyncStateResult{}
}

var NoteStoreGetSyncStateResult_Success_DEFAULT *SyncState
func (p *NoteStoreGetSyncStateResult) GetSuccess() *SyncState {
  if !p.IsSetSuccess() {
    return NoteStoreGetSyncStateResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetSyncStateResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetSyncStateResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetSyncStateResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetSyncStateResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetSyncStateResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetSyncStateResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreGetSyncStateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetSyncStateResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetSyncStateResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetSyncStateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetSyncStateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SyncState{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetSyncStateResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetSyncStateResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetSyncStateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSyncState_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetSyncStateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSyncStateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSyncStateResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSyncStateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetSyncStateResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - AfterUSN
//  - MaxEntries
//  - Filter
type NoteStoreGetFilteredSyncChunkArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  AfterUSN int32 `thrift:"afterUSN,2" db:"afterUSN" json:"afterUSN"`
  MaxEntries int32 `thrift:"maxEntries,3" db:"maxEntries" json:"maxEntries"`
  Filter *SyncChunkFilter `thrift:"filter,4" db:"filter" json:"filter"`
}

func NewNoteStoreGetFilteredSyncChunkArgs() *NoteStoreGetFilteredSyncChunkArgs {
  return &NoteStoreGetFilteredSyncChunkArgs{}
}


func (p *NoteStoreGetFilteredSyncChunkArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetFilteredSyncChunkArgs) GetAfterUSN() int32 {
  return p.AfterUSN
}

func (p *NoteStoreGetFilteredSyncChunkArgs) GetMaxEntries() int32 {
  return p.MaxEntries
}
var NoteStoreGetFilteredSyncChunkArgs_Filter_DEFAULT *SyncChunkFilter
func (p *NoteStoreGetFilteredSyncChunkArgs) GetFilter() *SyncChunkFilter {
  if !p.IsSetFilter() {
    return NoteStoreGetFilteredSyncChunkArgs_Filter_DEFAULT
  }
return p.Filter
}
func (p *NoteStoreGetFilteredSyncChunkArgs) IsSetFilter() bool {
  return p.Filter != nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AfterUSN = v
}
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.MaxEntries = v
}
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Filter = &SyncChunkFilter{}
  if err := p.Filter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Filter), err)
  }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getFilteredSyncChunk_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "afterUSN", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:afterUSN: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.AfterUSN)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.afterUSN (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:afterUSN: ", p), err) }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxEntries", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:maxEntries: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxEntries)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxEntries (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:maxEntries: ", p), err) }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:filter: ", p), err) }
  if err := p.Filter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Filter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:filter: ", p), err) }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetFilteredSyncChunkArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreGetFilteredSyncChunkResult struct {
  Success *SyncChunk `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreGetFilteredSyncChunkResult() *NoteStoreGetFilteredSyncChunkResult {
  return &NoteStoreGetFilteredSyncChunkResult{}
}

var NoteStoreGetFilteredSyncChunkResult_Success_DEFAULT *SyncChunk
func (p *NoteStoreGetFilteredSyncChunkResult) GetSuccess() *SyncChunk {
  if !p.IsSetSuccess() {
    return NoteStoreGetFilteredSyncChunkResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetFilteredSyncChunkResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetFilteredSyncChunkResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetFilteredSyncChunkResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetFilteredSyncChunkResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetFilteredSyncChunkResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetFilteredSyncChunkResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreGetFilteredSyncChunkResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetFilteredSyncChunkResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetFilteredSyncChunkResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetFilteredSyncChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SyncChunk{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getFilteredSyncChunk_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetFilteredSyncChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetFilteredSyncChunkResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetFilteredSyncChunkResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - LinkedNotebook
type NoteStoreGetLinkedNotebookSyncStateArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  LinkedNotebook *LinkedNotebook `thrift:"linkedNotebook,2" db:"linkedNotebook" json:"linkedNotebook"`
}

func NewNoteStoreGetLinkedNotebookSyncStateArgs() *NoteStoreGetLinkedNotebookSyncStateArgs {
  return &NoteStoreGetLinkedNotebookSyncStateArgs{}
}


func (p *NoteStoreGetLinkedNotebookSyncStateArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreGetLinkedNotebookSyncStateArgs_LinkedNotebook_DEFAULT *LinkedNotebook
func (p *NoteStoreGetLinkedNotebookSyncStateArgs) GetLinkedNotebook() *LinkedNotebook {
  if !p.IsSetLinkedNotebook() {
    return NoteStoreGetLinkedNotebookSyncStateArgs_LinkedNotebook_DEFAULT
  }
return p.LinkedNotebook
}
func (p *NoteStoreGetLinkedNotebookSyncStateArgs) IsSetLinkedNotebook() bool {
  return p.LinkedNotebook != nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.LinkedNotebook = &LinkedNotebook{}
  if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LinkedNotebook), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncState_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:linkedNotebook: ", p), err) }
  if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LinkedNotebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:linkedNotebook: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncStateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetLinkedNotebookSyncStateArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetLinkedNotebookSyncStateResult struct {
  Success *SyncState `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetLinkedNotebookSyncStateResult() *NoteStoreGetLinkedNotebookSyncStateResult {
  return &NoteStoreGetLinkedNotebookSyncStateResult{}
}

var NoteStoreGetLinkedNotebookSyncStateResult_Success_DEFAULT *SyncState
func (p *NoteStoreGetLinkedNotebookSyncStateResult) GetSuccess() *SyncState {
  if !p.IsSetSuccess() {
    return NoteStoreGetLinkedNotebookSyncStateResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetLinkedNotebookSyncStateResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetLinkedNotebookSyncStateResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetLinkedNotebookSyncStateResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetLinkedNotebookSyncStateResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetLinkedNotebookSyncStateResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetLinkedNotebookSyncStateResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetLinkedNotebookSyncStateResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetLinkedNotebookSyncStateResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetLinkedNotebookSyncStateResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetLinkedNotebookSyncStateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SyncState{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncState_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncStateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetLinkedNotebookSyncStateResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - LinkedNotebook
//  - AfterUSN
//  - MaxEntries
//  - FullSyncOnly
type NoteStoreGetLinkedNotebookSyncChunkArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  LinkedNotebook *LinkedNotebook `thrift:"linkedNotebook,2" db:"linkedNotebook" json:"linkedNotebook"`
  AfterUSN int32 `thrift:"afterUSN,3" db:"afterUSN" json:"afterUSN"`
  MaxEntries int32 `thrift:"maxEntries,4" db:"maxEntries" json:"maxEntries"`
  FullSyncOnly bool `thrift:"fullSyncOnly,5" db:"fullSyncOnly" json:"fullSyncOnly"`
}

func NewNoteStoreGetLinkedNotebookSyncChunkArgs() *NoteStoreGetLinkedNotebookSyncChunkArgs {
  return &NoteStoreGetLinkedNotebookSyncChunkArgs{}
}


func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreGetLinkedNotebookSyncChunkArgs_LinkedNotebook_DEFAULT *LinkedNotebook
func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) GetLinkedNotebook() *LinkedNotebook {
  if !p.IsSetLinkedNotebook() {
    return NoteStoreGetLinkedNotebookSyncChunkArgs_LinkedNotebook_DEFAULT
  }
return p.LinkedNotebook
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) GetAfterUSN() int32 {
  return p.AfterUSN
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) GetMaxEntries() int32 {
  return p.MaxEntries
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) GetFullSyncOnly() bool {
  return p.FullSyncOnly
}
func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) IsSetLinkedNotebook() bool {
  return p.LinkedNotebook != nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.LinkedNotebook = &LinkedNotebook{}
  if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LinkedNotebook), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.AfterUSN = v
}
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.MaxEntries = v
}
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.FullSyncOnly = v
}
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncChunk_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:linkedNotebook: ", p), err) }
  if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LinkedNotebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:linkedNotebook: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "afterUSN", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:afterUSN: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.AfterUSN)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.afterUSN (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:afterUSN: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxEntries", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:maxEntries: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxEntries)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxEntries (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:maxEntries: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "fullSyncOnly", thrift.BOOL, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:fullSyncOnly: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.FullSyncOnly)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.fullSyncOnly (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:fullSyncOnly: ", p), err) }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetLinkedNotebookSyncChunkArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetLinkedNotebookSyncChunkResult struct {
  Success *SyncChunk `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetLinkedNotebookSyncChunkResult() *NoteStoreGetLinkedNotebookSyncChunkResult {
  return &NoteStoreGetLinkedNotebookSyncChunkResult{}
}

var NoteStoreGetLinkedNotebookSyncChunkResult_Success_DEFAULT *SyncChunk
func (p *NoteStoreGetLinkedNotebookSyncChunkResult) GetSuccess() *SyncChunk {
  if !p.IsSetSuccess() {
    return NoteStoreGetLinkedNotebookSyncChunkResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetLinkedNotebookSyncChunkResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetLinkedNotebookSyncChunkResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetLinkedNotebookSyncChunkResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetLinkedNotebookSyncChunkResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetLinkedNotebookSyncChunkResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetLinkedNotebookSyncChunkResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetLinkedNotebookSyncChunkResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetLinkedNotebookSyncChunkResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetLinkedNotebookSyncChunkResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetLinkedNotebookSyncChunkResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SyncChunk{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getLinkedNotebookSyncChunk_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetLinkedNotebookSyncChunkResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetLinkedNotebookSyncChunkResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreListNotebooksArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreListNotebooksArgs() *NoteStoreListNotebooksArgs {
  return &NoteStoreListNotebooksArgs{}
}


func (p *NoteStoreListNotebooksArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreListNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListNotebooksArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNotebooks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListNotebooksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListNotebooksArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreListNotebooksResult struct {
  Success []*Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreListNotebooksResult() *NoteStoreListNotebooksResult {
  return &NoteStoreListNotebooksResult{}
}

var NoteStoreListNotebooksResult_Success_DEFAULT []*Notebook

func (p *NoteStoreListNotebooksResult) GetSuccess() []*Notebook {
  return p.Success
}
var NoteStoreListNotebooksResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListNotebooksResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListNotebooksResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListNotebooksResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListNotebooksResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListNotebooksResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreListNotebooksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListNotebooksResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListNotebooksResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListNotebooksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Notebook, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem356 := &Notebook{}
    if err := _elem356.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem356), err)
    }
    p.Success = append(p.Success, _elem356)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListNotebooksResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListNotebooksResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNotebooks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNotebooksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListNotebooksResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreListAccessibleBusinessNotebooksArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreListAccessibleBusinessNotebooksArgs() *NoteStoreListAccessibleBusinessNotebooksArgs {
  return &NoteStoreListAccessibleBusinessNotebooksArgs{}
}


func (p *NoteStoreListAccessibleBusinessNotebooksArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreListAccessibleBusinessNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listAccessibleBusinessNotebooks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListAccessibleBusinessNotebooksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListAccessibleBusinessNotebooksArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreListAccessibleBusinessNotebooksResult struct {
  Success []*Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreListAccessibleBusinessNotebooksResult() *NoteStoreListAccessibleBusinessNotebooksResult {
  return &NoteStoreListAccessibleBusinessNotebooksResult{}
}

var NoteStoreListAccessibleBusinessNotebooksResult_Success_DEFAULT []*Notebook

func (p *NoteStoreListAccessibleBusinessNotebooksResult) GetSuccess() []*Notebook {
  return p.Success
}
var NoteStoreListAccessibleBusinessNotebooksResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListAccessibleBusinessNotebooksResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListAccessibleBusinessNotebooksResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListAccessibleBusinessNotebooksResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListAccessibleBusinessNotebooksResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListAccessibleBusinessNotebooksResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreListAccessibleBusinessNotebooksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Notebook, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem357 := &Notebook{}
    if err := _elem357.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem357), err)
    }
    p.Success = append(p.Success, _elem357)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listAccessibleBusinessNotebooks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListAccessibleBusinessNotebooksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListAccessibleBusinessNotebooksResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetNotebookArgs() *NoteStoreGetNotebookArgs {
  return &NoteStoreGetNotebookArgs{}
}


func (p *NoteStoreGetNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNotebookArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNotebookResult struct {
  Success *Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNotebookResult() *NoteStoreGetNotebookResult {
  return &NoteStoreGetNotebookResult{}
}

var NoteStoreGetNotebookResult_Success_DEFAULT *Notebook
func (p *NoteStoreGetNotebookResult) GetSuccess() *Notebook {
  if !p.IsSetSuccess() {
    return NoteStoreGetNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Notebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreGetDefaultNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreGetDefaultNotebookArgs() *NoteStoreGetDefaultNotebookArgs {
  return &NoteStoreGetDefaultNotebookArgs{}
}


func (p *NoteStoreGetDefaultNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreGetDefaultNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetDefaultNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetDefaultNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getDefaultNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetDefaultNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetDefaultNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetDefaultNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreGetDefaultNotebookResult struct {
  Success *Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreGetDefaultNotebookResult() *NoteStoreGetDefaultNotebookResult {
  return &NoteStoreGetDefaultNotebookResult{}
}

var NoteStoreGetDefaultNotebookResult_Success_DEFAULT *Notebook
func (p *NoteStoreGetDefaultNotebookResult) GetSuccess() *Notebook {
  if !p.IsSetSuccess() {
    return NoteStoreGetDefaultNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetDefaultNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetDefaultNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetDefaultNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetDefaultNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetDefaultNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetDefaultNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreGetDefaultNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetDefaultNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetDefaultNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetDefaultNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetDefaultNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Notebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetDefaultNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetDefaultNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetDefaultNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getDefaultNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetDefaultNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetDefaultNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetDefaultNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetDefaultNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetDefaultNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Notebook
type NoteStoreCreateNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Notebook *Notebook `thrift:"notebook,2" db:"notebook" json:"notebook"`
}

func NewNoteStoreCreateNotebookArgs() *NoteStoreCreateNotebookArgs {
  return &NoteStoreCreateNotebookArgs{}
}


func (p *NoteStoreCreateNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreCreateNotebookArgs_Notebook_DEFAULT *Notebook
func (p *NoteStoreCreateNotebookArgs) GetNotebook() *Notebook {
  if !p.IsSetNotebook() {
    return NoteStoreCreateNotebookArgs_Notebook_DEFAULT
  }
return p.Notebook
}
func (p *NoteStoreCreateNotebookArgs) IsSetNotebook() bool {
  return p.Notebook != nil
}

func (p *NoteStoreCreateNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCreateNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Notebook = &Notebook{}
  if err := p.Notebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Notebook), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCreateNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notebook: ", p), err) }
  if err := p.Notebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Notebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notebook: ", p), err) }
  return err
}

func (p *NoteStoreCreateNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreCreateNotebookResult struct {
  Success *Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreCreateNotebookResult() *NoteStoreCreateNotebookResult {
  return &NoteStoreCreateNotebookResult{}
}

var NoteStoreCreateNotebookResult_Success_DEFAULT *Notebook
func (p *NoteStoreCreateNotebookResult) GetSuccess() *Notebook {
  if !p.IsSetSuccess() {
    return NoteStoreCreateNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCreateNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCreateNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCreateNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCreateNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCreateNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCreateNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreCreateNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreCreateNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreCreateNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreCreateNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCreateNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCreateNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCreateNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreCreateNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Notebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreCreateNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Notebook
type NoteStoreUpdateNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Notebook *Notebook `thrift:"notebook,2" db:"notebook" json:"notebook"`
}

func NewNoteStoreUpdateNotebookArgs() *NoteStoreUpdateNotebookArgs {
  return &NoteStoreUpdateNotebookArgs{}
}


func (p *NoteStoreUpdateNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateNotebookArgs_Notebook_DEFAULT *Notebook
func (p *NoteStoreUpdateNotebookArgs) GetNotebook() *Notebook {
  if !p.IsSetNotebook() {
    return NoteStoreUpdateNotebookArgs_Notebook_DEFAULT
  }
return p.Notebook
}
func (p *NoteStoreUpdateNotebookArgs) IsSetNotebook() bool {
  return p.Notebook != nil
}

func (p *NoteStoreUpdateNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Notebook = &Notebook{}
  if err := p.Notebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Notebook), err)
  }
  return nil
}

func (p *NoteStoreUpdateNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notebook: ", p), err) }
  if err := p.Notebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Notebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notebook: ", p), err) }
  return err
}

func (p *NoteStoreUpdateNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUpdateNotebookResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUpdateNotebookResult() *NoteStoreUpdateNotebookResult {
  return &NoteStoreUpdateNotebookResult{}
}

var NoteStoreUpdateNotebookResult_Success_DEFAULT int32
func (p *NoteStoreUpdateNotebookResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateNotebookResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUpdateNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUpdateNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUpdateNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUpdateNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreExpungeNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreExpungeNotebookArgs() *NoteStoreExpungeNotebookArgs {
  return &NoteStoreExpungeNotebookArgs{}
}


func (p *NoteStoreExpungeNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreExpungeNotebookArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreExpungeNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreExpungeNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreExpungeNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreExpungeNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreExpungeNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreExpungeNotebookResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreExpungeNotebookResult() *NoteStoreExpungeNotebookResult {
  return &NoteStoreExpungeNotebookResult{}
}

var NoteStoreExpungeNotebookResult_Success_DEFAULT int32
func (p *NoteStoreExpungeNotebookResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreExpungeNotebookResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreExpungeNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreExpungeNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreExpungeNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreExpungeNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreExpungeNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreExpungeNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreExpungeNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreExpungeNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreExpungeNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreExpungeNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreExpungeNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreExpungeNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreExpungeNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreExpungeNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreExpungeNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreExpungeNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreExpungeNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreExpungeNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreListTagsArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreListTagsArgs() *NoteStoreListTagsArgs {
  return &NoteStoreListTagsArgs{}
}


func (p *NoteStoreListTagsArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreListTagsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListTagsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListTagsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listTags_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListTagsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListTagsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListTagsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreListTagsResult struct {
  Success []*Tag `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreListTagsResult() *NoteStoreListTagsResult {
  return &NoteStoreListTagsResult{}
}

var NoteStoreListTagsResult_Success_DEFAULT []*Tag

func (p *NoteStoreListTagsResult) GetSuccess() []*Tag {
  return p.Success
}
var NoteStoreListTagsResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListTagsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListTagsResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListTagsResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListTagsResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListTagsResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreListTagsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListTagsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListTagsResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListTagsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListTagsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Tag, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem358 := &Tag{}
    if err := _elem358.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem358), err)
    }
    p.Success = append(p.Success, _elem358)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListTagsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListTagsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListTagsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listTags_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListTagsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListTagsResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NotebookGuid
type NoteStoreListTagsByNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NotebookGuid GUID `thrift:"notebookGuid,2" db:"notebookGuid" json:"notebookGuid"`
}

func NewNoteStoreListTagsByNotebookArgs() *NoteStoreListTagsByNotebookArgs {
  return &NoteStoreListTagsByNotebookArgs{}
}


func (p *NoteStoreListTagsByNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreListTagsByNotebookArgs) GetNotebookGuid() GUID {
  return p.NotebookGuid
}
func (p *NoteStoreListTagsByNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListTagsByNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListTagsByNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.NotebookGuid = temp
}
  return nil
}

func (p *NoteStoreListTagsByNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listTagsByNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListTagsByNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListTagsByNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notebookGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NotebookGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notebookGuid: ", p), err) }
  return err
}

func (p *NoteStoreListTagsByNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListTagsByNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreListTagsByNotebookResult struct {
  Success []*Tag `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreListTagsByNotebookResult() *NoteStoreListTagsByNotebookResult {
  return &NoteStoreListTagsByNotebookResult{}
}

var NoteStoreListTagsByNotebookResult_Success_DEFAULT []*Tag

func (p *NoteStoreListTagsByNotebookResult) GetSuccess() []*Tag {
  return p.Success
}
var NoteStoreListTagsByNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListTagsByNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListTagsByNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListTagsByNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListTagsByNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListTagsByNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreListTagsByNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreListTagsByNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreListTagsByNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreListTagsByNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListTagsByNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListTagsByNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListTagsByNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreListTagsByNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListTagsByNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Tag, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem359 := &Tag{}
    if err := _elem359.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem359), err)
    }
    p.Success = append(p.Success, _elem359)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListTagsByNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListTagsByNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListTagsByNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreListTagsByNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listTagsByNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListTagsByNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsByNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsByNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsByNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListTagsByNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListTagsByNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetTagArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetTagArgs() *NoteStoreGetTagArgs {
  return &NoteStoreGetTagArgs{}
}


func (p *NoteStoreGetTagArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetTagArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetTagArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetTagArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTag_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetTagArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetTagArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetTagResult struct {
  Success *Tag `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetTagResult() *NoteStoreGetTagResult {
  return &NoteStoreGetTagResult{}
}

var NoteStoreGetTagResult_Success_DEFAULT *Tag
func (p *NoteStoreGetTagResult) GetSuccess() *Tag {
  if !p.IsSetSuccess() {
    return NoteStoreGetTagResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetTagResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetTagResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetTagResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetTagResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetTagResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetTagResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetTagResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetTagResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetTagResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetTagResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetTagResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetTagResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetTagResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetTagResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Tag{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetTagResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetTagResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetTagResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTag_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetTagResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetTagResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Tag
type NoteStoreCreateTagArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Tag *Tag `thrift:"tag,2" db:"tag" json:"tag"`
}

func NewNoteStoreCreateTagArgs() *NoteStoreCreateTagArgs {
  return &NoteStoreCreateTagArgs{}
}


func (p *NoteStoreCreateTagArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreCreateTagArgs_Tag_DEFAULT *Tag
func (p *NoteStoreCreateTagArgs) GetTag() *Tag {
  if !p.IsSetTag() {
    return NoteStoreCreateTagArgs_Tag_DEFAULT
  }
return p.Tag
}
func (p *NoteStoreCreateTagArgs) IsSetTag() bool {
  return p.Tag != nil
}

func (p *NoteStoreCreateTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateTagArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCreateTagArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tag = &Tag{}
  if err := p.Tag.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tag), err)
  }
  return nil
}

func (p *NoteStoreCreateTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createTag_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCreateTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tag", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tag: ", p), err) }
  if err := p.Tag.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tag), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tag: ", p), err) }
  return err
}

func (p *NoteStoreCreateTagArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateTagArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreCreateTagResult struct {
  Success *Tag `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreCreateTagResult() *NoteStoreCreateTagResult {
  return &NoteStoreCreateTagResult{}
}

var NoteStoreCreateTagResult_Success_DEFAULT *Tag
func (p *NoteStoreCreateTagResult) GetSuccess() *Tag {
  if !p.IsSetSuccess() {
    return NoteStoreCreateTagResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCreateTagResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCreateTagResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCreateTagResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCreateTagResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCreateTagResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCreateTagResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreCreateTagResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreCreateTagResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreCreateTagResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreCreateTagResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCreateTagResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCreateTagResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCreateTagResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreCreateTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateTagResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Tag{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCreateTagResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCreateTagResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCreateTagResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreCreateTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createTag_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateTagResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateTagResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Tag
type NoteStoreUpdateTagArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Tag *Tag `thrift:"tag,2" db:"tag" json:"tag"`
}

func NewNoteStoreUpdateTagArgs() *NoteStoreUpdateTagArgs {
  return &NoteStoreUpdateTagArgs{}
}


func (p *NoteStoreUpdateTagArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateTagArgs_Tag_DEFAULT *Tag
func (p *NoteStoreUpdateTagArgs) GetTag() *Tag {
  if !p.IsSetTag() {
    return NoteStoreUpdateTagArgs_Tag_DEFAULT
  }
return p.Tag
}
func (p *NoteStoreUpdateTagArgs) IsSetTag() bool {
  return p.Tag != nil
}

func (p *NoteStoreUpdateTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateTagArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateTagArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tag = &Tag{}
  if err := p.Tag.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tag), err)
  }
  return nil
}

func (p *NoteStoreUpdateTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateTag_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tag", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tag: ", p), err) }
  if err := p.Tag.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tag), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tag: ", p), err) }
  return err
}

func (p *NoteStoreUpdateTagArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateTagArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUpdateTagResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUpdateTagResult() *NoteStoreUpdateTagResult {
  return &NoteStoreUpdateTagResult{}
}

var NoteStoreUpdateTagResult_Success_DEFAULT int32
func (p *NoteStoreUpdateTagResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateTagResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUpdateTagResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateTagResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateTagResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateTagResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateTagResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateTagResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUpdateTagResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateTagResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateTagResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUpdateTagResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateTagResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateTagResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateTagResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateTagResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUpdateTagResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateTagResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateTagResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateTag_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateTagResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateTagResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreUntagAllArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreUntagAllArgs() *NoteStoreUntagAllArgs {
  return &NoteStoreUntagAllArgs{}
}


func (p *NoteStoreUntagAllArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreUntagAllArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreUntagAllArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUntagAllArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUntagAllArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreUntagAllArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "untagAll_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUntagAllArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUntagAllArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreUntagAllArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUntagAllArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUntagAllResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUntagAllResult() *NoteStoreUntagAllResult {
  return &NoteStoreUntagAllResult{}
}

var NoteStoreUntagAllResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUntagAllResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUntagAllResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUntagAllResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUntagAllResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUntagAllResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUntagAllResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUntagAllResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUntagAllResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUntagAllResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUntagAllResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUntagAllResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUntagAllResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUntagAllResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUntagAllResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUntagAllResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUntagAllResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "untagAll_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUntagAllResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUntagAllResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUntagAllResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUntagAllResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUntagAllResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreExpungeTagArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreExpungeTagArgs() *NoteStoreExpungeTagArgs {
  return &NoteStoreExpungeTagArgs{}
}


func (p *NoteStoreExpungeTagArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreExpungeTagArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreExpungeTagArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeTagArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreExpungeTagArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreExpungeTagArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeTag_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeTagArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreExpungeTagArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreExpungeTagArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeTagArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreExpungeTagResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreExpungeTagResult() *NoteStoreExpungeTagResult {
  return &NoteStoreExpungeTagResult{}
}

var NoteStoreExpungeTagResult_Success_DEFAULT int32
func (p *NoteStoreExpungeTagResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreExpungeTagResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreExpungeTagResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreExpungeTagResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreExpungeTagResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreExpungeTagResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreExpungeTagResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreExpungeTagResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreExpungeTagResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreExpungeTagResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreExpungeTagResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreExpungeTagResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreExpungeTagResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreExpungeTagResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreExpungeTagResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreExpungeTagResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeTagResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreExpungeTagResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreExpungeTagResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreExpungeTagResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreExpungeTagResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeTag_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeTagResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeTagResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeTagResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeTagResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeTagResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeTagResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreListSearchesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreListSearchesArgs() *NoteStoreListSearchesArgs {
  return &NoteStoreListSearchesArgs{}
}


func (p *NoteStoreListSearchesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreListSearchesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListSearchesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListSearchesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listSearches_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListSearchesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListSearchesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListSearchesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreListSearchesResult struct {
  Success []*SavedSearch `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreListSearchesResult() *NoteStoreListSearchesResult {
  return &NoteStoreListSearchesResult{}
}

var NoteStoreListSearchesResult_Success_DEFAULT []*SavedSearch

func (p *NoteStoreListSearchesResult) GetSuccess() []*SavedSearch {
  return p.Success
}
var NoteStoreListSearchesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListSearchesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListSearchesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListSearchesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListSearchesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListSearchesResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreListSearchesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListSearchesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListSearchesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListSearchesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListSearchesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SavedSearch, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem360 := &SavedSearch{}
    if err := _elem360.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem360), err)
    }
    p.Success = append(p.Success, _elem360)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListSearchesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListSearchesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListSearchesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listSearches_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListSearchesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSearchesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSearchesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSearchesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListSearchesResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetSearchArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetSearchArgs() *NoteStoreGetSearchArgs {
  return &NoteStoreGetSearchArgs{}
}


func (p *NoteStoreGetSearchArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetSearchArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetSearchArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetSearchArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSearch_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetSearchArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetSearchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetSearchResult struct {
  Success *SavedSearch `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetSearchResult() *NoteStoreGetSearchResult {
  return &NoteStoreGetSearchResult{}
}

var NoteStoreGetSearchResult_Success_DEFAULT *SavedSearch
func (p *NoteStoreGetSearchResult) GetSuccess() *SavedSearch {
  if !p.IsSetSuccess() {
    return NoteStoreGetSearchResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetSearchResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetSearchResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetSearchResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetSearchResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetSearchResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetSearchResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetSearchResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetSearchResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetSearchResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetSearchResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetSearchResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetSearchResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetSearchResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetSearchResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SavedSearch{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetSearchResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetSearchResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetSearchResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSearch_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSearchResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSearchResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetSearchResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Search
type NoteStoreCreateSearchArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Search *SavedSearch `thrift:"search,2" db:"search" json:"search"`
}

func NewNoteStoreCreateSearchArgs() *NoteStoreCreateSearchArgs {
  return &NoteStoreCreateSearchArgs{}
}


func (p *NoteStoreCreateSearchArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreCreateSearchArgs_Search_DEFAULT *SavedSearch
func (p *NoteStoreCreateSearchArgs) GetSearch() *SavedSearch {
  if !p.IsSetSearch() {
    return NoteStoreCreateSearchArgs_Search_DEFAULT
  }
return p.Search
}
func (p *NoteStoreCreateSearchArgs) IsSetSearch() bool {
  return p.Search != nil
}

func (p *NoteStoreCreateSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateSearchArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCreateSearchArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Search = &SavedSearch{}
  if err := p.Search.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Search), err)
  }
  return nil
}

func (p *NoteStoreCreateSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createSearch_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCreateSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "search", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:search: ", p), err) }
  if err := p.Search.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Search), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:search: ", p), err) }
  return err
}

func (p *NoteStoreCreateSearchArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateSearchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type NoteStoreCreateSearchResult struct {
  Success *SavedSearch `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreCreateSearchResult() *NoteStoreCreateSearchResult {
  return &NoteStoreCreateSearchResult{}
}

var NoteStoreCreateSearchResult_Success_DEFAULT *SavedSearch
func (p *NoteStoreCreateSearchResult) GetSuccess() *SavedSearch {
  if !p.IsSetSuccess() {
    return NoteStoreCreateSearchResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCreateSearchResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCreateSearchResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCreateSearchResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCreateSearchResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCreateSearchResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCreateSearchResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreCreateSearchResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCreateSearchResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCreateSearchResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCreateSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateSearchResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SavedSearch{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCreateSearchResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCreateSearchResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCreateSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createSearch_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateSearchResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateSearchResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Search
type NoteStoreUpdateSearchArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Search *SavedSearch `thrift:"search,2" db:"search" json:"search"`
}

func NewNoteStoreUpdateSearchArgs() *NoteStoreUpdateSearchArgs {
  return &NoteStoreUpdateSearchArgs{}
}


func (p *NoteStoreUpdateSearchArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateSearchArgs_Search_DEFAULT *SavedSearch
func (p *NoteStoreUpdateSearchArgs) GetSearch() *SavedSearch {
  if !p.IsSetSearch() {
    return NoteStoreUpdateSearchArgs_Search_DEFAULT
  }
return p.Search
}
func (p *NoteStoreUpdateSearchArgs) IsSetSearch() bool {
  return p.Search != nil
}

func (p *NoteStoreUpdateSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateSearchArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateSearchArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Search = &SavedSearch{}
  if err := p.Search.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Search), err)
  }
  return nil
}

func (p *NoteStoreUpdateSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateSearch_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "search", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:search: ", p), err) }
  if err := p.Search.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Search), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:search: ", p), err) }
  return err
}

func (p *NoteStoreUpdateSearchArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateSearchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUpdateSearchResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUpdateSearchResult() *NoteStoreUpdateSearchResult {
  return &NoteStoreUpdateSearchResult{}
}

var NoteStoreUpdateSearchResult_Success_DEFAULT int32
func (p *NoteStoreUpdateSearchResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateSearchResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUpdateSearchResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateSearchResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateSearchResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateSearchResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateSearchResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateSearchResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUpdateSearchResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateSearchResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateSearchResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUpdateSearchResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateSearchResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateSearchResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateSearchResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateSearchResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUpdateSearchResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateSearchResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateSearchResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateSearch_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSearchResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSearchResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateSearchResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreExpungeSearchArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreExpungeSearchArgs() *NoteStoreExpungeSearchArgs {
  return &NoteStoreExpungeSearchArgs{}
}


func (p *NoteStoreExpungeSearchArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreExpungeSearchArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreExpungeSearchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeSearchArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreExpungeSearchArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreExpungeSearchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeSearch_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeSearchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreExpungeSearchArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreExpungeSearchArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeSearchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreExpungeSearchResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreExpungeSearchResult() *NoteStoreExpungeSearchResult {
  return &NoteStoreExpungeSearchResult{}
}

var NoteStoreExpungeSearchResult_Success_DEFAULT int32
func (p *NoteStoreExpungeSearchResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreExpungeSearchResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreExpungeSearchResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreExpungeSearchResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreExpungeSearchResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreExpungeSearchResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreExpungeSearchResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreExpungeSearchResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreExpungeSearchResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreExpungeSearchResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreExpungeSearchResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreExpungeSearchResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreExpungeSearchResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreExpungeSearchResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreExpungeSearchResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreExpungeSearchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeSearchResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreExpungeSearchResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreExpungeSearchResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreExpungeSearchResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreExpungeSearchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeSearch_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeSearchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeSearchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeSearchResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeSearchResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeSearchResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeSearchResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Filter
//  - GUID
type NoteStoreFindNoteOffsetArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Filter *NoteFilter `thrift:"filter,2" db:"filter" json:"filter"`
  GUID GUID `thrift:"guid,3" db:"guid" json:"guid"`
}

func NewNoteStoreFindNoteOffsetArgs() *NoteStoreFindNoteOffsetArgs {
  return &NoteStoreFindNoteOffsetArgs{}
}


func (p *NoteStoreFindNoteOffsetArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreFindNoteOffsetArgs_Filter_DEFAULT *NoteFilter
func (p *NoteStoreFindNoteOffsetArgs) GetFilter() *NoteFilter {
  if !p.IsSetFilter() {
    return NoteStoreFindNoteOffsetArgs_Filter_DEFAULT
  }
return p.Filter
}

func (p *NoteStoreFindNoteOffsetArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreFindNoteOffsetArgs) IsSetFilter() bool {
  return p.Filter != nil
}

func (p *NoteStoreFindNoteOffsetArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindNoteOffsetArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreFindNoteOffsetArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Filter = &NoteFilter{}
  if err := p.Filter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Filter), err)
  }
  return nil
}

func (p *NoteStoreFindNoteOffsetArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreFindNoteOffsetArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findNoteOffset_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindNoteOffsetArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreFindNoteOffsetArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:filter: ", p), err) }
  if err := p.Filter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Filter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:filter: ", p), err) }
  return err
}

func (p *NoteStoreFindNoteOffsetArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:guid: ", p), err) }
  return err
}

func (p *NoteStoreFindNoteOffsetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindNoteOffsetArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreFindNoteOffsetResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreFindNoteOffsetResult() *NoteStoreFindNoteOffsetResult {
  return &NoteStoreFindNoteOffsetResult{}
}

var NoteStoreFindNoteOffsetResult_Success_DEFAULT int32
func (p *NoteStoreFindNoteOffsetResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreFindNoteOffsetResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreFindNoteOffsetResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreFindNoteOffsetResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreFindNoteOffsetResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreFindNoteOffsetResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreFindNoteOffsetResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreFindNoteOffsetResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreFindNoteOffsetResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreFindNoteOffsetResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreFindNoteOffsetResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreFindNoteOffsetResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreFindNoteOffsetResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreFindNoteOffsetResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreFindNoteOffsetResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreFindNoteOffsetResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindNoteOffsetResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreFindNoteOffsetResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreFindNoteOffsetResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreFindNoteOffsetResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreFindNoteOffsetResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findNoteOffset_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindNoteOffsetResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteOffsetResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteOffsetResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteOffsetResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteOffsetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindNoteOffsetResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Filter
//  - Offset
//  - MaxNotes
//  - ResultSpec
type NoteStoreFindNotesMetadataArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Filter *NoteFilter `thrift:"filter,2" db:"filter" json:"filter"`
  Offset int32 `thrift:"offset,3" db:"offset" json:"offset"`
  MaxNotes int32 `thrift:"maxNotes,4" db:"maxNotes" json:"maxNotes"`
  ResultSpec *NotesMetadataResultSpec `thrift:"resultSpec,5" db:"resultSpec" json:"resultSpec"`
}

func NewNoteStoreFindNotesMetadataArgs() *NoteStoreFindNotesMetadataArgs {
  return &NoteStoreFindNotesMetadataArgs{}
}


func (p *NoteStoreFindNotesMetadataArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreFindNotesMetadataArgs_Filter_DEFAULT *NoteFilter
func (p *NoteStoreFindNotesMetadataArgs) GetFilter() *NoteFilter {
  if !p.IsSetFilter() {
    return NoteStoreFindNotesMetadataArgs_Filter_DEFAULT
  }
return p.Filter
}

func (p *NoteStoreFindNotesMetadataArgs) GetOffset() int32 {
  return p.Offset
}

func (p *NoteStoreFindNotesMetadataArgs) GetMaxNotes() int32 {
  return p.MaxNotes
}
var NoteStoreFindNotesMetadataArgs_ResultSpec_DEFAULT *NotesMetadataResultSpec
func (p *NoteStoreFindNotesMetadataArgs) GetResultSpec() *NotesMetadataResultSpec {
  if !p.IsSetResultSpec() {
    return NoteStoreFindNotesMetadataArgs_ResultSpec_DEFAULT
  }
return p.ResultSpec
}
func (p *NoteStoreFindNotesMetadataArgs) IsSetFilter() bool {
  return p.Filter != nil
}

func (p *NoteStoreFindNotesMetadataArgs) IsSetResultSpec() bool {
  return p.ResultSpec != nil
}

func (p *NoteStoreFindNotesMetadataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Filter = &NoteFilter{}
  if err := p.Filter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Filter), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Offset = v
}
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.MaxNotes = v
}
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.ResultSpec = &NotesMetadataResultSpec{}
  if err := p.ResultSpec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ResultSpec), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findNotesMetadata_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindNotesMetadataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreFindNotesMetadataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:filter: ", p), err) }
  if err := p.Filter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Filter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:filter: ", p), err) }
  return err
}

func (p *NoteStoreFindNotesMetadataArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Offset)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.offset (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset: ", p), err) }
  return err
}

func (p *NoteStoreFindNotesMetadataArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxNotes", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:maxNotes: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxNotes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxNotes (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:maxNotes: ", p), err) }
  return err
}

func (p *NoteStoreFindNotesMetadataArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resultSpec", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:resultSpec: ", p), err) }
  if err := p.ResultSpec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ResultSpec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:resultSpec: ", p), err) }
  return err
}

func (p *NoteStoreFindNotesMetadataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindNotesMetadataArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreFindNotesMetadataResult struct {
  Success *NotesMetadataList `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreFindNotesMetadataResult() *NoteStoreFindNotesMetadataResult {
  return &NoteStoreFindNotesMetadataResult{}
}

var NoteStoreFindNotesMetadataResult_Success_DEFAULT *NotesMetadataList
func (p *NoteStoreFindNotesMetadataResult) GetSuccess() *NotesMetadataList {
  if !p.IsSetSuccess() {
    return NoteStoreFindNotesMetadataResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreFindNotesMetadataResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreFindNotesMetadataResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreFindNotesMetadataResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreFindNotesMetadataResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreFindNotesMetadataResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreFindNotesMetadataResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreFindNotesMetadataResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreFindNotesMetadataResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreFindNotesMetadataResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreFindNotesMetadataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreFindNotesMetadataResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreFindNotesMetadataResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreFindNotesMetadataResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreFindNotesMetadataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NotesMetadataList{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreFindNotesMetadataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findNotesMetadata_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindNotesMetadataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNotesMetadataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNotesMetadataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNotesMetadataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNotesMetadataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindNotesMetadataResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Filter
//  - WithTrash
type NoteStoreFindNoteCountsArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Filter *NoteFilter `thrift:"filter,2" db:"filter" json:"filter"`
  WithTrash bool `thrift:"withTrash,3" db:"withTrash" json:"withTrash"`
}

func NewNoteStoreFindNoteCountsArgs() *NoteStoreFindNoteCountsArgs {
  return &NoteStoreFindNoteCountsArgs{}
}


func (p *NoteStoreFindNoteCountsArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreFindNoteCountsArgs_Filter_DEFAULT *NoteFilter
func (p *NoteStoreFindNoteCountsArgs) GetFilter() *NoteFilter {
  if !p.IsSetFilter() {
    return NoteStoreFindNoteCountsArgs_Filter_DEFAULT
  }
return p.Filter
}

func (p *NoteStoreFindNoteCountsArgs) GetWithTrash() bool {
  return p.WithTrash
}
func (p *NoteStoreFindNoteCountsArgs) IsSetFilter() bool {
  return p.Filter != nil
}

func (p *NoteStoreFindNoteCountsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreFindNoteCountsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Filter = &NoteFilter{}
  if err := p.Filter.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Filter), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.WithTrash = v
}
  return nil
}

func (p *NoteStoreFindNoteCountsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findNoteCounts_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindNoteCountsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreFindNoteCountsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "filter", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:filter: ", p), err) }
  if err := p.Filter.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Filter), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:filter: ", p), err) }
  return err
}

func (p *NoteStoreFindNoteCountsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withTrash", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:withTrash: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithTrash)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withTrash (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:withTrash: ", p), err) }
  return err
}

func (p *NoteStoreFindNoteCountsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindNoteCountsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreFindNoteCountsResult struct {
  Success *NoteCollectionCounts `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreFindNoteCountsResult() *NoteStoreFindNoteCountsResult {
  return &NoteStoreFindNoteCountsResult{}
}

var NoteStoreFindNoteCountsResult_Success_DEFAULT *NoteCollectionCounts
func (p *NoteStoreFindNoteCountsResult) GetSuccess() *NoteCollectionCounts {
  if !p.IsSetSuccess() {
    return NoteStoreFindNoteCountsResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreFindNoteCountsResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreFindNoteCountsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreFindNoteCountsResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreFindNoteCountsResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreFindNoteCountsResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreFindNoteCountsResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreFindNoteCountsResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreFindNoteCountsResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreFindNoteCountsResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreFindNoteCountsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreFindNoteCountsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreFindNoteCountsResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreFindNoteCountsResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreFindNoteCountsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &NoteCollectionCounts{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreFindNoteCountsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findNoteCounts_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindNoteCountsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteCountsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteCountsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteCountsResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindNoteCountsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindNoteCountsResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - ResultSpec
type NoteStoreGetNoteWithResultSpecArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  ResultSpec *NoteResultSpec `thrift:"resultSpec,3" db:"resultSpec" json:"resultSpec"`
}

func NewNoteStoreGetNoteWithResultSpecArgs() *NoteStoreGetNoteWithResultSpecArgs {
  return &NoteStoreGetNoteWithResultSpecArgs{}
}


func (p *NoteStoreGetNoteWithResultSpecArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteWithResultSpecArgs) GetGUID() GUID {
  return p.GUID
}
var NoteStoreGetNoteWithResultSpecArgs_ResultSpec_DEFAULT *NoteResultSpec
func (p *NoteStoreGetNoteWithResultSpecArgs) GetResultSpec() *NoteResultSpec {
  if !p.IsSetResultSpec() {
    return NoteStoreGetNoteWithResultSpecArgs_ResultSpec_DEFAULT
  }
return p.ResultSpec
}
func (p *NoteStoreGetNoteWithResultSpecArgs) IsSetResultSpec() bool {
  return p.ResultSpec != nil
}

func (p *NoteStoreGetNoteWithResultSpecArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.ResultSpec = &NoteResultSpec{}
  if err := p.ResultSpec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ResultSpec), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteWithResultSpec_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resultSpec", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:resultSpec: ", p), err) }
  if err := p.ResultSpec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ResultSpec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:resultSpec: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteWithResultSpecArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteWithResultSpecResult struct {
  Success *Note `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteWithResultSpecResult() *NoteStoreGetNoteWithResultSpecResult {
  return &NoteStoreGetNoteWithResultSpecResult{}
}

var NoteStoreGetNoteWithResultSpecResult_Success_DEFAULT *Note
func (p *NoteStoreGetNoteWithResultSpecResult) GetSuccess() *Note {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteWithResultSpecResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetNoteWithResultSpecResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteWithResultSpecResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteWithResultSpecResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteWithResultSpecResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteWithResultSpecResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteWithResultSpecResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteWithResultSpecResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteWithResultSpecResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteWithResultSpecResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteWithResultSpecResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteWithResultSpecResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteWithResultSpecResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteWithResultSpecResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteWithResultSpecResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Note{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteWithResultSpec_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteWithResultSpecResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteWithResultSpecResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteWithResultSpecResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - WithContent
//  - WithResourcesData
//  - WithResourcesRecognition
//  - WithResourcesAlternateData
type NoteStoreGetNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  WithContent bool `thrift:"withContent,3" db:"withContent" json:"withContent"`
  WithResourcesData bool `thrift:"withResourcesData,4" db:"withResourcesData" json:"withResourcesData"`
  WithResourcesRecognition bool `thrift:"withResourcesRecognition,5" db:"withResourcesRecognition" json:"withResourcesRecognition"`
  WithResourcesAlternateData bool `thrift:"withResourcesAlternateData,6" db:"withResourcesAlternateData" json:"withResourcesAlternateData"`
}

func NewNoteStoreGetNoteArgs() *NoteStoreGetNoteArgs {
  return &NoteStoreGetNoteArgs{}
}


func (p *NoteStoreGetNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreGetNoteArgs) GetWithContent() bool {
  return p.WithContent
}

func (p *NoteStoreGetNoteArgs) GetWithResourcesData() bool {
  return p.WithResourcesData
}

func (p *NoteStoreGetNoteArgs) GetWithResourcesRecognition() bool {
  return p.WithResourcesRecognition
}

func (p *NoteStoreGetNoteArgs) GetWithResourcesAlternateData() bool {
  return p.WithResourcesAlternateData
}
func (p *NoteStoreGetNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.WithContent = v
}
  return nil
}

func (p *NoteStoreGetNoteArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.WithResourcesData = v
}
  return nil
}

func (p *NoteStoreGetNoteArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.WithResourcesRecognition = v
}
  return nil
}

func (p *NoteStoreGetNoteArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.WithResourcesAlternateData = v
}
  return nil
}

func (p *NoteStoreGetNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withContent", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:withContent: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithContent)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withContent (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:withContent: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withResourcesData", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:withResourcesData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithResourcesData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withResourcesData (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:withResourcesData: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withResourcesRecognition", thrift.BOOL, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:withResourcesRecognition: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithResourcesRecognition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withResourcesRecognition (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:withResourcesRecognition: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withResourcesAlternateData", thrift.BOOL, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:withResourcesAlternateData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithResourcesAlternateData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withResourcesAlternateData (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:withResourcesAlternateData: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteResult struct {
  Success *Note `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteResult() *NoteStoreGetNoteResult {
  return &NoteStoreGetNoteResult{}
}

var NoteStoreGetNoteResult_Success_DEFAULT *Note
func (p *NoteStoreGetNoteResult) GetSuccess() *Note {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Note{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetNoteApplicationDataArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetNoteApplicationDataArgs() *NoteStoreGetNoteApplicationDataArgs {
  return &NoteStoreGetNoteApplicationDataArgs{}
}


func (p *NoteStoreGetNoteApplicationDataArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteApplicationDataArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetNoteApplicationDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteApplicationDataArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteApplicationDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteApplicationData_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteApplicationDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteApplicationDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteApplicationDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteApplicationDataResult struct {
  Success *LazyMap `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteApplicationDataResult() *NoteStoreGetNoteApplicationDataResult {
  return &NoteStoreGetNoteApplicationDataResult{}
}

var NoteStoreGetNoteApplicationDataResult_Success_DEFAULT *LazyMap
func (p *NoteStoreGetNoteApplicationDataResult) GetSuccess() *LazyMap {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteApplicationDataResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetNoteApplicationDataResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteApplicationDataResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteApplicationDataResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteApplicationDataResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteApplicationDataResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteApplicationDataResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteApplicationDataResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteApplicationDataResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteApplicationDataResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteApplicationDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteApplicationDataResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteApplicationDataResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteApplicationDataResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteApplicationDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LazyMap{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteApplicationData_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteApplicationDataResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - Key
type NoteStoreGetNoteApplicationDataEntryArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  Key string `thrift:"key,3" db:"key" json:"key"`
}

func NewNoteStoreGetNoteApplicationDataEntryArgs() *NoteStoreGetNoteApplicationDataEntryArgs {
  return &NoteStoreGetNoteApplicationDataEntryArgs{}
}


func (p *NoteStoreGetNoteApplicationDataEntryArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) GetKey() string {
  return p.Key
}
func (p *NoteStoreGetNoteApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteApplicationDataEntry_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteApplicationDataEntryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteApplicationDataEntryResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteApplicationDataEntryResult() *NoteStoreGetNoteApplicationDataEntryResult {
  return &NoteStoreGetNoteApplicationDataEntryResult{}
}

var NoteStoreGetNoteApplicationDataEntryResult_Success_DEFAULT string
func (p *NoteStoreGetNoteApplicationDataEntryResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteApplicationDataEntryResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreGetNoteApplicationDataEntryResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteApplicationDataEntryResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteApplicationDataEntryResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteApplicationDataEntryResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteApplicationDataEntryResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteApplicationDataEntryResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteApplicationDataEntryResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteApplicationDataEntryResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteApplicationDataEntryResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteApplicationDataEntryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteApplicationDataEntry_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteApplicationDataEntryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteApplicationDataEntryResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - Key
//  - Value
type NoteStoreSetNoteApplicationDataEntryArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  Key string `thrift:"key,3" db:"key" json:"key"`
  Value string `thrift:"value,4" db:"value" json:"value"`
}

func NewNoteStoreSetNoteApplicationDataEntryArgs() *NoteStoreSetNoteApplicationDataEntryArgs {
  return &NoteStoreSetNoteApplicationDataEntryArgs{}
}


func (p *NoteStoreSetNoteApplicationDataEntryArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) GetKey() string {
  return p.Key
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) GetValue() string {
  return p.Value
}
func (p *NoteStoreSetNoteApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setNoteApplicationDataEntry_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:value: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:value: ", p), err) }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreSetNoteApplicationDataEntryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreSetNoteApplicationDataEntryResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreSetNoteApplicationDataEntryResult() *NoteStoreSetNoteApplicationDataEntryResult {
  return &NoteStoreSetNoteApplicationDataEntryResult{}
}

var NoteStoreSetNoteApplicationDataEntryResult_Success_DEFAULT int32
func (p *NoteStoreSetNoteApplicationDataEntryResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreSetNoteApplicationDataEntryResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreSetNoteApplicationDataEntryResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreSetNoteApplicationDataEntryResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreSetNoteApplicationDataEntryResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreSetNoteApplicationDataEntryResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreSetNoteApplicationDataEntryResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreSetNoteApplicationDataEntryResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreSetNoteApplicationDataEntryResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreSetNoteApplicationDataEntryResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreSetNoteApplicationDataEntryResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreSetNoteApplicationDataEntryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setNoteApplicationDataEntry_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNoteApplicationDataEntryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreSetNoteApplicationDataEntryResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - Key
type NoteStoreUnsetNoteApplicationDataEntryArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  Key string `thrift:"key,3" db:"key" json:"key"`
}

func NewNoteStoreUnsetNoteApplicationDataEntryArgs() *NoteStoreUnsetNoteApplicationDataEntryArgs {
  return &NoteStoreUnsetNoteApplicationDataEntryArgs{}
}


func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) GetKey() string {
  return p.Key
}
func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unsetNoteApplicationDataEntry_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUnsetNoteApplicationDataEntryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUnsetNoteApplicationDataEntryResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUnsetNoteApplicationDataEntryResult() *NoteStoreUnsetNoteApplicationDataEntryResult {
  return &NoteStoreUnsetNoteApplicationDataEntryResult{}
}

var NoteStoreUnsetNoteApplicationDataEntryResult_Success_DEFAULT int32
func (p *NoteStoreUnsetNoteApplicationDataEntryResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUnsetNoteApplicationDataEntryResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUnsetNoteApplicationDataEntryResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUnsetNoteApplicationDataEntryResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUnsetNoteApplicationDataEntryResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUnsetNoteApplicationDataEntryResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUnsetNoteApplicationDataEntryResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUnsetNoteApplicationDataEntryResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUnsetNoteApplicationDataEntryResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUnsetNoteApplicationDataEntryResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUnsetNoteApplicationDataEntryResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUnsetNoteApplicationDataEntryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unsetNoteApplicationDataEntry_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetNoteApplicationDataEntryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUnsetNoteApplicationDataEntryResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetNoteContentArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetNoteContentArgs() *NoteStoreGetNoteContentArgs {
  return &NoteStoreGetNoteContentArgs{}
}


func (p *NoteStoreGetNoteContentArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteContentArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetNoteContentArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteContentArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteContentArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteContentArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteContent_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteContentArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteContentArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteContentArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteContentArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteContentResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteContentResult() *NoteStoreGetNoteContentResult {
  return &NoteStoreGetNoteContentResult{}
}

var NoteStoreGetNoteContentResult_Success_DEFAULT string
func (p *NoteStoreGetNoteContentResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteContentResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreGetNoteContentResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteContentResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteContentResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteContentResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteContentResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteContentResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteContentResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteContentResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteContentResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteContentResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteContentResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteContentResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteContentResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteContentResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteContentResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreGetNoteContentResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteContentResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteContentResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteContentResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteContent_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteContentResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteContentResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteContentResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteContentResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteContentResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteContentResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - NoteOnly
//  - TokenizeForIndexing
type NoteStoreGetNoteSearchTextArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  NoteOnly bool `thrift:"noteOnly,3" db:"noteOnly" json:"noteOnly"`
  TokenizeForIndexing bool `thrift:"tokenizeForIndexing,4" db:"tokenizeForIndexing" json:"tokenizeForIndexing"`
}

func NewNoteStoreGetNoteSearchTextArgs() *NoteStoreGetNoteSearchTextArgs {
  return &NoteStoreGetNoteSearchTextArgs{}
}


func (p *NoteStoreGetNoteSearchTextArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteSearchTextArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreGetNoteSearchTextArgs) GetNoteOnly() bool {
  return p.NoteOnly
}

func (p *NoteStoreGetNoteSearchTextArgs) GetTokenizeForIndexing() bool {
  return p.TokenizeForIndexing
}
func (p *NoteStoreGetNoteSearchTextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteSearchTextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteSearchTextArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteSearchTextArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NoteOnly = v
}
  return nil
}

func (p *NoteStoreGetNoteSearchTextArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TokenizeForIndexing = v
}
  return nil
}

func (p *NoteStoreGetNoteSearchTextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteSearchText_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteSearchTextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteSearchTextArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteSearchTextArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "noteOnly", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:noteOnly: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.NoteOnly)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.noteOnly (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:noteOnly: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteSearchTextArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tokenizeForIndexing", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:tokenizeForIndexing: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.TokenizeForIndexing)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tokenizeForIndexing (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:tokenizeForIndexing: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteSearchTextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteSearchTextArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteSearchTextResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteSearchTextResult() *NoteStoreGetNoteSearchTextResult {
  return &NoteStoreGetNoteSearchTextResult{}
}

var NoteStoreGetNoteSearchTextResult_Success_DEFAULT string
func (p *NoteStoreGetNoteSearchTextResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteSearchTextResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreGetNoteSearchTextResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteSearchTextResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteSearchTextResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteSearchTextResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteSearchTextResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteSearchTextResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteSearchTextResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteSearchTextResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteSearchTextResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteSearchTextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteSearchTextResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteSearchTextResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteSearchTextResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteSearchTextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteSearchTextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreGetNoteSearchTextResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteSearchTextResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteSearchTextResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteSearchTextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteSearchText_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteSearchTextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteSearchTextResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteSearchTextResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteSearchTextResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteSearchTextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteSearchTextResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetResourceSearchTextArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetResourceSearchTextArgs() *NoteStoreGetResourceSearchTextArgs {
  return &NoteStoreGetResourceSearchTextArgs{}
}


func (p *NoteStoreGetResourceSearchTextArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceSearchTextArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetResourceSearchTextArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceSearchTextArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceSearchTextArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceSearchTextArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceSearchText_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceSearchTextArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceSearchTextArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceSearchTextArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceSearchTextArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceSearchTextResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceSearchTextResult() *NoteStoreGetResourceSearchTextResult {
  return &NoteStoreGetResourceSearchTextResult{}
}

var NoteStoreGetResourceSearchTextResult_Success_DEFAULT string
func (p *NoteStoreGetResourceSearchTextResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return NoteStoreGetResourceSearchTextResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreGetResourceSearchTextResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceSearchTextResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceSearchTextResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceSearchTextResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceSearchTextResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceSearchTextResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceSearchTextResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceSearchTextResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceSearchTextResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceSearchTextResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceSearchTextResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceSearchTextResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceSearchTextResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceSearchTextResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceSearchTextResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreGetResourceSearchTextResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceSearchTextResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceSearchTextResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceSearchTextResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceSearchText_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceSearchTextResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceSearchTextResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceSearchTextResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceSearchTextResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceSearchTextResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceSearchTextResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetNoteTagNamesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetNoteTagNamesArgs() *NoteStoreGetNoteTagNamesArgs {
  return &NoteStoreGetNoteTagNamesArgs{}
}


func (p *NoteStoreGetNoteTagNamesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteTagNamesArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetNoteTagNamesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteTagNamesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteTagNamesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetNoteTagNamesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteTagNames_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteTagNamesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteTagNamesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteTagNamesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteTagNamesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteTagNamesResult struct {
  Success []string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteTagNamesResult() *NoteStoreGetNoteTagNamesResult {
  return &NoteStoreGetNoteTagNamesResult{}
}

var NoteStoreGetNoteTagNamesResult_Success_DEFAULT []string

func (p *NoteStoreGetNoteTagNamesResult) GetSuccess() []string {
  return p.Success
}
var NoteStoreGetNoteTagNamesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteTagNamesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteTagNamesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteTagNamesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteTagNamesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteTagNamesResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteTagNamesResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteTagNamesResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteTagNamesResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteTagNamesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteTagNamesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteTagNamesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteTagNamesResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteTagNamesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteTagNamesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
var _elem361 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem361 = v
}
    p.Success = append(p.Success, _elem361)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreGetNoteTagNamesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteTagNamesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteTagNamesResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteTagNamesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteTagNames_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteTagNamesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteTagNamesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteTagNamesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteTagNamesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteTagNamesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteTagNamesResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Note
type NoteStoreCreateNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Note *Note `thrift:"note,2" db:"note" json:"note"`
}

func NewNoteStoreCreateNoteArgs() *NoteStoreCreateNoteArgs {
  return &NoteStoreCreateNoteArgs{}
}


func (p *NoteStoreCreateNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreCreateNoteArgs_Note_DEFAULT *Note
func (p *NoteStoreCreateNoteArgs) GetNote() *Note {
  if !p.IsSetNote() {
    return NoteStoreCreateNoteArgs_Note_DEFAULT
  }
return p.Note
}
func (p *NoteStoreCreateNoteArgs) IsSetNote() bool {
  return p.Note != nil
}

func (p *NoteStoreCreateNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCreateNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Note = &Note{}
  if err := p.Note.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Note), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCreateNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:note: ", p), err) }
  if err := p.Note.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Note), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:note: ", p), err) }
  return err
}

func (p *NoteStoreCreateNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreCreateNoteResult struct {
  Success *Note `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreCreateNoteResult() *NoteStoreCreateNoteResult {
  return &NoteStoreCreateNoteResult{}
}

var NoteStoreCreateNoteResult_Success_DEFAULT *Note
func (p *NoteStoreCreateNoteResult) GetSuccess() *Note {
  if !p.IsSetSuccess() {
    return NoteStoreCreateNoteResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCreateNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCreateNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCreateNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCreateNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCreateNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCreateNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreCreateNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreCreateNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreCreateNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreCreateNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCreateNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCreateNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCreateNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreCreateNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Note{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreCreateNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Note
type NoteStoreUpdateNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Note *Note `thrift:"note,2" db:"note" json:"note"`
}

func NewNoteStoreUpdateNoteArgs() *NoteStoreUpdateNoteArgs {
  return &NoteStoreUpdateNoteArgs{}
}


func (p *NoteStoreUpdateNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateNoteArgs_Note_DEFAULT *Note
func (p *NoteStoreUpdateNoteArgs) GetNote() *Note {
  if !p.IsSetNote() {
    return NoteStoreUpdateNoteArgs_Note_DEFAULT
  }
return p.Note
}
func (p *NoteStoreUpdateNoteArgs) IsSetNote() bool {
  return p.Note != nil
}

func (p *NoteStoreUpdateNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Note = &Note{}
  if err := p.Note.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Note), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:note: ", p), err) }
  if err := p.Note.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Note), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:note: ", p), err) }
  return err
}

func (p *NoteStoreUpdateNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUpdateNoteResult struct {
  Success *Note `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUpdateNoteResult() *NoteStoreUpdateNoteResult {
  return &NoteStoreUpdateNoteResult{}
}

var NoteStoreUpdateNoteResult_Success_DEFAULT *Note
func (p *NoteStoreUpdateNoteResult) GetSuccess() *Note {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateNoteResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreUpdateNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUpdateNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUpdateNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Note{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreDeleteNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreDeleteNoteArgs() *NoteStoreDeleteNoteArgs {
  return &NoteStoreDeleteNoteArgs{}
}


func (p *NoteStoreDeleteNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreDeleteNoteArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreDeleteNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreDeleteNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreDeleteNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreDeleteNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreDeleteNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreDeleteNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreDeleteNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreDeleteNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreDeleteNoteResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreDeleteNoteResult() *NoteStoreDeleteNoteResult {
  return &NoteStoreDeleteNoteResult{}
}

var NoteStoreDeleteNoteResult_Success_DEFAULT int32
func (p *NoteStoreDeleteNoteResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreDeleteNoteResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreDeleteNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreDeleteNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreDeleteNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreDeleteNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreDeleteNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreDeleteNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreDeleteNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreDeleteNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreDeleteNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreDeleteNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreDeleteNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreDeleteNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreDeleteNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreDeleteNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreDeleteNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreDeleteNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreDeleteNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreDeleteNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreDeleteNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreDeleteNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreDeleteNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreDeleteNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreDeleteNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreDeleteNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreDeleteNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreExpungeNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreExpungeNoteArgs() *NoteStoreExpungeNoteArgs {
  return &NoteStoreExpungeNoteArgs{}
}


func (p *NoteStoreExpungeNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreExpungeNoteArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreExpungeNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreExpungeNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreExpungeNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreExpungeNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreExpungeNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreExpungeNoteResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreExpungeNoteResult() *NoteStoreExpungeNoteResult {
  return &NoteStoreExpungeNoteResult{}
}

var NoteStoreExpungeNoteResult_Success_DEFAULT int32
func (p *NoteStoreExpungeNoteResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreExpungeNoteResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreExpungeNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreExpungeNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreExpungeNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreExpungeNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreExpungeNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreExpungeNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreExpungeNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreExpungeNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreExpungeNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreExpungeNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreExpungeNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreExpungeNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreExpungeNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreExpungeNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreExpungeNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreExpungeNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreExpungeNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreExpungeNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NoteGuid
//  - ToNotebookGuid
type NoteStoreCopyNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NoteGuid GUID `thrift:"noteGuid,2" db:"noteGuid" json:"noteGuid"`
  ToNotebookGuid GUID `thrift:"toNotebookGuid,3" db:"toNotebookGuid" json:"toNotebookGuid"`
}

func NewNoteStoreCopyNoteArgs() *NoteStoreCopyNoteArgs {
  return &NoteStoreCopyNoteArgs{}
}


func (p *NoteStoreCopyNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreCopyNoteArgs) GetNoteGuid() GUID {
  return p.NoteGuid
}

func (p *NoteStoreCopyNoteArgs) GetToNotebookGuid() GUID {
  return p.ToNotebookGuid
}
func (p *NoteStoreCopyNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCopyNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCopyNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.NoteGuid = temp
}
  return nil
}

func (p *NoteStoreCopyNoteArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := GUID(v)
  p.ToNotebookGuid = temp
}
  return nil
}

func (p *NoteStoreCopyNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "copyNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCopyNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCopyNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noteGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.noteGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noteGuid: ", p), err) }
  return err
}

func (p *NoteStoreCopyNoteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "toNotebookGuid", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:toNotebookGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ToNotebookGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.toNotebookGuid (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:toNotebookGuid: ", p), err) }
  return err
}

func (p *NoteStoreCopyNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCopyNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreCopyNoteResult struct {
  Success *Note `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreCopyNoteResult() *NoteStoreCopyNoteResult {
  return &NoteStoreCopyNoteResult{}
}

var NoteStoreCopyNoteResult_Success_DEFAULT *Note
func (p *NoteStoreCopyNoteResult) GetSuccess() *Note {
  if !p.IsSetSuccess() {
    return NoteStoreCopyNoteResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCopyNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCopyNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCopyNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCopyNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCopyNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCopyNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreCopyNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreCopyNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreCopyNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreCopyNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCopyNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCopyNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCopyNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreCopyNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCopyNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Note{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCopyNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCopyNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCopyNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreCopyNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "copyNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCopyNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCopyNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCopyNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCopyNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCopyNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCopyNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NoteGuid
type NoteStoreListNoteVersionsArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NoteGuid GUID `thrift:"noteGuid,2" db:"noteGuid" json:"noteGuid"`
}

func NewNoteStoreListNoteVersionsArgs() *NoteStoreListNoteVersionsArgs {
  return &NoteStoreListNoteVersionsArgs{}
}


func (p *NoteStoreListNoteVersionsArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreListNoteVersionsArgs) GetNoteGuid() GUID {
  return p.NoteGuid
}
func (p *NoteStoreListNoteVersionsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListNoteVersionsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListNoteVersionsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.NoteGuid = temp
}
  return nil
}

func (p *NoteStoreListNoteVersionsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNoteVersions_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListNoteVersionsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListNoteVersionsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noteGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.noteGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noteGuid: ", p), err) }
  return err
}

func (p *NoteStoreListNoteVersionsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListNoteVersionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreListNoteVersionsResult struct {
  Success []*NoteVersionId `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreListNoteVersionsResult() *NoteStoreListNoteVersionsResult {
  return &NoteStoreListNoteVersionsResult{}
}

var NoteStoreListNoteVersionsResult_Success_DEFAULT []*NoteVersionId

func (p *NoteStoreListNoteVersionsResult) GetSuccess() []*NoteVersionId {
  return p.Success
}
var NoteStoreListNoteVersionsResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListNoteVersionsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListNoteVersionsResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListNoteVersionsResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListNoteVersionsResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListNoteVersionsResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreListNoteVersionsResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreListNoteVersionsResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreListNoteVersionsResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreListNoteVersionsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListNoteVersionsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListNoteVersionsResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListNoteVersionsResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreListNoteVersionsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListNoteVersionsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*NoteVersionId, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem362 := &NoteVersionId{}
    if err := _elem362.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem362), err)
    }
    p.Success = append(p.Success, _elem362)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListNoteVersionsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListNoteVersionsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListNoteVersionsResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreListNoteVersionsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listNoteVersions_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListNoteVersionsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNoteVersionsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNoteVersionsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNoteVersionsResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListNoteVersionsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListNoteVersionsResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NoteGuid
//  - UpdateSequenceNum
//  - WithResourcesData
//  - WithResourcesRecognition
//  - WithResourcesAlternateData
type NoteStoreGetNoteVersionArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NoteGuid GUID `thrift:"noteGuid,2" db:"noteGuid" json:"noteGuid"`
  UpdateSequenceNum int32 `thrift:"updateSequenceNum,3" db:"updateSequenceNum" json:"updateSequenceNum"`
  WithResourcesData bool `thrift:"withResourcesData,4" db:"withResourcesData" json:"withResourcesData"`
  WithResourcesRecognition bool `thrift:"withResourcesRecognition,5" db:"withResourcesRecognition" json:"withResourcesRecognition"`
  WithResourcesAlternateData bool `thrift:"withResourcesAlternateData,6" db:"withResourcesAlternateData" json:"withResourcesAlternateData"`
}

func NewNoteStoreGetNoteVersionArgs() *NoteStoreGetNoteVersionArgs {
  return &NoteStoreGetNoteVersionArgs{}
}


func (p *NoteStoreGetNoteVersionArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNoteVersionArgs) GetNoteGuid() GUID {
  return p.NoteGuid
}

func (p *NoteStoreGetNoteVersionArgs) GetUpdateSequenceNum() int32 {
  return p.UpdateSequenceNum
}

func (p *NoteStoreGetNoteVersionArgs) GetWithResourcesData() bool {
  return p.WithResourcesData
}

func (p *NoteStoreGetNoteVersionArgs) GetWithResourcesRecognition() bool {
  return p.WithResourcesRecognition
}

func (p *NoteStoreGetNoteVersionArgs) GetWithResourcesAlternateData() bool {
  return p.WithResourcesAlternateData
}
func (p *NoteStoreGetNoteVersionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteVersionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNoteVersionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.NoteGuid = temp
}
  return nil
}

func (p *NoteStoreGetNoteVersionArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.UpdateSequenceNum = v
}
  return nil
}

func (p *NoteStoreGetNoteVersionArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.WithResourcesData = v
}
  return nil
}

func (p *NoteStoreGetNoteVersionArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.WithResourcesRecognition = v
}
  return nil
}

func (p *NoteStoreGetNoteVersionArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.WithResourcesAlternateData = v
}
  return nil
}

func (p *NoteStoreGetNoteVersionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteVersion_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteVersionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteVersionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noteGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.noteGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noteGuid: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteVersionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateSequenceNum", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:updateSequenceNum: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UpdateSequenceNum)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updateSequenceNum (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:updateSequenceNum: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteVersionArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withResourcesData", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:withResourcesData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithResourcesData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withResourcesData (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:withResourcesData: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteVersionArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withResourcesRecognition", thrift.BOOL, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:withResourcesRecognition: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithResourcesRecognition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withResourcesRecognition (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:withResourcesRecognition: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteVersionArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withResourcesAlternateData", thrift.BOOL, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:withResourcesAlternateData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithResourcesAlternateData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withResourcesAlternateData (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:withResourcesAlternateData: ", p), err) }
  return err
}

func (p *NoteStoreGetNoteVersionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteVersionArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetNoteVersionResult struct {
  Success *Note `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetNoteVersionResult() *NoteStoreGetNoteVersionResult {
  return &NoteStoreGetNoteVersionResult{}
}

var NoteStoreGetNoteVersionResult_Success_DEFAULT *Note
func (p *NoteStoreGetNoteVersionResult) GetSuccess() *Note {
  if !p.IsSetSuccess() {
    return NoteStoreGetNoteVersionResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetNoteVersionResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNoteVersionResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNoteVersionResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNoteVersionResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNoteVersionResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNoteVersionResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetNoteVersionResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNoteVersionResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNoteVersionResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetNoteVersionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNoteVersionResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNoteVersionResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNoteVersionResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNoteVersionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNoteVersionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Note{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetNoteVersionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteVersionResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteVersionResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNoteVersionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNoteVersion_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNoteVersionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteVersionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteVersionResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteVersionResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNoteVersionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNoteVersionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - WithData
//  - WithRecognition
//  - WithAttributes
//  - WithAlternateData
type NoteStoreGetResourceArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  WithData bool `thrift:"withData,3" db:"withData" json:"withData"`
  WithRecognition bool `thrift:"withRecognition,4" db:"withRecognition" json:"withRecognition"`
  WithAttributes bool `thrift:"withAttributes,5" db:"withAttributes" json:"withAttributes"`
  WithAlternateData bool `thrift:"withAlternateData,6" db:"withAlternateData" json:"withAlternateData"`
}

func NewNoteStoreGetResourceArgs() *NoteStoreGetResourceArgs {
  return &NoteStoreGetResourceArgs{}
}


func (p *NoteStoreGetResourceArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreGetResourceArgs) GetWithData() bool {
  return p.WithData
}

func (p *NoteStoreGetResourceArgs) GetWithRecognition() bool {
  return p.WithRecognition
}

func (p *NoteStoreGetResourceArgs) GetWithAttributes() bool {
  return p.WithAttributes
}

func (p *NoteStoreGetResourceArgs) GetWithAlternateData() bool {
  return p.WithAlternateData
}
func (p *NoteStoreGetResourceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.WithData = v
}
  return nil
}

func (p *NoteStoreGetResourceArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.WithRecognition = v
}
  return nil
}

func (p *NoteStoreGetResourceArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.WithAttributes = v
}
  return nil
}

func (p *NoteStoreGetResourceArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.WithAlternateData = v
}
  return nil
}

func (p *NoteStoreGetResourceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResource_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withData", thrift.BOOL, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:withData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withData (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:withData: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withRecognition", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:withRecognition: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithRecognition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withRecognition (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:withRecognition: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withAttributes", thrift.BOOL, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:withAttributes: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithAttributes)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withAttributes (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:withAttributes: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withAlternateData", thrift.BOOL, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:withAlternateData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithAlternateData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withAlternateData (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:withAlternateData: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceResult struct {
  Success *Resource `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceResult() *NoteStoreGetResourceResult {
  return &NoteStoreGetResourceResult{}
}

var NoteStoreGetResourceResult_Success_DEFAULT *Resource
func (p *NoteStoreGetResourceResult) GetSuccess() *Resource {
  if !p.IsSetSuccess() {
    return NoteStoreGetResourceResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetResourceResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Resource{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetResourceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResource_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetResourceApplicationDataArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetResourceApplicationDataArgs() *NoteStoreGetResourceApplicationDataArgs {
  return &NoteStoreGetResourceApplicationDataArgs{}
}


func (p *NoteStoreGetResourceApplicationDataArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceApplicationDataArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetResourceApplicationDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceApplicationDataArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceApplicationDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceApplicationData_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceApplicationDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceApplicationDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceApplicationDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceApplicationDataResult struct {
  Success *LazyMap `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceApplicationDataResult() *NoteStoreGetResourceApplicationDataResult {
  return &NoteStoreGetResourceApplicationDataResult{}
}

var NoteStoreGetResourceApplicationDataResult_Success_DEFAULT *LazyMap
func (p *NoteStoreGetResourceApplicationDataResult) GetSuccess() *LazyMap {
  if !p.IsSetSuccess() {
    return NoteStoreGetResourceApplicationDataResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetResourceApplicationDataResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceApplicationDataResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceApplicationDataResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceApplicationDataResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceApplicationDataResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceApplicationDataResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceApplicationDataResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceApplicationDataResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceApplicationDataResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceApplicationDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceApplicationDataResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceApplicationDataResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceApplicationDataResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceApplicationDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LazyMap{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceApplicationData_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceApplicationDataResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - Key
type NoteStoreGetResourceApplicationDataEntryArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  Key string `thrift:"key,3" db:"key" json:"key"`
}

func NewNoteStoreGetResourceApplicationDataEntryArgs() *NoteStoreGetResourceApplicationDataEntryArgs {
  return &NoteStoreGetResourceApplicationDataEntryArgs{}
}


func (p *NoteStoreGetResourceApplicationDataEntryArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) GetKey() string {
  return p.Key
}
func (p *NoteStoreGetResourceApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceApplicationDataEntry_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceApplicationDataEntryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceApplicationDataEntryResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceApplicationDataEntryResult() *NoteStoreGetResourceApplicationDataEntryResult {
  return &NoteStoreGetResourceApplicationDataEntryResult{}
}

var NoteStoreGetResourceApplicationDataEntryResult_Success_DEFAULT string
func (p *NoteStoreGetResourceApplicationDataEntryResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return NoteStoreGetResourceApplicationDataEntryResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreGetResourceApplicationDataEntryResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceApplicationDataEntryResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceApplicationDataEntryResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceApplicationDataEntryResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceApplicationDataEntryResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceApplicationDataEntryResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceApplicationDataEntryResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceApplicationDataEntryResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceApplicationDataEntryResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceApplicationDataEntryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceApplicationDataEntry_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceApplicationDataEntryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceApplicationDataEntryResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - Key
//  - Value
type NoteStoreSetResourceApplicationDataEntryArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  Key string `thrift:"key,3" db:"key" json:"key"`
  Value string `thrift:"value,4" db:"value" json:"value"`
}

func NewNoteStoreSetResourceApplicationDataEntryArgs() *NoteStoreSetResourceApplicationDataEntryArgs {
  return &NoteStoreSetResourceApplicationDataEntryArgs{}
}


func (p *NoteStoreSetResourceApplicationDataEntryArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) GetKey() string {
  return p.Key
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) GetValue() string {
  return p.Value
}
func (p *NoteStoreSetResourceApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setResourceApplicationDataEntry_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:value: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:value: ", p), err) }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreSetResourceApplicationDataEntryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreSetResourceApplicationDataEntryResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreSetResourceApplicationDataEntryResult() *NoteStoreSetResourceApplicationDataEntryResult {
  return &NoteStoreSetResourceApplicationDataEntryResult{}
}

var NoteStoreSetResourceApplicationDataEntryResult_Success_DEFAULT int32
func (p *NoteStoreSetResourceApplicationDataEntryResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreSetResourceApplicationDataEntryResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreSetResourceApplicationDataEntryResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreSetResourceApplicationDataEntryResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreSetResourceApplicationDataEntryResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreSetResourceApplicationDataEntryResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreSetResourceApplicationDataEntryResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreSetResourceApplicationDataEntryResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreSetResourceApplicationDataEntryResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreSetResourceApplicationDataEntryResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreSetResourceApplicationDataEntryResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreSetResourceApplicationDataEntryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setResourceApplicationDataEntry_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetResourceApplicationDataEntryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreSetResourceApplicationDataEntryResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
//  - Key
type NoteStoreUnsetResourceApplicationDataEntryArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
  Key string `thrift:"key,3" db:"key" json:"key"`
}

func NewNoteStoreUnsetResourceApplicationDataEntryArgs() *NoteStoreUnsetResourceApplicationDataEntryArgs {
  return &NoteStoreUnsetResourceApplicationDataEntryArgs{}
}


func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) GetGUID() GUID {
  return p.GUID
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) GetKey() string {
  return p.Key
}
func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unsetResourceApplicationDataEntry_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUnsetResourceApplicationDataEntryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUnsetResourceApplicationDataEntryResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUnsetResourceApplicationDataEntryResult() *NoteStoreUnsetResourceApplicationDataEntryResult {
  return &NoteStoreUnsetResourceApplicationDataEntryResult{}
}

var NoteStoreUnsetResourceApplicationDataEntryResult_Success_DEFAULT int32
func (p *NoteStoreUnsetResourceApplicationDataEntryResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUnsetResourceApplicationDataEntryResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUnsetResourceApplicationDataEntryResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUnsetResourceApplicationDataEntryResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUnsetResourceApplicationDataEntryResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUnsetResourceApplicationDataEntryResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUnsetResourceApplicationDataEntryResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUnsetResourceApplicationDataEntryResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUnsetResourceApplicationDataEntryResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUnsetResourceApplicationDataEntryResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUnsetResourceApplicationDataEntryResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUnsetResourceApplicationDataEntryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unsetResourceApplicationDataEntry_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUnsetResourceApplicationDataEntryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUnsetResourceApplicationDataEntryResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Resource
type NoteStoreUpdateResourceArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Resource *Resource `thrift:"resource,2" db:"resource" json:"resource"`
}

func NewNoteStoreUpdateResourceArgs() *NoteStoreUpdateResourceArgs {
  return &NoteStoreUpdateResourceArgs{}
}


func (p *NoteStoreUpdateResourceArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateResourceArgs_Resource_DEFAULT *Resource
func (p *NoteStoreUpdateResourceArgs) GetResource() *Resource {
  if !p.IsSetResource() {
    return NoteStoreUpdateResourceArgs_Resource_DEFAULT
  }
return p.Resource
}
func (p *NoteStoreUpdateResourceArgs) IsSetResource() bool {
  return p.Resource != nil
}

func (p *NoteStoreUpdateResourceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateResourceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateResourceArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Resource = &Resource{}
  if err := p.Resource.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Resource), err)
  }
  return nil
}

func (p *NoteStoreUpdateResourceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateResource_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateResourceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateResourceArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resource", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:resource: ", p), err) }
  if err := p.Resource.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Resource), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:resource: ", p), err) }
  return err
}

func (p *NoteStoreUpdateResourceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateResourceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreUpdateResourceResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreUpdateResourceResult() *NoteStoreUpdateResourceResult {
  return &NoteStoreUpdateResourceResult{}
}

var NoteStoreUpdateResourceResult_Success_DEFAULT int32
func (p *NoteStoreUpdateResourceResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateResourceResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUpdateResourceResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateResourceResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateResourceResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateResourceResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateResourceResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateResourceResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreUpdateResourceResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateResourceResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateResourceResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreUpdateResourceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateResourceResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateResourceResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateResourceResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateResourceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateResourceResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUpdateResourceResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateResourceResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateResourceResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateResourceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateResource_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateResourceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateResourceResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateResourceResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateResourceResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateResourceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateResourceResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetResourceDataArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetResourceDataArgs() *NoteStoreGetResourceDataArgs {
  return &NoteStoreGetResourceDataArgs{}
}


func (p *NoteStoreGetResourceDataArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceDataArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetResourceDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceDataArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceData_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceDataResult() *NoteStoreGetResourceDataResult {
  return &NoteStoreGetResourceDataResult{}
}

var NoteStoreGetResourceDataResult_Success_DEFAULT []byte

func (p *NoteStoreGetResourceDataResult) GetSuccess() []byte {
  return p.Success
}
var NoteStoreGetResourceDataResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceDataResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceDataResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceDataResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceDataResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceDataResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceDataResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceDataResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceDataResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceDataResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceDataResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceDataResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *NoteStoreGetResourceDataResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceDataResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceDataResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceData_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceDataResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NoteGuid
//  - ContentHash
//  - WithData
//  - WithRecognition
//  - WithAlternateData
type NoteStoreGetResourceByHashArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NoteGuid GUID `thrift:"noteGuid,2" db:"noteGuid" json:"noteGuid"`
  ContentHash []byte `thrift:"contentHash,3" db:"contentHash" json:"contentHash"`
  WithData bool `thrift:"withData,4" db:"withData" json:"withData"`
  WithRecognition bool `thrift:"withRecognition,5" db:"withRecognition" json:"withRecognition"`
  WithAlternateData bool `thrift:"withAlternateData,6" db:"withAlternateData" json:"withAlternateData"`
}

func NewNoteStoreGetResourceByHashArgs() *NoteStoreGetResourceByHashArgs {
  return &NoteStoreGetResourceByHashArgs{}
}


func (p *NoteStoreGetResourceByHashArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceByHashArgs) GetNoteGuid() GUID {
  return p.NoteGuid
}

func (p *NoteStoreGetResourceByHashArgs) GetContentHash() []byte {
  return p.ContentHash
}

func (p *NoteStoreGetResourceByHashArgs) GetWithData() bool {
  return p.WithData
}

func (p *NoteStoreGetResourceByHashArgs) GetWithRecognition() bool {
  return p.WithRecognition
}

func (p *NoteStoreGetResourceByHashArgs) GetWithAlternateData() bool {
  return p.WithAlternateData
}
func (p *NoteStoreGetResourceByHashArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceByHashArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceByHashArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.NoteGuid = temp
}
  return nil
}

func (p *NoteStoreGetResourceByHashArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ContentHash = v
}
  return nil
}

func (p *NoteStoreGetResourceByHashArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.WithData = v
}
  return nil
}

func (p *NoteStoreGetResourceByHashArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.WithRecognition = v
}
  return nil
}

func (p *NoteStoreGetResourceByHashArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.WithAlternateData = v
}
  return nil
}

func (p *NoteStoreGetResourceByHashArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceByHash_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceByHashArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceByHashArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "noteGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noteGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NoteGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.noteGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noteGuid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceByHashArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "contentHash", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:contentHash: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.ContentHash); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.contentHash (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:contentHash: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceByHashArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withData", thrift.BOOL, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:withData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withData (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:withData: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceByHashArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withRecognition", thrift.BOOL, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:withRecognition: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithRecognition)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withRecognition (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:withRecognition: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceByHashArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "withAlternateData", thrift.BOOL, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:withAlternateData: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WithAlternateData)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.withAlternateData (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:withAlternateData: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceByHashArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceByHashArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceByHashResult struct {
  Success *Resource `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceByHashResult() *NoteStoreGetResourceByHashResult {
  return &NoteStoreGetResourceByHashResult{}
}

var NoteStoreGetResourceByHashResult_Success_DEFAULT *Resource
func (p *NoteStoreGetResourceByHashResult) GetSuccess() *Resource {
  if !p.IsSetSuccess() {
    return NoteStoreGetResourceByHashResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetResourceByHashResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceByHashResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceByHashResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceByHashResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceByHashResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceByHashResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceByHashResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceByHashResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceByHashResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceByHashResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceByHashResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceByHashResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceByHashResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceByHashResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceByHashResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Resource{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetResourceByHashResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceByHashResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceByHashResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceByHashResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceByHash_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceByHashResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceByHashResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceByHashResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceByHashResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceByHashResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceByHashResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetResourceRecognitionArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetResourceRecognitionArgs() *NoteStoreGetResourceRecognitionArgs {
  return &NoteStoreGetResourceRecognitionArgs{}
}


func (p *NoteStoreGetResourceRecognitionArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceRecognitionArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetResourceRecognitionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceRecognitionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceRecognitionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceRecognitionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceRecognition_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceRecognitionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceRecognitionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceRecognitionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceRecognitionArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceRecognitionResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceRecognitionResult() *NoteStoreGetResourceRecognitionResult {
  return &NoteStoreGetResourceRecognitionResult{}
}

var NoteStoreGetResourceRecognitionResult_Success_DEFAULT []byte

func (p *NoteStoreGetResourceRecognitionResult) GetSuccess() []byte {
  return p.Success
}
var NoteStoreGetResourceRecognitionResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceRecognitionResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceRecognitionResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceRecognitionResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceRecognitionResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceRecognitionResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceRecognitionResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceRecognitionResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceRecognitionResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceRecognitionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceRecognitionResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceRecognitionResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceRecognitionResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceRecognitionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceRecognitionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *NoteStoreGetResourceRecognitionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceRecognitionResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceRecognitionResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceRecognitionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceRecognition_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceRecognitionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceRecognitionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceRecognitionResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceRecognitionResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceRecognitionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceRecognitionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetResourceAlternateDataArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetResourceAlternateDataArgs() *NoteStoreGetResourceAlternateDataArgs {
  return &NoteStoreGetResourceAlternateDataArgs{}
}


func (p *NoteStoreGetResourceAlternateDataArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceAlternateDataArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetResourceAlternateDataArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceAlternateDataArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceAlternateDataArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceAlternateData_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceAlternateDataArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceAlternateDataArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceAlternateDataArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceAlternateDataResult struct {
  Success []byte `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceAlternateDataResult() *NoteStoreGetResourceAlternateDataResult {
  return &NoteStoreGetResourceAlternateDataResult{}
}

var NoteStoreGetResourceAlternateDataResult_Success_DEFAULT []byte

func (p *NoteStoreGetResourceAlternateDataResult) GetSuccess() []byte {
  return p.Success
}
var NoteStoreGetResourceAlternateDataResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceAlternateDataResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceAlternateDataResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceAlternateDataResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceAlternateDataResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceAlternateDataResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceAlternateDataResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceAlternateDataResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceAlternateDataResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceAlternateDataResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceAlternateDataResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceAlternateDataResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceAlternateDataResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceAlternateDataResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = v
}
  return nil
}

func (p *NoteStoreGetResourceAlternateDataResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceAlternateData_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceAlternateDataResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.Success); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAlternateDataResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAlternateDataResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAlternateDataResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAlternateDataResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceAlternateDataResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreGetResourceAttributesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreGetResourceAttributesArgs() *NoteStoreGetResourceAttributesArgs {
  return &NoteStoreGetResourceAttributesArgs{}
}


func (p *NoteStoreGetResourceAttributesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetResourceAttributesArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreGetResourceAttributesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAttributesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetResourceAttributesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreGetResourceAttributesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceAttributes_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceAttributesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceAttributesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreGetResourceAttributesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceAttributesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreGetResourceAttributesResult struct {
  Success *ResourceAttributes `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetResourceAttributesResult() *NoteStoreGetResourceAttributesResult {
  return &NoteStoreGetResourceAttributesResult{}
}

var NoteStoreGetResourceAttributesResult_Success_DEFAULT *ResourceAttributes
func (p *NoteStoreGetResourceAttributesResult) GetSuccess() *ResourceAttributes {
  if !p.IsSetSuccess() {
    return NoteStoreGetResourceAttributesResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetResourceAttributesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetResourceAttributesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetResourceAttributesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetResourceAttributesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetResourceAttributesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetResourceAttributesResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetResourceAttributesResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetResourceAttributesResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetResourceAttributesResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetResourceAttributesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetResourceAttributesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetResourceAttributesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetResourceAttributesResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetResourceAttributesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAttributesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &ResourceAttributes{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAttributesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAttributesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAttributesResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetResourceAttributesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getResourceAttributes_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetResourceAttributesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAttributesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAttributesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAttributesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetResourceAttributesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetResourceAttributesResult(%+v)", *p)
}

// Attributes:
//  - UserId
//  - PublicUri
type NoteStoreGetPublicNotebookArgs struct {
  UserId UserID `thrift:"userId,1" db:"userId" json:"userId"`
  PublicUri string `thrift:"publicUri,2" db:"publicUri" json:"publicUri"`
}

func NewNoteStoreGetPublicNotebookArgs() *NoteStoreGetPublicNotebookArgs {
  return &NoteStoreGetPublicNotebookArgs{}
}


func (p *NoteStoreGetPublicNotebookArgs) GetUserId() UserID {
  return p.UserId
}

func (p *NoteStoreGetPublicNotebookArgs) GetPublicUri() string {
  return p.PublicUri
}
func (p *NoteStoreGetPublicNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetPublicNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := UserID(v)
  p.UserId = temp
}
  return nil
}

func (p *NoteStoreGetPublicNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.PublicUri = v
}
  return nil
}

func (p *NoteStoreGetPublicNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPublicNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetPublicNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "userId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UserId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.userId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userId: ", p), err) }
  return err
}

func (p *NoteStoreGetPublicNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "publicUri", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:publicUri: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.PublicUri)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.publicUri (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:publicUri: ", p), err) }
  return err
}

func (p *NoteStoreGetPublicNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetPublicNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - SystemException
//  - NotFoundException
type NoteStoreGetPublicNotebookResult struct {
  Success *Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,1" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreGetPublicNotebookResult() *NoteStoreGetPublicNotebookResult {
  return &NoteStoreGetPublicNotebookResult{}
}

var NoteStoreGetPublicNotebookResult_Success_DEFAULT *Notebook
func (p *NoteStoreGetPublicNotebookResult) GetSuccess() *Notebook {
  if !p.IsSetSuccess() {
    return NoteStoreGetPublicNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetPublicNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetPublicNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetPublicNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreGetPublicNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetPublicNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetPublicNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreGetPublicNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetPublicNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetPublicNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetPublicNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetPublicNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Notebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetPublicNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetPublicNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetPublicNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPublicNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetPublicNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetPublicNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetPublicNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetPublicNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetPublicNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - SharedNotebook
//  - Message
type NoteStoreShareNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  SharedNotebook *SharedNotebook `thrift:"sharedNotebook,2" db:"sharedNotebook" json:"sharedNotebook"`
  Message string `thrift:"message,3" db:"message" json:"message"`
}

func NewNoteStoreShareNotebookArgs() *NoteStoreShareNotebookArgs {
  return &NoteStoreShareNotebookArgs{}
}


func (p *NoteStoreShareNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreShareNotebookArgs_SharedNotebook_DEFAULT *SharedNotebook
func (p *NoteStoreShareNotebookArgs) GetSharedNotebook() *SharedNotebook {
  if !p.IsSetSharedNotebook() {
    return NoteStoreShareNotebookArgs_SharedNotebook_DEFAULT
  }
return p.SharedNotebook
}

func (p *NoteStoreShareNotebookArgs) GetMessage() string {
  return p.Message
}
func (p *NoteStoreShareNotebookArgs) IsSetSharedNotebook() bool {
  return p.SharedNotebook != nil
}

func (p *NoteStoreShareNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreShareNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SharedNotebook = &SharedNotebook{}
  if err := p.SharedNotebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SharedNotebook), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *NoteStoreShareNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shareNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreShareNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreShareNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sharedNotebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sharedNotebook: ", p), err) }
  if err := p.SharedNotebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SharedNotebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sharedNotebook: ", p), err) }
  return err
}

func (p *NoteStoreShareNotebookArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err) }
  return err
}

func (p *NoteStoreShareNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreShareNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreShareNotebookResult struct {
  Success *SharedNotebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreShareNotebookResult() *NoteStoreShareNotebookResult {
  return &NoteStoreShareNotebookResult{}
}

var NoteStoreShareNotebookResult_Success_DEFAULT *SharedNotebook
func (p *NoteStoreShareNotebookResult) GetSuccess() *SharedNotebook {
  if !p.IsSetSuccess() {
    return NoteStoreShareNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreShareNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreShareNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreShareNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreShareNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreShareNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreShareNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreShareNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreShareNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreShareNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreShareNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreShareNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreShareNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreShareNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreShareNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SharedNotebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreShareNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shareNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreShareNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreShareNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - ShareTemplate
type NoteStoreCreateOrUpdateNotebookSharesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  ShareTemplate *NotebookShareTemplate `thrift:"shareTemplate,2" db:"shareTemplate" json:"shareTemplate"`
}

func NewNoteStoreCreateOrUpdateNotebookSharesArgs() *NoteStoreCreateOrUpdateNotebookSharesArgs {
  return &NoteStoreCreateOrUpdateNotebookSharesArgs{}
}


func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreCreateOrUpdateNotebookSharesArgs_ShareTemplate_DEFAULT *NotebookShareTemplate
func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) GetShareTemplate() *NotebookShareTemplate {
  if !p.IsSetShareTemplate() {
    return NoteStoreCreateOrUpdateNotebookSharesArgs_ShareTemplate_DEFAULT
  }
return p.ShareTemplate
}
func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) IsSetShareTemplate() bool {
  return p.ShareTemplate != nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.ShareTemplate = &NotebookShareTemplate{}
  if err := p.ShareTemplate.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ShareTemplate), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createOrUpdateNotebookShares_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "shareTemplate", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:shareTemplate: ", p), err) }
  if err := p.ShareTemplate.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ShareTemplate), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:shareTemplate: ", p), err) }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateOrUpdateNotebookSharesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
//  - InvalidContactsException
type NoteStoreCreateOrUpdateNotebookSharesResult struct {
  Success *CreateOrUpdateNotebookSharesResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
  InvalidContactsException *EDAMInvalidContactsException `thrift:"invalidContactsException,4" db:"invalidContactsException" json:"invalidContactsException,omitempty"`
}

func NewNoteStoreCreateOrUpdateNotebookSharesResult() *NoteStoreCreateOrUpdateNotebookSharesResult {
  return &NoteStoreCreateOrUpdateNotebookSharesResult{}
}

var NoteStoreCreateOrUpdateNotebookSharesResult_Success_DEFAULT *CreateOrUpdateNotebookSharesResult_
func (p *NoteStoreCreateOrUpdateNotebookSharesResult) GetSuccess() *CreateOrUpdateNotebookSharesResult_ {
  if !p.IsSetSuccess() {
    return NoteStoreCreateOrUpdateNotebookSharesResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCreateOrUpdateNotebookSharesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCreateOrUpdateNotebookSharesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCreateOrUpdateNotebookSharesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCreateOrUpdateNotebookSharesResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreCreateOrUpdateNotebookSharesResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreCreateOrUpdateNotebookSharesResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreCreateOrUpdateNotebookSharesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCreateOrUpdateNotebookSharesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCreateOrUpdateNotebookSharesResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreCreateOrUpdateNotebookSharesResult_InvalidContactsException_DEFAULT *EDAMInvalidContactsException
func (p *NoteStoreCreateOrUpdateNotebookSharesResult) GetInvalidContactsException() *EDAMInvalidContactsException {
  if !p.IsSetInvalidContactsException() {
    return NoteStoreCreateOrUpdateNotebookSharesResult_InvalidContactsException_DEFAULT
  }
return p.InvalidContactsException
}
func (p *NoteStoreCreateOrUpdateNotebookSharesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) IsSetInvalidContactsException() bool {
  return p.InvalidContactsException != nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CreateOrUpdateNotebookSharesResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.InvalidContactsException = &EDAMInvalidContactsException{}
  if err := p.InvalidContactsException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.InvalidContactsException), err)
  }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createOrUpdateNotebookShares_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInvalidContactsException() {
    if err := oprot.WriteFieldBegin(ctx, "invalidContactsException", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:invalidContactsException: ", p), err) }
    if err := p.InvalidContactsException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.InvalidContactsException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:invalidContactsException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateOrUpdateNotebookSharesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateOrUpdateNotebookSharesResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - SharedNotebook
type NoteStoreUpdateSharedNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  SharedNotebook *SharedNotebook `thrift:"sharedNotebook,2" db:"sharedNotebook" json:"sharedNotebook"`
}

func NewNoteStoreUpdateSharedNotebookArgs() *NoteStoreUpdateSharedNotebookArgs {
  return &NoteStoreUpdateSharedNotebookArgs{}
}


func (p *NoteStoreUpdateSharedNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateSharedNotebookArgs_SharedNotebook_DEFAULT *SharedNotebook
func (p *NoteStoreUpdateSharedNotebookArgs) GetSharedNotebook() *SharedNotebook {
  if !p.IsSetSharedNotebook() {
    return NoteStoreUpdateSharedNotebookArgs_SharedNotebook_DEFAULT
  }
return p.SharedNotebook
}
func (p *NoteStoreUpdateSharedNotebookArgs) IsSetSharedNotebook() bool {
  return p.SharedNotebook != nil
}

func (p *NoteStoreUpdateSharedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateSharedNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SharedNotebook = &SharedNotebook{}
  if err := p.SharedNotebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SharedNotebook), err)
  }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateSharedNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateSharedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sharedNotebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sharedNotebook: ", p), err) }
  if err := p.SharedNotebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SharedNotebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sharedNotebook: ", p), err) }
  return err
}

func (p *NoteStoreUpdateSharedNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateSharedNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreUpdateSharedNotebookResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreUpdateSharedNotebookResult() *NoteStoreUpdateSharedNotebookResult {
  return &NoteStoreUpdateSharedNotebookResult{}
}

var NoteStoreUpdateSharedNotebookResult_Success_DEFAULT int32
func (p *NoteStoreUpdateSharedNotebookResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateSharedNotebookResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUpdateSharedNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateSharedNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateSharedNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateSharedNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateSharedNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateSharedNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreUpdateSharedNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateSharedNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateSharedNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreUpdateSharedNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateSharedNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateSharedNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateSharedNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateSharedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUpdateSharedNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateSharedNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateSharedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSharedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSharedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSharedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateSharedNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateSharedNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NotebookGuid
//  - RecipientSettings
type NoteStoreSetNotebookRecipientSettingsArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NotebookGuid string `thrift:"notebookGuid,2" db:"notebookGuid" json:"notebookGuid"`
  RecipientSettings *NotebookRecipientSettings `thrift:"recipientSettings,3" db:"recipientSettings" json:"recipientSettings"`
}

func NewNoteStoreSetNotebookRecipientSettingsArgs() *NoteStoreSetNotebookRecipientSettingsArgs {
  return &NoteStoreSetNotebookRecipientSettingsArgs{}
}


func (p *NoteStoreSetNotebookRecipientSettingsArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) GetNotebookGuid() string {
  return p.NotebookGuid
}
var NoteStoreSetNotebookRecipientSettingsArgs_RecipientSettings_DEFAULT *NotebookRecipientSettings
func (p *NoteStoreSetNotebookRecipientSettingsArgs) GetRecipientSettings() *NotebookRecipientSettings {
  if !p.IsSetRecipientSettings() {
    return NoteStoreSetNotebookRecipientSettingsArgs_RecipientSettings_DEFAULT
  }
return p.RecipientSettings
}
func (p *NoteStoreSetNotebookRecipientSettingsArgs) IsSetRecipientSettings() bool {
  return p.RecipientSettings != nil
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NotebookGuid = v
}
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.RecipientSettings = &NotebookRecipientSettings{}
  if err := p.RecipientSettings.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RecipientSettings), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setNotebookRecipientSettings_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notebookGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NotebookGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notebookGuid: ", p), err) }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "recipientSettings", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:recipientSettings: ", p), err) }
  if err := p.RecipientSettings.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RecipientSettings), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:recipientSettings: ", p), err) }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreSetNotebookRecipientSettingsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreSetNotebookRecipientSettingsResult struct {
  Success *Notebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreSetNotebookRecipientSettingsResult() *NoteStoreSetNotebookRecipientSettingsResult {
  return &NoteStoreSetNotebookRecipientSettingsResult{}
}

var NoteStoreSetNotebookRecipientSettingsResult_Success_DEFAULT *Notebook
func (p *NoteStoreSetNotebookRecipientSettingsResult) GetSuccess() *Notebook {
  if !p.IsSetSuccess() {
    return NoteStoreSetNotebookRecipientSettingsResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreSetNotebookRecipientSettingsResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreSetNotebookRecipientSettingsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreSetNotebookRecipientSettingsResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreSetNotebookRecipientSettingsResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreSetNotebookRecipientSettingsResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreSetNotebookRecipientSettingsResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreSetNotebookRecipientSettingsResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreSetNotebookRecipientSettingsResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreSetNotebookRecipientSettingsResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreSetNotebookRecipientSettingsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Notebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setNotebookRecipientSettings_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreSetNotebookRecipientSettingsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreSetNotebookRecipientSettingsResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreListSharedNotebooksArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreListSharedNotebooksArgs() *NoteStoreListSharedNotebooksArgs {
  return &NoteStoreListSharedNotebooksArgs{}
}


func (p *NoteStoreListSharedNotebooksArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreListSharedNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListSharedNotebooksArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListSharedNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listSharedNotebooks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListSharedNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListSharedNotebooksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListSharedNotebooksArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreListSharedNotebooksResult struct {
  Success []*SharedNotebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreListSharedNotebooksResult() *NoteStoreListSharedNotebooksResult {
  return &NoteStoreListSharedNotebooksResult{}
}

var NoteStoreListSharedNotebooksResult_Success_DEFAULT []*SharedNotebook

func (p *NoteStoreListSharedNotebooksResult) GetSuccess() []*SharedNotebook {
  return p.Success
}
var NoteStoreListSharedNotebooksResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListSharedNotebooksResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListSharedNotebooksResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListSharedNotebooksResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreListSharedNotebooksResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreListSharedNotebooksResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreListSharedNotebooksResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListSharedNotebooksResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListSharedNotebooksResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreListSharedNotebooksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListSharedNotebooksResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListSharedNotebooksResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreListSharedNotebooksResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListSharedNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListSharedNotebooksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SharedNotebook, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem363 := &SharedNotebook{}
    if err := _elem363.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem363), err)
    }
    p.Success = append(p.Success, _elem363)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListSharedNotebooksResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListSharedNotebooksResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreListSharedNotebooksResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListSharedNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listSharedNotebooks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListSharedNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSharedNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSharedNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSharedNotebooksResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListSharedNotebooksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListSharedNotebooksResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - LinkedNotebook
type NoteStoreCreateLinkedNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  LinkedNotebook *LinkedNotebook `thrift:"linkedNotebook,2" db:"linkedNotebook" json:"linkedNotebook"`
}

func NewNoteStoreCreateLinkedNotebookArgs() *NoteStoreCreateLinkedNotebookArgs {
  return &NoteStoreCreateLinkedNotebookArgs{}
}


func (p *NoteStoreCreateLinkedNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreCreateLinkedNotebookArgs_LinkedNotebook_DEFAULT *LinkedNotebook
func (p *NoteStoreCreateLinkedNotebookArgs) GetLinkedNotebook() *LinkedNotebook {
  if !p.IsSetLinkedNotebook() {
    return NoteStoreCreateLinkedNotebookArgs_LinkedNotebook_DEFAULT
  }
return p.LinkedNotebook
}
func (p *NoteStoreCreateLinkedNotebookArgs) IsSetLinkedNotebook() bool {
  return p.LinkedNotebook != nil
}

func (p *NoteStoreCreateLinkedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreCreateLinkedNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.LinkedNotebook = &LinkedNotebook{}
  if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LinkedNotebook), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createLinkedNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreCreateLinkedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:linkedNotebook: ", p), err) }
  if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LinkedNotebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:linkedNotebook: ", p), err) }
  return err
}

func (p *NoteStoreCreateLinkedNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateLinkedNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreCreateLinkedNotebookResult struct {
  Success *LinkedNotebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreCreateLinkedNotebookResult() *NoteStoreCreateLinkedNotebookResult {
  return &NoteStoreCreateLinkedNotebookResult{}
}

var NoteStoreCreateLinkedNotebookResult_Success_DEFAULT *LinkedNotebook
func (p *NoteStoreCreateLinkedNotebookResult) GetSuccess() *LinkedNotebook {
  if !p.IsSetSuccess() {
    return NoteStoreCreateLinkedNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreCreateLinkedNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreCreateLinkedNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreCreateLinkedNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreCreateLinkedNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreCreateLinkedNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreCreateLinkedNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreCreateLinkedNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreCreateLinkedNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreCreateLinkedNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreCreateLinkedNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreCreateLinkedNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreCreateLinkedNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreCreateLinkedNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreCreateLinkedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &LinkedNotebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createLinkedNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreCreateLinkedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateLinkedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateLinkedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateLinkedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreCreateLinkedNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreCreateLinkedNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - LinkedNotebook
type NoteStoreUpdateLinkedNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  LinkedNotebook *LinkedNotebook `thrift:"linkedNotebook,2" db:"linkedNotebook" json:"linkedNotebook"`
}

func NewNoteStoreUpdateLinkedNotebookArgs() *NoteStoreUpdateLinkedNotebookArgs {
  return &NoteStoreUpdateLinkedNotebookArgs{}
}


func (p *NoteStoreUpdateLinkedNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateLinkedNotebookArgs_LinkedNotebook_DEFAULT *LinkedNotebook
func (p *NoteStoreUpdateLinkedNotebookArgs) GetLinkedNotebook() *LinkedNotebook {
  if !p.IsSetLinkedNotebook() {
    return NoteStoreUpdateLinkedNotebookArgs_LinkedNotebook_DEFAULT
  }
return p.LinkedNotebook
}
func (p *NoteStoreUpdateLinkedNotebookArgs) IsSetLinkedNotebook() bool {
  return p.LinkedNotebook != nil
}

func (p *NoteStoreUpdateLinkedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.LinkedNotebook = &LinkedNotebook{}
  if err := p.LinkedNotebook.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LinkedNotebook), err)
  }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateLinkedNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateLinkedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "linkedNotebook", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:linkedNotebook: ", p), err) }
  if err := p.LinkedNotebook.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LinkedNotebook), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:linkedNotebook: ", p), err) }
  return err
}

func (p *NoteStoreUpdateLinkedNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateLinkedNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreUpdateLinkedNotebookResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreUpdateLinkedNotebookResult() *NoteStoreUpdateLinkedNotebookResult {
  return &NoteStoreUpdateLinkedNotebookResult{}
}

var NoteStoreUpdateLinkedNotebookResult_Success_DEFAULT int32
func (p *NoteStoreUpdateLinkedNotebookResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateLinkedNotebookResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreUpdateLinkedNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateLinkedNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateLinkedNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateLinkedNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateLinkedNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateLinkedNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreUpdateLinkedNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateLinkedNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateLinkedNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreUpdateLinkedNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateLinkedNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateLinkedNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateLinkedNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateLinkedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateLinkedNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateLinkedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateLinkedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateLinkedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateLinkedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateLinkedNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateLinkedNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreListLinkedNotebooksArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreListLinkedNotebooksArgs() *NoteStoreListLinkedNotebooksArgs {
  return &NoteStoreListLinkedNotebooksArgs{}
}


func (p *NoteStoreListLinkedNotebooksArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreListLinkedNotebooksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListLinkedNotebooksArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreListLinkedNotebooksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listLinkedNotebooks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListLinkedNotebooksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreListLinkedNotebooksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListLinkedNotebooksArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreListLinkedNotebooksResult struct {
  Success []*LinkedNotebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreListLinkedNotebooksResult() *NoteStoreListLinkedNotebooksResult {
  return &NoteStoreListLinkedNotebooksResult{}
}

var NoteStoreListLinkedNotebooksResult_Success_DEFAULT []*LinkedNotebook

func (p *NoteStoreListLinkedNotebooksResult) GetSuccess() []*LinkedNotebook {
  return p.Success
}
var NoteStoreListLinkedNotebooksResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreListLinkedNotebooksResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreListLinkedNotebooksResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreListLinkedNotebooksResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreListLinkedNotebooksResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreListLinkedNotebooksResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreListLinkedNotebooksResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreListLinkedNotebooksResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreListLinkedNotebooksResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreListLinkedNotebooksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreListLinkedNotebooksResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreListLinkedNotebooksResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreListLinkedNotebooksResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreListLinkedNotebooksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreListLinkedNotebooksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*LinkedNotebook, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem364 := &LinkedNotebook{}
    if err := _elem364.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem364), err)
    }
    p.Success = append(p.Success, _elem364)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NoteStoreListLinkedNotebooksResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreListLinkedNotebooksResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreListLinkedNotebooksResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreListLinkedNotebooksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listLinkedNotebooks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreListLinkedNotebooksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreListLinkedNotebooksResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListLinkedNotebooksResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListLinkedNotebooksResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreListLinkedNotebooksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreListLinkedNotebooksResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreExpungeLinkedNotebookArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreExpungeLinkedNotebookArgs() *NoteStoreExpungeLinkedNotebookArgs {
  return &NoteStoreExpungeLinkedNotebookArgs{}
}


func (p *NoteStoreExpungeLinkedNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreExpungeLinkedNotebookArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreExpungeLinkedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeLinkedNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreExpungeLinkedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreExpungeLinkedNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeLinkedNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreExpungeLinkedNotebookResult struct {
  Success *int32 `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreExpungeLinkedNotebookResult() *NoteStoreExpungeLinkedNotebookResult {
  return &NoteStoreExpungeLinkedNotebookResult{}
}

var NoteStoreExpungeLinkedNotebookResult_Success_DEFAULT int32
func (p *NoteStoreExpungeLinkedNotebookResult) GetSuccess() int32 {
  if !p.IsSetSuccess() {
    return NoteStoreExpungeLinkedNotebookResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreExpungeLinkedNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreExpungeLinkedNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreExpungeLinkedNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreExpungeLinkedNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreExpungeLinkedNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreExpungeLinkedNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreExpungeLinkedNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreExpungeLinkedNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreExpungeLinkedNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreExpungeLinkedNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreExpungeLinkedNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreExpungeLinkedNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreExpungeLinkedNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreExpungeLinkedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "expungeLinkedNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreExpungeLinkedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I32, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeLinkedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeLinkedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeLinkedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreExpungeLinkedNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreExpungeLinkedNotebookResult(%+v)", *p)
}

// Attributes:
//  - ShareKeyOrGlobalId
//  - AuthenticationToken
type NoteStoreAuthenticateToSharedNotebookArgs struct {
  ShareKeyOrGlobalId string `thrift:"shareKeyOrGlobalId,1" db:"shareKeyOrGlobalId" json:"shareKeyOrGlobalId"`
  AuthenticationToken string `thrift:"authenticationToken,2" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreAuthenticateToSharedNotebookArgs() *NoteStoreAuthenticateToSharedNotebookArgs {
  return &NoteStoreAuthenticateToSharedNotebookArgs{}
}


func (p *NoteStoreAuthenticateToSharedNotebookArgs) GetShareKeyOrGlobalId() string {
  return p.ShareKeyOrGlobalId
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreAuthenticateToSharedNotebookArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ShareKeyOrGlobalId = v
}
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNotebook_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "shareKeyOrGlobalId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:shareKeyOrGlobalId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ShareKeyOrGlobalId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.shareKeyOrGlobalId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:shareKeyOrGlobalId: ", p), err) }
  return err
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreAuthenticateToSharedNotebookArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreAuthenticateToSharedNotebookArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreAuthenticateToSharedNotebookResult struct {
  Success *AuthenticationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreAuthenticateToSharedNotebookResult() *NoteStoreAuthenticateToSharedNotebookResult {
  return &NoteStoreAuthenticateToSharedNotebookResult{}
}

var NoteStoreAuthenticateToSharedNotebookResult_Success_DEFAULT *AuthenticationResult_
func (p *NoteStoreAuthenticateToSharedNotebookResult) GetSuccess() *AuthenticationResult_ {
  if !p.IsSetSuccess() {
    return NoteStoreAuthenticateToSharedNotebookResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreAuthenticateToSharedNotebookResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreAuthenticateToSharedNotebookResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreAuthenticateToSharedNotebookResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreAuthenticateToSharedNotebookResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreAuthenticateToSharedNotebookResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreAuthenticateToSharedNotebookResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreAuthenticateToSharedNotebookResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreAuthenticateToSharedNotebookResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreAuthenticateToSharedNotebookResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreAuthenticateToSharedNotebookResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &AuthenticationResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNotebook_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNotebookResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreAuthenticateToSharedNotebookResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type NoteStoreGetSharedNotebookByAuthArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreGetSharedNotebookByAuthArgs() *NoteStoreGetSharedNotebookByAuthArgs {
  return &NoteStoreGetSharedNotebookByAuthArgs{}
}


func (p *NoteStoreGetSharedNotebookByAuthArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreGetSharedNotebookByAuthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSharedNotebookByAuth_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetSharedNotebookByAuthArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetSharedNotebookByAuthArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreGetSharedNotebookByAuthResult struct {
  Success *SharedNotebook `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreGetSharedNotebookByAuthResult() *NoteStoreGetSharedNotebookByAuthResult {
  return &NoteStoreGetSharedNotebookByAuthResult{}
}

var NoteStoreGetSharedNotebookByAuthResult_Success_DEFAULT *SharedNotebook
func (p *NoteStoreGetSharedNotebookByAuthResult) GetSuccess() *SharedNotebook {
  if !p.IsSetSuccess() {
    return NoteStoreGetSharedNotebookByAuthResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetSharedNotebookByAuthResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetSharedNotebookByAuthResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetSharedNotebookByAuthResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetSharedNotebookByAuthResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetSharedNotebookByAuthResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetSharedNotebookByAuthResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreGetSharedNotebookByAuthResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetSharedNotebookByAuthResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetSharedNotebookByAuthResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreGetSharedNotebookByAuthResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &SharedNotebook{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getSharedNotebookByAuth_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetSharedNotebookByAuthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSharedNotebookByAuthResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSharedNotebookByAuthResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSharedNotebookByAuthResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetSharedNotebookByAuthResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetSharedNotebookByAuthResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Parameters
type NoteStoreEmailNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Parameters *NoteEmailParameters `thrift:"parameters,2" db:"parameters" json:"parameters"`
}

func NewNoteStoreEmailNoteArgs() *NoteStoreEmailNoteArgs {
  return &NoteStoreEmailNoteArgs{}
}


func (p *NoteStoreEmailNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreEmailNoteArgs_Parameters_DEFAULT *NoteEmailParameters
func (p *NoteStoreEmailNoteArgs) GetParameters() *NoteEmailParameters {
  if !p.IsSetParameters() {
    return NoteStoreEmailNoteArgs_Parameters_DEFAULT
  }
return p.Parameters
}
func (p *NoteStoreEmailNoteArgs) IsSetParameters() bool {
  return p.Parameters != nil
}

func (p *NoteStoreEmailNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreEmailNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreEmailNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Parameters = &NoteEmailParameters{}
  if err := p.Parameters.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Parameters), err)
  }
  return nil
}

func (p *NoteStoreEmailNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "emailNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreEmailNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreEmailNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "parameters", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:parameters: ", p), err) }
  if err := p.Parameters.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Parameters), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:parameters: ", p), err) }
  return err
}

func (p *NoteStoreEmailNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreEmailNoteArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreEmailNoteResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreEmailNoteResult() *NoteStoreEmailNoteResult {
  return &NoteStoreEmailNoteResult{}
}

var NoteStoreEmailNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreEmailNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreEmailNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreEmailNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreEmailNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreEmailNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreEmailNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreEmailNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreEmailNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreEmailNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreEmailNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreEmailNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreEmailNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreEmailNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreEmailNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreEmailNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreEmailNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "emailNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreEmailNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreEmailNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreEmailNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreEmailNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreEmailNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreShareNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreShareNoteArgs() *NoteStoreShareNoteArgs {
  return &NoteStoreShareNoteArgs{}
}


func (p *NoteStoreShareNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreShareNoteArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreShareNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreShareNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreShareNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreShareNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shareNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreShareNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreShareNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreShareNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreShareNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreShareNoteResult struct {
  Success *string `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreShareNoteResult() *NoteStoreShareNoteResult {
  return &NoteStoreShareNoteResult{}
}

var NoteStoreShareNoteResult_Success_DEFAULT string
func (p *NoteStoreShareNoteResult) GetSuccess() string {
  if !p.IsSetSuccess() {
    return NoteStoreShareNoteResult_Success_DEFAULT
  }
return *p.Success
}
var NoteStoreShareNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreShareNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreShareNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreShareNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreShareNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreShareNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreShareNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreShareNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreShareNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreShareNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreShareNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreShareNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreShareNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreShareNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreShareNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *NoteStoreShareNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreShareNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreShareNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreShareNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "shareNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreShareNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRING, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreShareNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreShareNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - GUID
type NoteStoreStopSharingNoteArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  GUID GUID `thrift:"guid,2" db:"guid" json:"guid"`
}

func NewNoteStoreStopSharingNoteArgs() *NoteStoreStopSharingNoteArgs {
  return &NoteStoreStopSharingNoteArgs{}
}


func (p *NoteStoreStopSharingNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreStopSharingNoteArgs) GetGUID() GUID {
  return p.GUID
}
func (p *NoteStoreStopSharingNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreStopSharingNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreStopSharingNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := GUID(v)
  p.GUID = temp
}
  return nil
}

func (p *NoteStoreStopSharingNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "stopSharingNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreStopSharingNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreStopSharingNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:guid: ", p), err) }
  return err
}

func (p *NoteStoreStopSharingNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreStopSharingNoteArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreStopSharingNoteResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreStopSharingNoteResult() *NoteStoreStopSharingNoteResult {
  return &NoteStoreStopSharingNoteResult{}
}

var NoteStoreStopSharingNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreStopSharingNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreStopSharingNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreStopSharingNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreStopSharingNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreStopSharingNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreStopSharingNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreStopSharingNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreStopSharingNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreStopSharingNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreStopSharingNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreStopSharingNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreStopSharingNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreStopSharingNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreStopSharingNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreStopSharingNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreStopSharingNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "stopSharingNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreStopSharingNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreStopSharingNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreStopSharingNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreStopSharingNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreStopSharingNoteResult(%+v)", *p)
}

// Attributes:
//  - GUID
//  - NoteKey
//  - AuthenticationToken
type NoteStoreAuthenticateToSharedNoteArgs struct {
  GUID string `thrift:"guid,1" db:"guid" json:"guid"`
  NoteKey string `thrift:"noteKey,2" db:"noteKey" json:"noteKey"`
  AuthenticationToken string `thrift:"authenticationToken,3" db:"authenticationToken" json:"authenticationToken"`
}

func NewNoteStoreAuthenticateToSharedNoteArgs() *NoteStoreAuthenticateToSharedNoteArgs {
  return &NoteStoreAuthenticateToSharedNoteArgs{}
}


func (p *NoteStoreAuthenticateToSharedNoteArgs) GetGUID() string {
  return p.GUID
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) GetNoteKey() string {
  return p.NoteKey
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *NoteStoreAuthenticateToSharedNoteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.GUID = v
}
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NoteKey = v
}
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNote_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "guid", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:guid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.GUID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.guid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:guid: ", p), err) }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "noteKey", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:noteKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NoteKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.noteKey (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:noteKey: ", p), err) }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreAuthenticateToSharedNoteArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreAuthenticateToSharedNoteResult struct {
  Success *AuthenticationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreAuthenticateToSharedNoteResult() *NoteStoreAuthenticateToSharedNoteResult {
  return &NoteStoreAuthenticateToSharedNoteResult{}
}

var NoteStoreAuthenticateToSharedNoteResult_Success_DEFAULT *AuthenticationResult_
func (p *NoteStoreAuthenticateToSharedNoteResult) GetSuccess() *AuthenticationResult_ {
  if !p.IsSetSuccess() {
    return NoteStoreAuthenticateToSharedNoteResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreAuthenticateToSharedNoteResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreAuthenticateToSharedNoteResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreAuthenticateToSharedNoteResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreAuthenticateToSharedNoteResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreAuthenticateToSharedNoteResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreAuthenticateToSharedNoteResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreAuthenticateToSharedNoteResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreAuthenticateToSharedNoteResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreAuthenticateToSharedNoteResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreAuthenticateToSharedNoteResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &AuthenticationResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateToSharedNote_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreAuthenticateToSharedNoteResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreAuthenticateToSharedNoteResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreAuthenticateToSharedNoteResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Query
//  - ResultSpec
type NoteStoreFindRelatedArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Query *RelatedQuery `thrift:"query,2" db:"query" json:"query"`
  ResultSpec *RelatedResultSpec `thrift:"resultSpec,3" db:"resultSpec" json:"resultSpec"`
}

func NewNoteStoreFindRelatedArgs() *NoteStoreFindRelatedArgs {
  return &NoteStoreFindRelatedArgs{}
}


func (p *NoteStoreFindRelatedArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreFindRelatedArgs_Query_DEFAULT *RelatedQuery
func (p *NoteStoreFindRelatedArgs) GetQuery() *RelatedQuery {
  if !p.IsSetQuery() {
    return NoteStoreFindRelatedArgs_Query_DEFAULT
  }
return p.Query
}
var NoteStoreFindRelatedArgs_ResultSpec_DEFAULT *RelatedResultSpec
func (p *NoteStoreFindRelatedArgs) GetResultSpec() *RelatedResultSpec {
  if !p.IsSetResultSpec() {
    return NoteStoreFindRelatedArgs_ResultSpec_DEFAULT
  }
return p.ResultSpec
}
func (p *NoteStoreFindRelatedArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *NoteStoreFindRelatedArgs) IsSetResultSpec() bool {
  return p.ResultSpec != nil
}

func (p *NoteStoreFindRelatedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreFindRelatedArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &RelatedQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.ResultSpec = &RelatedResultSpec{}
  if err := p.ResultSpec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ResultSpec), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findRelated_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindRelatedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreFindRelatedArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:query: ", p), err) }
  return err
}

func (p *NoteStoreFindRelatedArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resultSpec", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:resultSpec: ", p), err) }
  if err := p.ResultSpec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ResultSpec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:resultSpec: ", p), err) }
  return err
}

func (p *NoteStoreFindRelatedArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindRelatedArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
//  - NotFoundException
type NoteStoreFindRelatedResult struct {
  Success *RelatedResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewNoteStoreFindRelatedResult() *NoteStoreFindRelatedResult {
  return &NoteStoreFindRelatedResult{}
}

var NoteStoreFindRelatedResult_Success_DEFAULT *RelatedResult_
func (p *NoteStoreFindRelatedResult) GetSuccess() *RelatedResult_ {
  if !p.IsSetSuccess() {
    return NoteStoreFindRelatedResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreFindRelatedResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreFindRelatedResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreFindRelatedResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreFindRelatedResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreFindRelatedResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreFindRelatedResult_SystemException_DEFAULT
  }
return p.SystemException
}
var NoteStoreFindRelatedResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreFindRelatedResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreFindRelatedResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *NoteStoreFindRelatedResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreFindRelatedResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreFindRelatedResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreFindRelatedResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreFindRelatedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &RelatedResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreFindRelatedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "findRelated_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreFindRelatedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindRelatedResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindRelatedResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindRelatedResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreFindRelatedResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreFindRelatedResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Note
type NoteStoreUpdateNoteIfUsnMatchesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Note *Note `thrift:"note,2" db:"note" json:"note"`
}

func NewNoteStoreUpdateNoteIfUsnMatchesArgs() *NoteStoreUpdateNoteIfUsnMatchesArgs {
  return &NoteStoreUpdateNoteIfUsnMatchesArgs{}
}


func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreUpdateNoteIfUsnMatchesArgs_Note_DEFAULT *Note
func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) GetNote() *Note {
  if !p.IsSetNote() {
    return NoteStoreUpdateNoteIfUsnMatchesArgs_Note_DEFAULT
  }
return p.Note
}
func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) IsSetNote() bool {
  return p.Note != nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Note = &Note{}
  if err := p.Note.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Note), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateNoteIfUsnMatches_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "note", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:note: ", p), err) }
  if err := p.Note.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Note), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:note: ", p), err) }
  return err
}

func (p *NoteStoreUpdateNoteIfUsnMatchesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateNoteIfUsnMatchesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreUpdateNoteIfUsnMatchesResult struct {
  Success *UpdateNoteIfUsnMatchesResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreUpdateNoteIfUsnMatchesResult() *NoteStoreUpdateNoteIfUsnMatchesResult {
  return &NoteStoreUpdateNoteIfUsnMatchesResult{}
}

var NoteStoreUpdateNoteIfUsnMatchesResult_Success_DEFAULT *UpdateNoteIfUsnMatchesResult_
func (p *NoteStoreUpdateNoteIfUsnMatchesResult) GetSuccess() *UpdateNoteIfUsnMatchesResult_ {
  if !p.IsSetSuccess() {
    return NoteStoreUpdateNoteIfUsnMatchesResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreUpdateNoteIfUsnMatchesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreUpdateNoteIfUsnMatchesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreUpdateNoteIfUsnMatchesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreUpdateNoteIfUsnMatchesResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreUpdateNoteIfUsnMatchesResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreUpdateNoteIfUsnMatchesResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreUpdateNoteIfUsnMatchesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreUpdateNoteIfUsnMatchesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreUpdateNoteIfUsnMatchesResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreUpdateNoteIfUsnMatchesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &UpdateNoteIfUsnMatchesResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateNoteIfUsnMatches_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreUpdateNoteIfUsnMatchesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreUpdateNoteIfUsnMatchesResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - Parameters
type NoteStoreManageNotebookSharesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  Parameters *ManageNotebookSharesParameters `thrift:"parameters,2" db:"parameters" json:"parameters"`
}

func NewNoteStoreManageNotebookSharesArgs() *NoteStoreManageNotebookSharesArgs {
  return &NoteStoreManageNotebookSharesArgs{}
}


func (p *NoteStoreManageNotebookSharesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
var NoteStoreManageNotebookSharesArgs_Parameters_DEFAULT *ManageNotebookSharesParameters
func (p *NoteStoreManageNotebookSharesArgs) GetParameters() *ManageNotebookSharesParameters {
  if !p.IsSetParameters() {
    return NoteStoreManageNotebookSharesArgs_Parameters_DEFAULT
  }
return p.Parameters
}
func (p *NoteStoreManageNotebookSharesArgs) IsSetParameters() bool {
  return p.Parameters != nil
}

func (p *NoteStoreManageNotebookSharesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreManageNotebookSharesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Parameters = &ManageNotebookSharesParameters{}
  if err := p.Parameters.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Parameters), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "manageNotebookShares_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreManageNotebookSharesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreManageNotebookSharesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "parameters", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:parameters: ", p), err) }
  if err := p.Parameters.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Parameters), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:parameters: ", p), err) }
  return err
}

func (p *NoteStoreManageNotebookSharesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreManageNotebookSharesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreManageNotebookSharesResult struct {
  Success *ManageNotebookSharesResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreManageNotebookSharesResult() *NoteStoreManageNotebookSharesResult {
  return &NoteStoreManageNotebookSharesResult{}
}

var NoteStoreManageNotebookSharesResult_Success_DEFAULT *ManageNotebookSharesResult_
func (p *NoteStoreManageNotebookSharesResult) GetSuccess() *ManageNotebookSharesResult_ {
  if !p.IsSetSuccess() {
    return NoteStoreManageNotebookSharesResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreManageNotebookSharesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreManageNotebookSharesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreManageNotebookSharesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreManageNotebookSharesResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreManageNotebookSharesResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreManageNotebookSharesResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreManageNotebookSharesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreManageNotebookSharesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreManageNotebookSharesResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreManageNotebookSharesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreManageNotebookSharesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreManageNotebookSharesResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreManageNotebookSharesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreManageNotebookSharesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &ManageNotebookSharesResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreManageNotebookSharesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "manageNotebookShares_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreManageNotebookSharesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreManageNotebookSharesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreManageNotebookSharesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreManageNotebookSharesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreManageNotebookSharesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreManageNotebookSharesResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - NotebookGuid
type NoteStoreGetNotebookSharesArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  NotebookGuid string `thrift:"notebookGuid,2" db:"notebookGuid" json:"notebookGuid"`
}

func NewNoteStoreGetNotebookSharesArgs() *NoteStoreGetNotebookSharesArgs {
  return &NoteStoreGetNotebookSharesArgs{}
}


func (p *NoteStoreGetNotebookSharesArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *NoteStoreGetNotebookSharesArgs) GetNotebookGuid() string {
  return p.NotebookGuid
}
func (p *NoteStoreGetNotebookSharesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookSharesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *NoteStoreGetNotebookSharesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.NotebookGuid = v
}
  return nil
}

func (p *NoteStoreGetNotebookSharesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNotebookShares_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNotebookSharesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *NoteStoreGetNotebookSharesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "notebookGuid", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notebookGuid: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NotebookGuid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.notebookGuid (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notebookGuid: ", p), err) }
  return err
}

func (p *NoteStoreGetNotebookSharesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNotebookSharesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - NotFoundException
//  - SystemException
type NoteStoreGetNotebookSharesResult struct {
  Success *ShareRelationships `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,2" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,3" db:"systemException" json:"systemException,omitempty"`
}

func NewNoteStoreGetNotebookSharesResult() *NoteStoreGetNotebookSharesResult {
  return &NoteStoreGetNotebookSharesResult{}
}

var NoteStoreGetNotebookSharesResult_Success_DEFAULT *ShareRelationships
func (p *NoteStoreGetNotebookSharesResult) GetSuccess() *ShareRelationships {
  if !p.IsSetSuccess() {
    return NoteStoreGetNotebookSharesResult_Success_DEFAULT
  }
return p.Success
}
var NoteStoreGetNotebookSharesResult_UserException_DEFAULT *EDAMUserException
func (p *NoteStoreGetNotebookSharesResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return NoteStoreGetNotebookSharesResult_UserException_DEFAULT
  }
return p.UserException
}
var NoteStoreGetNotebookSharesResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *NoteStoreGetNotebookSharesResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return NoteStoreGetNotebookSharesResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var NoteStoreGetNotebookSharesResult_SystemException_DEFAULT *EDAMSystemException
func (p *NoteStoreGetNotebookSharesResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return NoteStoreGetNotebookSharesResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *NoteStoreGetNotebookSharesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *NoteStoreGetNotebookSharesResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *NoteStoreGetNotebookSharesResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *NoteStoreGetNotebookSharesResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *NoteStoreGetNotebookSharesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookSharesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &ShareRelationships{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookSharesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookSharesResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookSharesResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *NoteStoreGetNotebookSharesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getNotebookShares_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoteStoreGetNotebookSharesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookSharesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookSharesResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:notFoundException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookSharesResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:systemException: ", p), err) }
  }
  return err
}

func (p *NoteStoreGetNotebookSharesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NoteStoreGetNotebookSharesResult(%+v)", *p)
}


