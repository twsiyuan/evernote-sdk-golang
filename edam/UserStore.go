// Code generated by Thrift Compiler (0.16.0). DO NOT EDIT.

package edam

import (
	"bytes"
	"context"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

//  This structure is used to provide publicly-available user information
//  about a particular account.
// <dl>
//  <dt>userId:</dt>
//    <dd>
//    The unique numeric user identifier for the user account.
//    </dd>
//  <dt>serviceLevel:</dt>
//    <dd>
//    The service level of the account.
//    </dd>
//  <dt>noteStoreUrl:</dt>
//    <dd>
//    This field will contain the full URL that clients should use to make
//    NoteStore requests to the server shard that contains that user's data.
//    I.e. this is the URL that should be used to create the Thrift HTTP client
//    transport to send messages to the NoteStore service for the account.
//    </dd>
//  <dt>webApiUrlPrefix:</dt>
//    <dd>
//    This field will contain the initial part of the URLs that should be used
//    to make requests to Evernote's thin client "web API", which provide
//    optimized operations for clients that aren't capable of manipulating
//    the full contents of accounts via the full Thrift data model. Clients
//    should concatenate the relative path for the various servlets onto the
//    end of this string to construct the full URL, as documented on our
//    developer web site.
//    </dd>
//  </dl>
// 
// Attributes:
//  - UserId
//  - ServiceLevel
//  - Username
//  - NoteStoreUrl
//  - WebApiUrlPrefix
type PublicUserInfo struct {
  UserId UserID `thrift:"userId,1,required" db:"userId" json:"userId"`
  // unused fields # 2 to 3
  Username *string `thrift:"username,4" db:"username" json:"username,omitempty"`
  NoteStoreUrl *string `thrift:"noteStoreUrl,5" db:"noteStoreUrl" json:"noteStoreUrl,omitempty"`
  WebApiUrlPrefix *string `thrift:"webApiUrlPrefix,6" db:"webApiUrlPrefix" json:"webApiUrlPrefix,omitempty"`
  ServiceLevel *ServiceLevel `thrift:"serviceLevel,7" db:"serviceLevel" json:"serviceLevel,omitempty"`
}

func NewPublicUserInfo() *PublicUserInfo {
  return &PublicUserInfo{}
}


func (p *PublicUserInfo) GetUserId() UserID {
  return p.UserId
}
var PublicUserInfo_ServiceLevel_DEFAULT ServiceLevel
func (p *PublicUserInfo) GetServiceLevel() ServiceLevel {
  if !p.IsSetServiceLevel() {
    return PublicUserInfo_ServiceLevel_DEFAULT
  }
return *p.ServiceLevel
}
var PublicUserInfo_Username_DEFAULT string
func (p *PublicUserInfo) GetUsername() string {
  if !p.IsSetUsername() {
    return PublicUserInfo_Username_DEFAULT
  }
return *p.Username
}
var PublicUserInfo_NoteStoreUrl_DEFAULT string
func (p *PublicUserInfo) GetNoteStoreUrl() string {
  if !p.IsSetNoteStoreUrl() {
    return PublicUserInfo_NoteStoreUrl_DEFAULT
  }
return *p.NoteStoreUrl
}
var PublicUserInfo_WebApiUrlPrefix_DEFAULT string
func (p *PublicUserInfo) GetWebApiUrlPrefix() string {
  if !p.IsSetWebApiUrlPrefix() {
    return PublicUserInfo_WebApiUrlPrefix_DEFAULT
  }
return *p.WebApiUrlPrefix
}
func (p *PublicUserInfo) IsSetServiceLevel() bool {
  return p.ServiceLevel != nil
}

func (p *PublicUserInfo) IsSetUsername() bool {
  return p.Username != nil
}

func (p *PublicUserInfo) IsSetNoteStoreUrl() bool {
  return p.NoteStoreUrl != nil
}

func (p *PublicUserInfo) IsSetWebApiUrlPrefix() bool {
  return p.WebApiUrlPrefix != nil
}

func (p *PublicUserInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetUserId bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetUserId = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetUserId{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field UserId is not set"));
  }
  return nil
}

func (p *PublicUserInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := UserID(v)
  p.UserId = temp
}
  return nil
}

func (p *PublicUserInfo)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  temp := ServiceLevel(v)
  p.ServiceLevel = &temp
}
  return nil
}

func (p *PublicUserInfo)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Username = &v
}
  return nil
}

func (p *PublicUserInfo)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.NoteStoreUrl = &v
}
  return nil
}

func (p *PublicUserInfo)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.WebApiUrlPrefix = &v
}
  return nil
}

func (p *PublicUserInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PublicUserInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PublicUserInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "userId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UserId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.userId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userId: ", p), err) }
  return err
}

func (p *PublicUserInfo) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUsername() {
    if err := oprot.WriteFieldBegin(ctx, "username", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:username: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Username)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.username (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:username: ", p), err) }
  }
  return err
}

func (p *PublicUserInfo) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoteStoreUrl() {
    if err := oprot.WriteFieldBegin(ctx, "noteStoreUrl", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:noteStoreUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NoteStoreUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noteStoreUrl (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:noteStoreUrl: ", p), err) }
  }
  return err
}

func (p *PublicUserInfo) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetWebApiUrlPrefix() {
    if err := oprot.WriteFieldBegin(ctx, "webApiUrlPrefix", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:webApiUrlPrefix: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.WebApiUrlPrefix)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.webApiUrlPrefix (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:webApiUrlPrefix: ", p), err) }
  }
  return err
}

func (p *PublicUserInfo) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetServiceLevel() {
    if err := oprot.WriteFieldBegin(ctx, "serviceLevel", thrift.I32, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:serviceLevel: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ServiceLevel)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.serviceLevel (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:serviceLevel: ", p), err) }
  }
  return err
}

func (p *PublicUserInfo) Equals(other *PublicUserInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.UserId != other.UserId { return false }
  if p.Username != other.Username {
    if p.Username == nil || other.Username == nil {
      return false
    }
    if (*p.Username) != (*other.Username) { return false }
  }
  if p.NoteStoreUrl != other.NoteStoreUrl {
    if p.NoteStoreUrl == nil || other.NoteStoreUrl == nil {
      return false
    }
    if (*p.NoteStoreUrl) != (*other.NoteStoreUrl) { return false }
  }
  if p.WebApiUrlPrefix != other.WebApiUrlPrefix {
    if p.WebApiUrlPrefix == nil || other.WebApiUrlPrefix == nil {
      return false
    }
    if (*p.WebApiUrlPrefix) != (*other.WebApiUrlPrefix) { return false }
  }
  if p.ServiceLevel != other.ServiceLevel {
    if p.ServiceLevel == nil || other.ServiceLevel == nil {
      return false
    }
    if (*p.ServiceLevel) != (*other.ServiceLevel) { return false }
  }
  return true
}

func (p *PublicUserInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PublicUserInfo(%+v)", *p)
}

// <dl>
// <dt>noteStoreUrl:</dt>
//   <dd>
//   This field will contain the full URL that clients should use to make
//   NoteStore requests to the server shard that contains that user's data.
//   I.e. this is the URL that should be used to create the Thrift HTTP client
//   transport to send messages to the NoteStore service for the account.
//   </dd>
// <dt>webApiUrlPrefix:</dt>
//   <dd>
//   This field will contain the initial part of the URLs that should be used
//   to make requests to Evernote's thin client "web API", which provide
//   optimized operations for clients that aren't capable of manipulating
//   the full contents of accounts via the full Thrift data model. Clients
//   should concatenate the relative path for the various servlets onto the
//   end of this string to construct the full URL, as documented on our
//   developer web site.
//   </dd>
// <dt>userStoreUrl:</dt>
//   <dd>
//   This field will contain the full URL that clients should use to make UserStore
//   requests after successfully authenticating. I.e. this is the URL that should be used
//   to create the Thrift HTTP client transport to send messages to the UserStore service
//   for this account.
//   </dd>
// <dt>utilityUrl:</dt>
//   <dd>
//   This field will contain the full URL that clients should use to make Utility requests
//   to the server shard that contains that user's data. I.e. this is the URL that should
//   be used to create the Thrift HTTP client transport to send messages to the Utility
//   service for the account.
//   </dd>
// <dt>messageStoreUrl:</dt>
//   <dd>
//   This field will contain the full URL that clients should use to make MessageStore
//   requests to the server. I.e. this is the URL that should be used to create the
//   Thrift HTTP client transport to send messages to the MessageStore service for the
//   account.
//   </dd>
// <dt>userWebSocketUrl:</dt>
//   <dd>
//   This field will contain the full URL that clients should use when opening a
//   persistent web socket to recieve notification of events for the authenticated user.
//   </dd>
// </dl>
// 
// Attributes:
//  - NoteStoreUrl
//  - WebApiUrlPrefix
//  - UserStoreUrl
//  - UtilityUrl
//  - MessageStoreUrl
//  - UserWebSocketUrl
type UserUrls struct {
  NoteStoreUrl *string `thrift:"noteStoreUrl,1" db:"noteStoreUrl" json:"noteStoreUrl,omitempty"`
  WebApiUrlPrefix *string `thrift:"webApiUrlPrefix,2" db:"webApiUrlPrefix" json:"webApiUrlPrefix,omitempty"`
  UserStoreUrl *string `thrift:"userStoreUrl,3" db:"userStoreUrl" json:"userStoreUrl,omitempty"`
  UtilityUrl *string `thrift:"utilityUrl,4" db:"utilityUrl" json:"utilityUrl,omitempty"`
  MessageStoreUrl *string `thrift:"messageStoreUrl,5" db:"messageStoreUrl" json:"messageStoreUrl,omitempty"`
  UserWebSocketUrl *string `thrift:"userWebSocketUrl,6" db:"userWebSocketUrl" json:"userWebSocketUrl,omitempty"`
}

func NewUserUrls() *UserUrls {
  return &UserUrls{}
}

var UserUrls_NoteStoreUrl_DEFAULT string
func (p *UserUrls) GetNoteStoreUrl() string {
  if !p.IsSetNoteStoreUrl() {
    return UserUrls_NoteStoreUrl_DEFAULT
  }
return *p.NoteStoreUrl
}
var UserUrls_WebApiUrlPrefix_DEFAULT string
func (p *UserUrls) GetWebApiUrlPrefix() string {
  if !p.IsSetWebApiUrlPrefix() {
    return UserUrls_WebApiUrlPrefix_DEFAULT
  }
return *p.WebApiUrlPrefix
}
var UserUrls_UserStoreUrl_DEFAULT string
func (p *UserUrls) GetUserStoreUrl() string {
  if !p.IsSetUserStoreUrl() {
    return UserUrls_UserStoreUrl_DEFAULT
  }
return *p.UserStoreUrl
}
var UserUrls_UtilityUrl_DEFAULT string
func (p *UserUrls) GetUtilityUrl() string {
  if !p.IsSetUtilityUrl() {
    return UserUrls_UtilityUrl_DEFAULT
  }
return *p.UtilityUrl
}
var UserUrls_MessageStoreUrl_DEFAULT string
func (p *UserUrls) GetMessageStoreUrl() string {
  if !p.IsSetMessageStoreUrl() {
    return UserUrls_MessageStoreUrl_DEFAULT
  }
return *p.MessageStoreUrl
}
var UserUrls_UserWebSocketUrl_DEFAULT string
func (p *UserUrls) GetUserWebSocketUrl() string {
  if !p.IsSetUserWebSocketUrl() {
    return UserUrls_UserWebSocketUrl_DEFAULT
  }
return *p.UserWebSocketUrl
}
func (p *UserUrls) IsSetNoteStoreUrl() bool {
  return p.NoteStoreUrl != nil
}

func (p *UserUrls) IsSetWebApiUrlPrefix() bool {
  return p.WebApiUrlPrefix != nil
}

func (p *UserUrls) IsSetUserStoreUrl() bool {
  return p.UserStoreUrl != nil
}

func (p *UserUrls) IsSetUtilityUrl() bool {
  return p.UtilityUrl != nil
}

func (p *UserUrls) IsSetMessageStoreUrl() bool {
  return p.MessageStoreUrl != nil
}

func (p *UserUrls) IsSetUserWebSocketUrl() bool {
  return p.UserWebSocketUrl != nil
}

func (p *UserUrls) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserUrls)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NoteStoreUrl = &v
}
  return nil
}

func (p *UserUrls)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.WebApiUrlPrefix = &v
}
  return nil
}

func (p *UserUrls)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.UserStoreUrl = &v
}
  return nil
}

func (p *UserUrls)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.UtilityUrl = &v
}
  return nil
}

func (p *UserUrls)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.MessageStoreUrl = &v
}
  return nil
}

func (p *UserUrls)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.UserWebSocketUrl = &v
}
  return nil
}

func (p *UserUrls) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "UserUrls"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserUrls) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoteStoreUrl() {
    if err := oprot.WriteFieldBegin(ctx, "noteStoreUrl", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:noteStoreUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NoteStoreUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noteStoreUrl (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:noteStoreUrl: ", p), err) }
  }
  return err
}

func (p *UserUrls) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetWebApiUrlPrefix() {
    if err := oprot.WriteFieldBegin(ctx, "webApiUrlPrefix", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:webApiUrlPrefix: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.WebApiUrlPrefix)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.webApiUrlPrefix (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:webApiUrlPrefix: ", p), err) }
  }
  return err
}

func (p *UserUrls) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserStoreUrl() {
    if err := oprot.WriteFieldBegin(ctx, "userStoreUrl", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:userStoreUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.UserStoreUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.userStoreUrl (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:userStoreUrl: ", p), err) }
  }
  return err
}

func (p *UserUrls) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUtilityUrl() {
    if err := oprot.WriteFieldBegin(ctx, "utilityUrl", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:utilityUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.UtilityUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.utilityUrl (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:utilityUrl: ", p), err) }
  }
  return err
}

func (p *UserUrls) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessageStoreUrl() {
    if err := oprot.WriteFieldBegin(ctx, "messageStoreUrl", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:messageStoreUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.MessageStoreUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.messageStoreUrl (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:messageStoreUrl: ", p), err) }
  }
  return err
}

func (p *UserUrls) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserWebSocketUrl() {
    if err := oprot.WriteFieldBegin(ctx, "userWebSocketUrl", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:userWebSocketUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.UserWebSocketUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.userWebSocketUrl (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:userWebSocketUrl: ", p), err) }
  }
  return err
}

func (p *UserUrls) Equals(other *UserUrls) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NoteStoreUrl != other.NoteStoreUrl {
    if p.NoteStoreUrl == nil || other.NoteStoreUrl == nil {
      return false
    }
    if (*p.NoteStoreUrl) != (*other.NoteStoreUrl) { return false }
  }
  if p.WebApiUrlPrefix != other.WebApiUrlPrefix {
    if p.WebApiUrlPrefix == nil || other.WebApiUrlPrefix == nil {
      return false
    }
    if (*p.WebApiUrlPrefix) != (*other.WebApiUrlPrefix) { return false }
  }
  if p.UserStoreUrl != other.UserStoreUrl {
    if p.UserStoreUrl == nil || other.UserStoreUrl == nil {
      return false
    }
    if (*p.UserStoreUrl) != (*other.UserStoreUrl) { return false }
  }
  if p.UtilityUrl != other.UtilityUrl {
    if p.UtilityUrl == nil || other.UtilityUrl == nil {
      return false
    }
    if (*p.UtilityUrl) != (*other.UtilityUrl) { return false }
  }
  if p.MessageStoreUrl != other.MessageStoreUrl {
    if p.MessageStoreUrl == nil || other.MessageStoreUrl == nil {
      return false
    }
    if (*p.MessageStoreUrl) != (*other.MessageStoreUrl) { return false }
  }
  if p.UserWebSocketUrl != other.UserWebSocketUrl {
    if p.UserWebSocketUrl == nil || other.UserWebSocketUrl == nil {
      return false
    }
    if (*p.UserWebSocketUrl) != (*other.UserWebSocketUrl) { return false }
  }
  return true
}

func (p *UserUrls) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserUrls(%+v)", *p)
}

//  When an authentication (or re-authentication) is performed, this structure
//  provides the result to the client.
// <dl>
//  <dt>currentTime:</dt>
//    <dd>
//    The server-side date and time when this result was
//    generated.
//    </dd>
//  <dt>authenticationToken:</dt>
//    <dd>
//    Holds an opaque, ASCII-encoded token that can be
//    used by the client to perform actions on a NoteStore.
//    </dd>
//  <dt>expiration:</dt>
//    <dd>
//    Holds the server-side date and time when the
//    authentication token will expire.
//    This time can be compared to "currentTime" to produce an expiration
//    time that can be reconciled with the client's local clock.
//    </dd>
//  <dt>user:</dt>
//    <dd>
//    Holds the information about the account which was
//    authenticated if this was a full authentication.  May be absent if this
//    particular authentication did not require user information.
//    </dd>
//  <dt>publicUserInfo:</dt>
//    <dd>
//    If this authentication result was achieved without full permissions to
//    access the full User structure, this field may be set to give back
//    a more limited public set of data.
//    </dd>
//  <dt>noteStoreUrl:</dt>
//    <dd>
//    DEPRECATED - Client applications should use urls.noteStoreUrl.
//    </dd>
//  <dt>webApiUrlPrefix:</dt>
//    <dd>
//    DEPRECATED - Client applications should use urls.webApiUrlPrefix.
//    </dd>
//  <dt>secondFactorRequired:</dt>
//    <dd>
//    If set to true, this field indicates that the user has enabled two-factor
//    authentication and must enter their second factor in order to complete
//    authentication. In this case the value of authenticationResult will be
//    a short-lived authentication token that may only be used to make a
//    subsequent call to completeTwoFactorAuthentication.
//    </dd>
//  <dt>secondFactorDeliveryHint:</dt>
//    <dd>
//    When secondFactorRequired is set to true, this field may contain a string
//    describing the second factor delivery method that the user has configured.
//    This will typically be an obfuscated mobile device number, such as
//    "(xxx) xxx-x095". This string can be displayed to the user to remind them
//    how to obtain the required second factor.
//    </dd>
//  <dt>urls</dt>
//    <dd>
//    This structure will contain all of the URLs that clients need to make requests to the
//    Evernote service on behalf of the authenticated User.
//    </dd>
//  </dl>
// 
// Attributes:
//  - CurrentTime
//  - AuthenticationToken
//  - Expiration
//  - User
//  - PublicUserInfo
//  - NoteStoreUrl
//  - WebApiUrlPrefix
//  - SecondFactorRequired
//  - SecondFactorDeliveryHint
//  - Urls
type AuthenticationResult_ struct {
  CurrentTime Timestamp `thrift:"currentTime,1,required" db:"currentTime" json:"currentTime"`
  AuthenticationToken string `thrift:"authenticationToken,2,required" db:"authenticationToken" json:"authenticationToken"`
  Expiration Timestamp `thrift:"expiration,3,required" db:"expiration" json:"expiration"`
  User *User `thrift:"user,4" db:"user" json:"user,omitempty"`
  PublicUserInfo *PublicUserInfo `thrift:"publicUserInfo,5" db:"publicUserInfo" json:"publicUserInfo,omitempty"`
  NoteStoreUrl *string `thrift:"noteStoreUrl,6" db:"noteStoreUrl" json:"noteStoreUrl,omitempty"`
  WebApiUrlPrefix *string `thrift:"webApiUrlPrefix,7" db:"webApiUrlPrefix" json:"webApiUrlPrefix,omitempty"`
  SecondFactorRequired *bool `thrift:"secondFactorRequired,8" db:"secondFactorRequired" json:"secondFactorRequired,omitempty"`
  SecondFactorDeliveryHint *string `thrift:"secondFactorDeliveryHint,9" db:"secondFactorDeliveryHint" json:"secondFactorDeliveryHint,omitempty"`
  Urls *UserUrls `thrift:"urls,10" db:"urls" json:"urls,omitempty"`
}

func NewAuthenticationResult_() *AuthenticationResult_ {
  return &AuthenticationResult_{}
}


func (p *AuthenticationResult_) GetCurrentTime() Timestamp {
  return p.CurrentTime
}

func (p *AuthenticationResult_) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *AuthenticationResult_) GetExpiration() Timestamp {
  return p.Expiration
}
var AuthenticationResult__User_DEFAULT *User
func (p *AuthenticationResult_) GetUser() *User {
  if !p.IsSetUser() {
    return AuthenticationResult__User_DEFAULT
  }
return p.User
}
var AuthenticationResult__PublicUserInfo_DEFAULT *PublicUserInfo
func (p *AuthenticationResult_) GetPublicUserInfo() *PublicUserInfo {
  if !p.IsSetPublicUserInfo() {
    return AuthenticationResult__PublicUserInfo_DEFAULT
  }
return p.PublicUserInfo
}
var AuthenticationResult__NoteStoreUrl_DEFAULT string
func (p *AuthenticationResult_) GetNoteStoreUrl() string {
  if !p.IsSetNoteStoreUrl() {
    return AuthenticationResult__NoteStoreUrl_DEFAULT
  }
return *p.NoteStoreUrl
}
var AuthenticationResult__WebApiUrlPrefix_DEFAULT string
func (p *AuthenticationResult_) GetWebApiUrlPrefix() string {
  if !p.IsSetWebApiUrlPrefix() {
    return AuthenticationResult__WebApiUrlPrefix_DEFAULT
  }
return *p.WebApiUrlPrefix
}
var AuthenticationResult__SecondFactorRequired_DEFAULT bool
func (p *AuthenticationResult_) GetSecondFactorRequired() bool {
  if !p.IsSetSecondFactorRequired() {
    return AuthenticationResult__SecondFactorRequired_DEFAULT
  }
return *p.SecondFactorRequired
}
var AuthenticationResult__SecondFactorDeliveryHint_DEFAULT string
func (p *AuthenticationResult_) GetSecondFactorDeliveryHint() string {
  if !p.IsSetSecondFactorDeliveryHint() {
    return AuthenticationResult__SecondFactorDeliveryHint_DEFAULT
  }
return *p.SecondFactorDeliveryHint
}
var AuthenticationResult__Urls_DEFAULT *UserUrls
func (p *AuthenticationResult_) GetUrls() *UserUrls {
  if !p.IsSetUrls() {
    return AuthenticationResult__Urls_DEFAULT
  }
return p.Urls
}
func (p *AuthenticationResult_) IsSetUser() bool {
  return p.User != nil
}

func (p *AuthenticationResult_) IsSetPublicUserInfo() bool {
  return p.PublicUserInfo != nil
}

func (p *AuthenticationResult_) IsSetNoteStoreUrl() bool {
  return p.NoteStoreUrl != nil
}

func (p *AuthenticationResult_) IsSetWebApiUrlPrefix() bool {
  return p.WebApiUrlPrefix != nil
}

func (p *AuthenticationResult_) IsSetSecondFactorRequired() bool {
  return p.SecondFactorRequired != nil
}

func (p *AuthenticationResult_) IsSetSecondFactorDeliveryHint() bool {
  return p.SecondFactorDeliveryHint != nil
}

func (p *AuthenticationResult_) IsSetUrls() bool {
  return p.Urls != nil
}

func (p *AuthenticationResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetCurrentTime bool = false;
  var issetAuthenticationToken bool = false;
  var issetExpiration bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetCurrentTime = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetAuthenticationToken = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetExpiration = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetCurrentTime{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CurrentTime is not set"));
  }
  if !issetAuthenticationToken{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field AuthenticationToken is not set"));
  }
  if !issetExpiration{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Expiration is not set"));
  }
  return nil
}

func (p *AuthenticationResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Timestamp(v)
  p.CurrentTime = temp
}
  return nil
}

func (p *AuthenticationResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *AuthenticationResult_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Timestamp(v)
  p.Expiration = temp
}
  return nil
}

func (p *AuthenticationResult_)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.User = &User{}
  if err := p.User.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.User), err)
  }
  return nil
}

func (p *AuthenticationResult_)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.PublicUserInfo = &PublicUserInfo{}
  if err := p.PublicUserInfo.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PublicUserInfo), err)
  }
  return nil
}

func (p *AuthenticationResult_)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.NoteStoreUrl = &v
}
  return nil
}

func (p *AuthenticationResult_)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.WebApiUrlPrefix = &v
}
  return nil
}

func (p *AuthenticationResult_)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.SecondFactorRequired = &v
}
  return nil
}

func (p *AuthenticationResult_)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.SecondFactorDeliveryHint = &v
}
  return nil
}

func (p *AuthenticationResult_)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  p.Urls = &UserUrls{}
  if err := p.Urls.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Urls), err)
  }
  return nil
}

func (p *AuthenticationResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AuthenticationResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuthenticationResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "currentTime", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:currentTime: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CurrentTime)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.currentTime (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:currentTime: ", p), err) }
  return err
}

func (p *AuthenticationResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:authenticationToken: ", p), err) }
  return err
}

func (p *AuthenticationResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "expiration", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:expiration: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Expiration)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.expiration (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:expiration: ", p), err) }
  return err
}

func (p *AuthenticationResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUser() {
    if err := oprot.WriteFieldBegin(ctx, "user", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:user: ", p), err) }
    if err := p.User.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.User), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:user: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPublicUserInfo() {
    if err := oprot.WriteFieldBegin(ctx, "publicUserInfo", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:publicUserInfo: ", p), err) }
    if err := p.PublicUserInfo.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PublicUserInfo), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:publicUserInfo: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNoteStoreUrl() {
    if err := oprot.WriteFieldBegin(ctx, "noteStoreUrl", thrift.STRING, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:noteStoreUrl: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NoteStoreUrl)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.noteStoreUrl (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:noteStoreUrl: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetWebApiUrlPrefix() {
    if err := oprot.WriteFieldBegin(ctx, "webApiUrlPrefix", thrift.STRING, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:webApiUrlPrefix: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.WebApiUrlPrefix)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.webApiUrlPrefix (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:webApiUrlPrefix: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSecondFactorRequired() {
    if err := oprot.WriteFieldBegin(ctx, "secondFactorRequired", thrift.BOOL, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:secondFactorRequired: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.SecondFactorRequired)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.secondFactorRequired (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:secondFactorRequired: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSecondFactorDeliveryHint() {
    if err := oprot.WriteFieldBegin(ctx, "secondFactorDeliveryHint", thrift.STRING, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:secondFactorDeliveryHint: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.SecondFactorDeliveryHint)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.secondFactorDeliveryHint (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:secondFactorDeliveryHint: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUrls() {
    if err := oprot.WriteFieldBegin(ctx, "urls", thrift.STRUCT, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:urls: ", p), err) }
    if err := p.Urls.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Urls), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:urls: ", p), err) }
  }
  return err
}

func (p *AuthenticationResult_) Equals(other *AuthenticationResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.CurrentTime != other.CurrentTime { return false }
  if p.AuthenticationToken != other.AuthenticationToken { return false }
  if p.Expiration != other.Expiration { return false }
  if !p.User.Equals(other.User) { return false }
  if !p.PublicUserInfo.Equals(other.PublicUserInfo) { return false }
  if p.NoteStoreUrl != other.NoteStoreUrl {
    if p.NoteStoreUrl == nil || other.NoteStoreUrl == nil {
      return false
    }
    if (*p.NoteStoreUrl) != (*other.NoteStoreUrl) { return false }
  }
  if p.WebApiUrlPrefix != other.WebApiUrlPrefix {
    if p.WebApiUrlPrefix == nil || other.WebApiUrlPrefix == nil {
      return false
    }
    if (*p.WebApiUrlPrefix) != (*other.WebApiUrlPrefix) { return false }
  }
  if p.SecondFactorRequired != other.SecondFactorRequired {
    if p.SecondFactorRequired == nil || other.SecondFactorRequired == nil {
      return false
    }
    if (*p.SecondFactorRequired) != (*other.SecondFactorRequired) { return false }
  }
  if p.SecondFactorDeliveryHint != other.SecondFactorDeliveryHint {
    if p.SecondFactorDeliveryHint == nil || other.SecondFactorDeliveryHint == nil {
      return false
    }
    if (*p.SecondFactorDeliveryHint) != (*other.SecondFactorDeliveryHint) { return false }
  }
  if !p.Urls.Equals(other.Urls) { return false }
  return true
}

func (p *AuthenticationResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuthenticationResult_(%+v)", *p)
}

//  This structure describes a collection of bootstrap settings.
// <dl>
//  <dt>serviceHost:</dt>
//    <dd>
//    The hostname and optional port for composing Evernote web service URLs.
//    This URL can be used to access the UserStore and related services,
//    but must not be used to compose the NoteStore URL. Client applications
//    must handle serviceHost values that include only the hostname
//    (e.g. www.evernote.com) or both the hostname and port (e.g. www.evernote.com:8080).
//    If no port is specified, or if port 443 is specified, client applications must
//    use the scheme "https" when composing URLs. Otherwise, a client must use the
//    scheme "http".
//  </dd>
//  <dt>marketingUrl:</dt>
//    <dd>
//    The URL stem for the Evernote corporate marketing website, e.g. http://www.evernote.com.
//    This stem can be used to compose website URLs. For example, the URL of the Evernote
//    Trunk is composed by appending "/about/trunk/" to the value of marketingUrl.
//    </dd>
//  <dt>supportUrl:</dt>
//    <dd>
//    The full URL for the Evernote customer support website, e.g. https://support.evernote.com.
//    </dd>
//  <dt>accountEmailDomain:</dt>
//    <dd>
//    The domain used for an Evernote user's incoming email address, which allows notes to
//    be emailed into an account. E.g. m.evernote.com.
//    </dd>
//  <dt>enableFacebookSharing:</dt>
//    <dd>
//    Whether the client application should enable sharing of notes on Facebook.
//    </dd>
//  <dt>enableGiftSubscriptions:</dt>
//    <dd>
//    Whether the client application should enable gift subscriptions.
//    </dd>
//  <dt>enableSupportTickets:</dt>
//    <dd>
//    Whether the client application should enable in-client creation of support tickets.
//    </dd>
//  <dt>enableSharedNotebooks:</dt>
//    <dd>
//    Whether the client application should enable shared notebooks.
//    </dd>
//  <dt>enableSingleNoteSharing:</dt>
//    <dd>
//    Whether the client application should enable single note sharing.
//    </dd>
//  <dt>enableSponsoredAccounts:</dt>
//    <dd>
//    Whether the client application should enable sponsored accounts.
//    </dd>
//  <dt>enableTwitterSharing:</dt>
//    <dd>
//    Whether the client application should enable sharing of notes on Twitter.
//    </dd>
//  <dt>enableGoogle:</dt>
//    <dd>
//    Whether the client application should enable authentication with Google,
//    for example to allow integration with a user's Gmail contacts.
//  </dl>
// 
// Attributes:
//  - ServiceHost
//  - MarketingUrl
//  - SupportUrl
//  - AccountEmailDomain
//  - EnableFacebookSharing
//  - EnableGiftSubscriptions
//  - EnableSupportTickets
//  - EnableSharedNotebooks
//  - EnableSingleNoteSharing
//  - EnableSponsoredAccounts
//  - EnableTwitterSharing
//  - EnableLinkedInSharing
//  - EnablePublicNotebooks
//  - EnableGoogle
type BootstrapSettings struct {
  ServiceHost string `thrift:"serviceHost,1,required" db:"serviceHost" json:"serviceHost"`
  MarketingUrl string `thrift:"marketingUrl,2,required" db:"marketingUrl" json:"marketingUrl"`
  SupportUrl string `thrift:"supportUrl,3,required" db:"supportUrl" json:"supportUrl"`
  AccountEmailDomain string `thrift:"accountEmailDomain,4,required" db:"accountEmailDomain" json:"accountEmailDomain"`
  EnableFacebookSharing *bool `thrift:"enableFacebookSharing,5" db:"enableFacebookSharing" json:"enableFacebookSharing,omitempty"`
  EnableGiftSubscriptions *bool `thrift:"enableGiftSubscriptions,6" db:"enableGiftSubscriptions" json:"enableGiftSubscriptions,omitempty"`
  EnableSupportTickets *bool `thrift:"enableSupportTickets,7" db:"enableSupportTickets" json:"enableSupportTickets,omitempty"`
  EnableSharedNotebooks *bool `thrift:"enableSharedNotebooks,8" db:"enableSharedNotebooks" json:"enableSharedNotebooks,omitempty"`
  EnableSingleNoteSharing *bool `thrift:"enableSingleNoteSharing,9" db:"enableSingleNoteSharing" json:"enableSingleNoteSharing,omitempty"`
  EnableSponsoredAccounts *bool `thrift:"enableSponsoredAccounts,10" db:"enableSponsoredAccounts" json:"enableSponsoredAccounts,omitempty"`
  EnableTwitterSharing *bool `thrift:"enableTwitterSharing,11" db:"enableTwitterSharing" json:"enableTwitterSharing,omitempty"`
  EnableLinkedInSharing *bool `thrift:"enableLinkedInSharing,12" db:"enableLinkedInSharing" json:"enableLinkedInSharing,omitempty"`
  EnablePublicNotebooks *bool `thrift:"enablePublicNotebooks,13" db:"enablePublicNotebooks" json:"enablePublicNotebooks,omitempty"`
  // unused fields # 14 to 15
  EnableGoogle *bool `thrift:"enableGoogle,16" db:"enableGoogle" json:"enableGoogle,omitempty"`
}

func NewBootstrapSettings() *BootstrapSettings {
  return &BootstrapSettings{}
}


func (p *BootstrapSettings) GetServiceHost() string {
  return p.ServiceHost
}

func (p *BootstrapSettings) GetMarketingUrl() string {
  return p.MarketingUrl
}

func (p *BootstrapSettings) GetSupportUrl() string {
  return p.SupportUrl
}

func (p *BootstrapSettings) GetAccountEmailDomain() string {
  return p.AccountEmailDomain
}
var BootstrapSettings_EnableFacebookSharing_DEFAULT bool
func (p *BootstrapSettings) GetEnableFacebookSharing() bool {
  if !p.IsSetEnableFacebookSharing() {
    return BootstrapSettings_EnableFacebookSharing_DEFAULT
  }
return *p.EnableFacebookSharing
}
var BootstrapSettings_EnableGiftSubscriptions_DEFAULT bool
func (p *BootstrapSettings) GetEnableGiftSubscriptions() bool {
  if !p.IsSetEnableGiftSubscriptions() {
    return BootstrapSettings_EnableGiftSubscriptions_DEFAULT
  }
return *p.EnableGiftSubscriptions
}
var BootstrapSettings_EnableSupportTickets_DEFAULT bool
func (p *BootstrapSettings) GetEnableSupportTickets() bool {
  if !p.IsSetEnableSupportTickets() {
    return BootstrapSettings_EnableSupportTickets_DEFAULT
  }
return *p.EnableSupportTickets
}
var BootstrapSettings_EnableSharedNotebooks_DEFAULT bool
func (p *BootstrapSettings) GetEnableSharedNotebooks() bool {
  if !p.IsSetEnableSharedNotebooks() {
    return BootstrapSettings_EnableSharedNotebooks_DEFAULT
  }
return *p.EnableSharedNotebooks
}
var BootstrapSettings_EnableSingleNoteSharing_DEFAULT bool
func (p *BootstrapSettings) GetEnableSingleNoteSharing() bool {
  if !p.IsSetEnableSingleNoteSharing() {
    return BootstrapSettings_EnableSingleNoteSharing_DEFAULT
  }
return *p.EnableSingleNoteSharing
}
var BootstrapSettings_EnableSponsoredAccounts_DEFAULT bool
func (p *BootstrapSettings) GetEnableSponsoredAccounts() bool {
  if !p.IsSetEnableSponsoredAccounts() {
    return BootstrapSettings_EnableSponsoredAccounts_DEFAULT
  }
return *p.EnableSponsoredAccounts
}
var BootstrapSettings_EnableTwitterSharing_DEFAULT bool
func (p *BootstrapSettings) GetEnableTwitterSharing() bool {
  if !p.IsSetEnableTwitterSharing() {
    return BootstrapSettings_EnableTwitterSharing_DEFAULT
  }
return *p.EnableTwitterSharing
}
var BootstrapSettings_EnableLinkedInSharing_DEFAULT bool
func (p *BootstrapSettings) GetEnableLinkedInSharing() bool {
  if !p.IsSetEnableLinkedInSharing() {
    return BootstrapSettings_EnableLinkedInSharing_DEFAULT
  }
return *p.EnableLinkedInSharing
}
var BootstrapSettings_EnablePublicNotebooks_DEFAULT bool
func (p *BootstrapSettings) GetEnablePublicNotebooks() bool {
  if !p.IsSetEnablePublicNotebooks() {
    return BootstrapSettings_EnablePublicNotebooks_DEFAULT
  }
return *p.EnablePublicNotebooks
}
var BootstrapSettings_EnableGoogle_DEFAULT bool
func (p *BootstrapSettings) GetEnableGoogle() bool {
  if !p.IsSetEnableGoogle() {
    return BootstrapSettings_EnableGoogle_DEFAULT
  }
return *p.EnableGoogle
}
func (p *BootstrapSettings) IsSetEnableFacebookSharing() bool {
  return p.EnableFacebookSharing != nil
}

func (p *BootstrapSettings) IsSetEnableGiftSubscriptions() bool {
  return p.EnableGiftSubscriptions != nil
}

func (p *BootstrapSettings) IsSetEnableSupportTickets() bool {
  return p.EnableSupportTickets != nil
}

func (p *BootstrapSettings) IsSetEnableSharedNotebooks() bool {
  return p.EnableSharedNotebooks != nil
}

func (p *BootstrapSettings) IsSetEnableSingleNoteSharing() bool {
  return p.EnableSingleNoteSharing != nil
}

func (p *BootstrapSettings) IsSetEnableSponsoredAccounts() bool {
  return p.EnableSponsoredAccounts != nil
}

func (p *BootstrapSettings) IsSetEnableTwitterSharing() bool {
  return p.EnableTwitterSharing != nil
}

func (p *BootstrapSettings) IsSetEnableLinkedInSharing() bool {
  return p.EnableLinkedInSharing != nil
}

func (p *BootstrapSettings) IsSetEnablePublicNotebooks() bool {
  return p.EnablePublicNotebooks != nil
}

func (p *BootstrapSettings) IsSetEnableGoogle() bool {
  return p.EnableGoogle != nil
}

func (p *BootstrapSettings) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetServiceHost bool = false;
  var issetMarketingUrl bool = false;
  var issetSupportUrl bool = false;
  var issetAccountEmailDomain bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetServiceHost = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetMarketingUrl = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
        issetSupportUrl = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
        issetAccountEmailDomain = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField16(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetServiceHost{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ServiceHost is not set"));
  }
  if !issetMarketingUrl{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MarketingUrl is not set"));
  }
  if !issetSupportUrl{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SupportUrl is not set"));
  }
  if !issetAccountEmailDomain{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field AccountEmailDomain is not set"));
  }
  return nil
}

func (p *BootstrapSettings)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ServiceHost = v
}
  return nil
}

func (p *BootstrapSettings)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MarketingUrl = v
}
  return nil
}

func (p *BootstrapSettings)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.SupportUrl = v
}
  return nil
}

func (p *BootstrapSettings)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.AccountEmailDomain = v
}
  return nil
}

func (p *BootstrapSettings)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.EnableFacebookSharing = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.EnableGiftSubscriptions = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.EnableSupportTickets = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.EnableSharedNotebooks = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.EnableSingleNoteSharing = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.EnableSponsoredAccounts = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.EnableTwitterSharing = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.EnableLinkedInSharing = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.EnablePublicNotebooks = &v
}
  return nil
}

func (p *BootstrapSettings)  ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 16: ", err)
} else {
  p.EnableGoogle = &v
}
  return nil
}

func (p *BootstrapSettings) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "BootstrapSettings"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField16(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *BootstrapSettings) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serviceHost", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serviceHost: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ServiceHost)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serviceHost (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serviceHost: ", p), err) }
  return err
}

func (p *BootstrapSettings) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "marketingUrl", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:marketingUrl: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.MarketingUrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.marketingUrl (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:marketingUrl: ", p), err) }
  return err
}

func (p *BootstrapSettings) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "supportUrl", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:supportUrl: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.SupportUrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.supportUrl (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:supportUrl: ", p), err) }
  return err
}

func (p *BootstrapSettings) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "accountEmailDomain", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:accountEmailDomain: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AccountEmailDomain)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.accountEmailDomain (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:accountEmailDomain: ", p), err) }
  return err
}

func (p *BootstrapSettings) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableFacebookSharing() {
    if err := oprot.WriteFieldBegin(ctx, "enableFacebookSharing", thrift.BOOL, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:enableFacebookSharing: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableFacebookSharing)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableFacebookSharing (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:enableFacebookSharing: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableGiftSubscriptions() {
    if err := oprot.WriteFieldBegin(ctx, "enableGiftSubscriptions", thrift.BOOL, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:enableGiftSubscriptions: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableGiftSubscriptions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableGiftSubscriptions (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:enableGiftSubscriptions: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableSupportTickets() {
    if err := oprot.WriteFieldBegin(ctx, "enableSupportTickets", thrift.BOOL, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:enableSupportTickets: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableSupportTickets)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableSupportTickets (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:enableSupportTickets: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableSharedNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "enableSharedNotebooks", thrift.BOOL, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:enableSharedNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableSharedNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableSharedNotebooks (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:enableSharedNotebooks: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableSingleNoteSharing() {
    if err := oprot.WriteFieldBegin(ctx, "enableSingleNoteSharing", thrift.BOOL, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:enableSingleNoteSharing: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableSingleNoteSharing)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableSingleNoteSharing (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:enableSingleNoteSharing: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableSponsoredAccounts() {
    if err := oprot.WriteFieldBegin(ctx, "enableSponsoredAccounts", thrift.BOOL, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:enableSponsoredAccounts: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableSponsoredAccounts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableSponsoredAccounts (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:enableSponsoredAccounts: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableTwitterSharing() {
    if err := oprot.WriteFieldBegin(ctx, "enableTwitterSharing", thrift.BOOL, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:enableTwitterSharing: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableTwitterSharing)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableTwitterSharing (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:enableTwitterSharing: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableLinkedInSharing() {
    if err := oprot.WriteFieldBegin(ctx, "enableLinkedInSharing", thrift.BOOL, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:enableLinkedInSharing: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableLinkedInSharing)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableLinkedInSharing (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:enableLinkedInSharing: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnablePublicNotebooks() {
    if err := oprot.WriteFieldBegin(ctx, "enablePublicNotebooks", thrift.BOOL, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:enablePublicNotebooks: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnablePublicNotebooks)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enablePublicNotebooks (13) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:enablePublicNotebooks: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnableGoogle() {
    if err := oprot.WriteFieldBegin(ctx, "enableGoogle", thrift.BOOL, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:enableGoogle: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.EnableGoogle)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.enableGoogle (16) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:enableGoogle: ", p), err) }
  }
  return err
}

func (p *BootstrapSettings) Equals(other *BootstrapSettings) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ServiceHost != other.ServiceHost { return false }
  if p.MarketingUrl != other.MarketingUrl { return false }
  if p.SupportUrl != other.SupportUrl { return false }
  if p.AccountEmailDomain != other.AccountEmailDomain { return false }
  if p.EnableFacebookSharing != other.EnableFacebookSharing {
    if p.EnableFacebookSharing == nil || other.EnableFacebookSharing == nil {
      return false
    }
    if (*p.EnableFacebookSharing) != (*other.EnableFacebookSharing) { return false }
  }
  if p.EnableGiftSubscriptions != other.EnableGiftSubscriptions {
    if p.EnableGiftSubscriptions == nil || other.EnableGiftSubscriptions == nil {
      return false
    }
    if (*p.EnableGiftSubscriptions) != (*other.EnableGiftSubscriptions) { return false }
  }
  if p.EnableSupportTickets != other.EnableSupportTickets {
    if p.EnableSupportTickets == nil || other.EnableSupportTickets == nil {
      return false
    }
    if (*p.EnableSupportTickets) != (*other.EnableSupportTickets) { return false }
  }
  if p.EnableSharedNotebooks != other.EnableSharedNotebooks {
    if p.EnableSharedNotebooks == nil || other.EnableSharedNotebooks == nil {
      return false
    }
    if (*p.EnableSharedNotebooks) != (*other.EnableSharedNotebooks) { return false }
  }
  if p.EnableSingleNoteSharing != other.EnableSingleNoteSharing {
    if p.EnableSingleNoteSharing == nil || other.EnableSingleNoteSharing == nil {
      return false
    }
    if (*p.EnableSingleNoteSharing) != (*other.EnableSingleNoteSharing) { return false }
  }
  if p.EnableSponsoredAccounts != other.EnableSponsoredAccounts {
    if p.EnableSponsoredAccounts == nil || other.EnableSponsoredAccounts == nil {
      return false
    }
    if (*p.EnableSponsoredAccounts) != (*other.EnableSponsoredAccounts) { return false }
  }
  if p.EnableTwitterSharing != other.EnableTwitterSharing {
    if p.EnableTwitterSharing == nil || other.EnableTwitterSharing == nil {
      return false
    }
    if (*p.EnableTwitterSharing) != (*other.EnableTwitterSharing) { return false }
  }
  if p.EnableLinkedInSharing != other.EnableLinkedInSharing {
    if p.EnableLinkedInSharing == nil || other.EnableLinkedInSharing == nil {
      return false
    }
    if (*p.EnableLinkedInSharing) != (*other.EnableLinkedInSharing) { return false }
  }
  if p.EnablePublicNotebooks != other.EnablePublicNotebooks {
    if p.EnablePublicNotebooks == nil || other.EnablePublicNotebooks == nil {
      return false
    }
    if (*p.EnablePublicNotebooks) != (*other.EnablePublicNotebooks) { return false }
  }
  if p.EnableGoogle != other.EnableGoogle {
    if p.EnableGoogle == nil || other.EnableGoogle == nil {
      return false
    }
    if (*p.EnableGoogle) != (*other.EnableGoogle) { return false }
  }
  return true
}

func (p *BootstrapSettings) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("BootstrapSettings(%+v)", *p)
}

//  This structure describes a collection of bootstrap settings.
// <dl>
//  <dt>name:</dt>
//    <dd>
//    The unique name of the profile, which is guaranteed to remain consistent across
//    calls to getBootstrapInfo.
//    </dd>
//  <dt>settings:</dt>
//    <dd>
//    The settings for this profile.
//    </dd>
//  </dl>
// 
// Attributes:
//  - Name
//  - Settings
type BootstrapProfile struct {
  Name string `thrift:"name,1,required" db:"name" json:"name"`
  Settings *BootstrapSettings `thrift:"settings,2,required" db:"settings" json:"settings"`
}

func NewBootstrapProfile() *BootstrapProfile {
  return &BootstrapProfile{}
}


func (p *BootstrapProfile) GetName() string {
  return p.Name
}
var BootstrapProfile_Settings_DEFAULT *BootstrapSettings
func (p *BootstrapProfile) GetSettings() *BootstrapSettings {
  if !p.IsSetSettings() {
    return BootstrapProfile_Settings_DEFAULT
  }
return p.Settings
}
func (p *BootstrapProfile) IsSetSettings() bool {
  return p.Settings != nil
}

func (p *BootstrapProfile) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetName bool = false;
  var issetSettings bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetName = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
        issetSettings = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetName{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
  }
  if !issetSettings{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Settings is not set"));
  }
  return nil
}

func (p *BootstrapProfile)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *BootstrapProfile)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Settings = &BootstrapSettings{}
  if err := p.Settings.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Settings), err)
  }
  return nil
}

func (p *BootstrapProfile) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "BootstrapProfile"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *BootstrapProfile) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *BootstrapProfile) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "settings", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:settings: ", p), err) }
  if err := p.Settings.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Settings), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:settings: ", p), err) }
  return err
}

func (p *BootstrapProfile) Equals(other *BootstrapProfile) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if !p.Settings.Equals(other.Settings) { return false }
  return true
}

func (p *BootstrapProfile) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("BootstrapProfile(%+v)", *p)
}

//  This structure describes a collection of bootstrap profiles.
// <dl>
//  <dt>profiles:</dt>
//    <dd>
//    List of one or more bootstrap profiles, in descending
//    preference order.
//    </dd>
//  </dl>
// 
// Attributes:
//  - Profiles
type BootstrapInfo struct {
  Profiles []*BootstrapProfile `thrift:"profiles,1,required" db:"profiles" json:"profiles"`
}

func NewBootstrapInfo() *BootstrapInfo {
  return &BootstrapInfo{}
}


func (p *BootstrapInfo) GetProfiles() []*BootstrapProfile {
  return p.Profiles
}
func (p *BootstrapInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetProfiles bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
        issetProfiles = true
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetProfiles{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Profiles is not set"));
  }
  return nil
}

func (p *BootstrapInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*BootstrapProfile, 0, size)
  p.Profiles =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &BootstrapProfile{}
    if err := _elem0.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.Profiles = append(p.Profiles, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *BootstrapInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "BootstrapInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *BootstrapInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "profiles", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:profiles: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Profiles)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Profiles {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:profiles: ", p), err) }
  return err
}

func (p *BootstrapInfo) Equals(other *BootstrapInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Profiles) != len(other.Profiles) { return false }
  for i, _tgt := range p.Profiles {
    _src1 := other.Profiles[i]
    if !_tgt.Equals(_src1) { return false }
  }
  return true
}

func (p *BootstrapInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("BootstrapInfo(%+v)", *p)
}

type UserStore interface {  //Service:  UserStore
  //<p>
  //The UserStore service is primarily used by EDAM clients to establish
  //authentication via username and password over a trusted connection (e.g.
  //SSL).  A client's first call to this interface should be checkVersion() to
  //ensure that the client's software is up to date.
  //</p>
  //All calls which require an authenticationToken may throw an
  //EDAMUserException for the following reasons:
  // <ul>
  //  <li> AUTH_EXPIRED "authenticationToken" - token has expired
  //  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
  //  <li> DATA_REQUIRED "authenticationToken" - token is empty
  //  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
  //  <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
  //    privileges
  //</ul>

  // This should be the first call made by a client to the EDAM service.  It
  // tells the service what protocol version is used by the client.  The
  // service will then return true if the client is capable of talking to
  // the service, and false if the client's protocol version is incompatible
  // with the service, so the client must upgrade.  If a client receives a
  // false value, it should report the incompatibility to the user and not
  // continue with any more EDAM requests (UserStore or NoteStore).
  // 
  // @param clientName
  //   This string provides some information about the client for
  //   tracking/logging on the service.  It should provide information about
  //   the client's software and platform. The structure should be:
  //   application/version; platform/version; [ device/version ]
  //   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
  // 
  // @param edamVersionMajor
  //   This should be the major protocol version that was compiled by the
  //   client.  This should be the current value of the EDAM_VERSION_MAJOR
  //   constant for the client.
  // 
  // @param edamVersionMinor
  //   This should be the major protocol version that was compiled by the
  //   client.  This should be the current value of the EDAM_VERSION_MINOR
  //   constant for the client.
  // 
  // Parameters:
  //  - ClientName
  //  - EdamVersionMajor
  //  - EdamVersionMinor
  CheckVersion(ctx context.Context, clientName string, edamVersionMajor int16, edamVersionMinor int16) (_r bool, _err error)
  // This provides bootstrap information to the client. Various bootstrap
  // profiles and settings may be used by the client to configure itself.
  // 
  // @param locale
  //   The client's current locale, expressed in language[_country]
  //   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
  //   language and country codes.
  // 
  // @return
  //   The bootstrap information suitable for this client.
  // 
  // Parameters:
  //  - Locale
  GetBootstrapInfo(ctx context.Context, locale string) (_r *BootstrapInfo, _err error)
  // This is used to check a username and password in order to create a
  // long-lived authentication token that can be used for further actions.
  // 
  // This function is not available to most third party applications,
  // which typically authenticate using OAuth as
  // described at
  // <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
  // If you believe that your application requires permission to authenticate
  // using username and password instead of OAuth, please contact Evernote
  // developer support by visiting
  // <a href="http://dev.evernote.com">dev.evernote.com</a>.
  // 
  // @param username
  //   The username or registered email address of the account to
  //   authenticate against.
  // 
  // @param password
  //   The plaintext password to check against the account.  Since
  //   this is not protected by the EDAM protocol, this information must be
  //   provided over a protected transport (i.e. SSL).
  // 
  // @param consumerKey
  //   The "consumer key" portion of the API key issued to the client application
  //   by Evernote.
  // 
  // @param consumerSecret
  //   The "consumer secret" portion of the API key issued to the client application
  //   by Evernote.
  // 
  // @param deviceIdentifier
  //   An optional string that uniquely identifies the device from which the
  //   authentication is being performed. This string allows the service to return the
  //   same authentication token when a given application requests authentication
  //   repeatedly from the same device. This may happen when the user logs out of an
  //   application and then logs back in, or when the application is uninstalled
  //   and later reinstalled. If no reliable device identifier can be created,
  //   this value should be omitted. If set, the device identifier must be between
  //   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
  //   EDAM_DEVICE_ID_REGEX.
  // 
  // @param deviceDescription
  //   A description of the device from which the authentication is being performed.
  //   This field is displayed to the user in a list of authorized applications to
  //   allow them to distinguish between multiple tokens issued to the same client
  //   application on different devices. For example, the Evernote iOS client on
  //   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
  //   "Bob's iPad". The device description must be between 1 and
  //   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
  //   expression EDAM_DEVICE_DESCRIPTION_REGEX.
  // 
  // @param supportsTwoFactor
  //   Whether the calling application supports two-factor authentication. If this
  //   parameter is false, this method will fail with the error code INVALID_AUTH and the
  //   parameter "password" when called for a user who has enabled two-factor
  //   authentication.
  // 
  // @return
  //   <p>The result of the authentication. The level of detail provided in the returned
  //   AuthenticationResult.User structure depends on the access level granted by
  //   calling application's API key.</p>
  //   <p>If the user has two-factor authentication enabled,
  //   AuthenticationResult.secondFactorRequired will be set and
  //   AuthenticationResult.authenticationToken will contain a short-lived token
  //   that may only be used to complete the two-factor authentication process by calling
  //   UserStore.completeTwoFactorAuthentication.</p>
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "username" - username is empty
  //   <li> DATA_REQUIRED "password" - password is empty
  //   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
  //   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
  //   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
  //   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
  //   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
  //   <li> INVALID_AUTH "username" - username not found
  //   <li> INVALID_AUTH "password" - password did not match
  //   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
  //   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
  //   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
  //   <li> PERMISSION_DENIED "User.active" - user account is closed
  //   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
  //     failed authentication too often
  //   <li> AUTH_EXPIRED "password" - user password is expired
  // </ul>
  // 
  // Parameters:
  //  - Username
  //  - Password
  //  - ConsumerKey
  //  - ConsumerSecret
  //  - DeviceIdentifier
  //  - DeviceDescription
  //  - SupportsTwoFactor
  AuthenticateLongSession(ctx context.Context, username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (_r *AuthenticationResult_, _err error)
  // Complete the authentication process when a second factor is required. This
  // call is made after a successful call to authenticate or authenticateLongSession
  // when the authenticating user has enabled two-factor authentication.
  // 
  // @param authenticationToken An authentication token returned by a previous
  //   call to UserStore.authenticate or UserStore.authenticateLongSession that
  //   could not be completed in a single call because a second factor was required.
  // 
  // @param oneTimeCode The one time code entered by the user. This value is delivered
  //   out-of-band, typically via SMS or an authenticator application.
  // 
  // @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
  // 
  // @param deviceDescription See the corresponding parameter in authenticateLongSession.
  // 
  // @return
  //   The result of the authentication. The level of detail provided in the returned
  //   AuthenticationResult.User structure depends on the access level granted by the
  //   calling application's API key. If the initial authentication call was made to
  //   authenticateLongSession, the AuthenticationResult will contain a long-lived
  //   authentication token.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
  //   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
  //   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
  //   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
  //   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
  //   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
  //   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
  //   <li> PERMISSION_DENIED "User.active" - user account is closed
  //   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
  //     failed authentication too often
  //   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
  //      two-factor authentication.</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - OneTimeCode
  //  - DeviceIdentifier
  //  - DeviceDescription
  CompleteTwoFactorAuthentication(ctx context.Context, authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (_r *AuthenticationResult_, _err error)
  // Revoke an existing long lived authentication token. This can be used to
  // revoke OAuth tokens or tokens created by calling authenticateLongSession,
  // and allows a user to effectively log out of Evernote from the perspective
  // of the application that holds the token. The authentication token that is
  // passed is immediately revoked and may not be used to call any authenticated
  // EDAM function.
  // 
  // @param authenticationToken the authentication token to revoke.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
  //   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
  //   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
  //   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
  //     is already revoked.
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  RevokeLongSession(ctx context.Context, authenticationToken string) (_err error)
  // This is used to take an existing authentication token that grants access
  // to an individual user account (returned from 'authenticate',
  // 'authenticateLongSession' or an OAuth authorization) and obtain an additional
  // authentication token that may be used to access business notebooks if the user
  // is a member of an Evernote Business account.
  // 
  // The resulting authentication token may be used to make NoteStore API calls
  // against the business using the NoteStore URL returned in the result.
  // 
  // @param authenticationToken
  //   The authentication token for the user. This may not be a shared authentication
  //   token (returned by NoteStore.authenticateToSharedNotebook or
  //   NoteStore.authenticateToSharedNote) or a business authentication token.
  // 
  // @return
  //   The result of the authentication, with the token granting access to the
  //   business in the result's 'authenticationToken' field. The URL that must
  //   be used to access the business account NoteStore will be returned in the
  //   result's 'noteStoreUrl' field.  The 'User' field will
  //   not be set in the result.
  // 
  // @throws EDAMUserException <ul>
  //   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
  //        is a shared or business authentication token. </li>
  //   <li> PERMISSION_DENIED "Business" - the user identified by the provided
  //        authentication token is not currently a member of a business. </li>
  //   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
  //        member of is not currently in an active status. </li>
  //   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
  //        sign-on before authenticating to the business.
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  AuthenticateToBusiness(ctx context.Context, authenticationToken string) (_r *AuthenticationResult_, _err error)
  // Returns the User corresponding to the provided authentication token,
  // or throws an exception if this token is not valid.
  // The level of detail provided in the returned User structure depends on
  // the access level granted by the token, so a web service client may receive
  // fewer fields than an integrated desktop client.
  // 
  // Parameters:
  //  - AuthenticationToken
  GetUser(ctx context.Context, authenticationToken string) (_r *User, _err error)
  // Asks the UserStore about the publicly available location information for
  // a particular username.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "username" - username is empty
  // </ul>
  // 
  // Parameters:
  //  - Username
  GetPublicUserInfo(ctx context.Context, username string) (_r *PublicUserInfo, _err error)
  // <p>Returns the URLs that should be used when sending requests to the service on
  // behalf of the account represented by the provided authenticationToken.</p>
  // 
  // <p>This method isn't needed by most clients, who can retreive the correct set of
  // UserUrls from the AuthenticationResult returned from
  // UserStore#authenticateLongSession(). This method is typically only needed to look up
  // the correct URLs for an existing long-lived authentication token.</p>
  // 
  // Parameters:
  //  - AuthenticationToken
  GetUserUrls(ctx context.Context, authenticationToken string) (_r *UserUrls, _err error)
  // Invite a user to join an Evernote Business account.
  // 
  // Behavior will depend on the auth token. <ol>
  //   <li>
  //     auth token with privileges to manage Evernote Business membership.
  //       "External Provisioning" - The user will receive an email inviting
  //       them to join the business. They do not need to have an existing Evernote
  //       account. If the user has already been invited, a new invitation email
  //       will be sent.
  //   </li>
  //   <li>
  //     business auth token issued to an admin user. Only for first-party clients:
  //       "Approve Invitation" - If there has been a request to invite the email,
  //       approve it. Invited user will receive email with a link to join business.
  //       "Invite User" - If no invitation for the email exists, create an approved
  //       invitation for the email. An email will be sent to the emailAddress with
  //       a link to join the caller's business.
  //   </li>
  //   </li>
  //     business auth token:
  //       "Request Invitation" - If no invitation exists, create a request to
  //       invite the user to the business. These requests do not count towards a
  //       business' max active user limit.
  //   </li>
  // </ol>
  // 
  // @param authenticationToken
  //   the authentication token with sufficient privileges to manage Evernote Business
  //   membership or a business auth token.
  // 
  // @param emailAddress
  //   the email address of the user to invite to join the Evernote Business account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "email" - if no email address was provided </li>
  //   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
  //   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
  //     whose business email address matches the specified email address. </li>
  //   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
  //     user limit. </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - EmailAddress
  InviteToBusiness(ctx context.Context, authenticationToken string, emailAddress string) (_err error)
  // Remove a user from an Evernote Business account. Once removed, the user will no
  // longer be able to access content within the Evernote Business account.
  // 
  // <p>The email address of the user to remove from the business must match the email
  // address used to invite a user to join the business via UserStore.inviteToBusiness.
  // This function will only remove users who were invited by external provisioning</p>
  // 
  // @param authenticationToken
  //   An authentication token with sufficient privileges to manage Evernote Business
  //   membership.
  // 
  // @param emailAddress
  //   The email address of the user to remove from the Evernote Business account.
  // 
  // @throws EDAMUserException <ul>
  //   <li> DATA_REQUIRED "email" - if no email address was provided </li>
  //   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
  // </ul>
  // @throws EDAMNotFoundException <ul>
  //   <li> "email" - If there is no user with the specified email address in the
  //     business or that user was not invited via external provisioning. </li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - EmailAddress
  RemoveFromBusiness(ctx context.Context, authenticationToken string, emailAddress string) (_err error)
  // Update the email address used to uniquely identify an Evernote Business user.
  // 
  // This will update the identifier for a user who was previously invited using
  // inviteToBusiness, ensuring that caller and the Evernote service maintain an
  // agreed-upon identifier for a specific user.
  // 
  // For example, the following sequence of calls would invite a user to join
  // a business, update their email address, and then remove the user
  // from the business using the updated email address.
  // 
  // inviteToBusiness("foo@bar.com")
  // updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
  // removeFromBusiness("baz@bar.com")
  // 
  // @param authenticationToken
  //   An authentication token with sufficient privileges to manage Evernote Business
  //   membership.
  // 
  // @param oldEmailAddress
  //   The existing email address used to uniquely identify the user.
  // 
  // @param newEmailAddress
  //   The new email address used to uniquely identify the user.
  // 
  // @throws EDAMUserException <ul>
  //   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
  //   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
  //   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
  //   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
  //   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
  //   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
  //     the provided new email address.</li>
  //   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
  //     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
  //     updated.</li>
  // </ul>
  // @throws EDAMNotFoundException <ul>
  //   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
  //     in the business.</li>
  // </ul>
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - OldEmailAddress
  //  - NewEmailAddress_
  UpdateBusinessUserIdentifier(ctx context.Context, authenticationToken string, oldEmailAddress string, newEmailAddress string) (_err error)
  // Returns a list of active business users in a given business.
  // 
  // Clients are required to cache this information and re-fetch no more than once per day
  // or when they encountered a user ID or username that was not known to them.
  // 
  // To avoid excessive look ups, clients should also track user IDs and usernames that belong
  // to users who are not in the business, since they will not be included in the result.
  // 
  // I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
  // listBusinessUsers to find information about this user. If the user is not in the resulting
  // list, the client should track that fact and not re-query the service the next time that it sees
  // this user on a note.
  // 
  // @param authenticationToken
  //   A business authentication token returned by authenticateToBusiness or with sufficient
  //   privileges to manage Evernote Business membership.
  // 
  // Parameters:
  //  - AuthenticationToken
  ListBusinessUsers(ctx context.Context, authenticationToken string) (_r []*UserProfile, _err error)
  // Returns a list of outstanding invitations to join an Evernote Business account.
  // 
  // Only outstanding invitations are returned by this function. Users who have accepted an
  // invitation and joined a business are listed using listBusinessUsers.
  // 
  // @param authenticationToken
  //   An authentication token with sufficient privileges to manage Evernote Business membership.
  // 
  // @param includeRequestedInvitations
  //   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
  //   in the returned list. If false, only invitations with a status of
  //   BusinessInvitationStatus.APPROVED will be included.
  // 
  // Parameters:
  //  - AuthenticationToken
  //  - IncludeRequestedInvitations
  ListBusinessInvitations(ctx context.Context, authenticationToken string, includeRequestedInvitations bool) (_r []*BusinessInvitation, _err error)
  // Retrieve the standard account limits for a given service level. This should only be
  // called when necessary, e.g. to determine if a higher level is available should the
  // user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
  // not expected to fluctuate frequently.
  // 
  // @throws EDAMUserException <ul>
  //   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
  // </ul>
  // 
  // Parameters:
  //  - ServiceLevel
  GetAccountLimits(ctx context.Context, serviceLevel ServiceLevel) (_r *AccountLimits, _err error)
}

//Service:  UserStore
//<p>
//The UserStore service is primarily used by EDAM clients to establish
//authentication via username and password over a trusted connection (e.g.
//SSL).  A client's first call to this interface should be checkVersion() to
//ensure that the client's software is up to date.
//</p>
//All calls which require an authenticationToken may throw an
//EDAMUserException for the following reasons:
// <ul>
//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
//  <li> DATA_REQUIRED "authenticationToken" - token is empty
//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
//  <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
//    privileges
//</ul>
type UserStoreClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewUserStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *UserStoreClient {
  return &UserStoreClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewUserStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *UserStoreClient {
  return &UserStoreClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewUserStoreClient(c thrift.TClient) *UserStoreClient {
  return &UserStoreClient{
    c: c,
  }
}

func (p *UserStoreClient) Client_() thrift.TClient {
  return p.c
}

func (p *UserStoreClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *UserStoreClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// This should be the first call made by a client to the EDAM service.  It
// tells the service what protocol version is used by the client.  The
// service will then return true if the client is capable of talking to
// the service, and false if the client's protocol version is incompatible
// with the service, so the client must upgrade.  If a client receives a
// false value, it should report the incompatibility to the user and not
// continue with any more EDAM requests (UserStore or NoteStore).
// 
// @param clientName
//   This string provides some information about the client for
//   tracking/logging on the service.  It should provide information about
//   the client's software and platform. The structure should be:
//   application/version; platform/version; [ device/version ]
//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
// 
// @param edamVersionMajor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MAJOR
//   constant for the client.
// 
// @param edamVersionMinor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MINOR
//   constant for the client.
// 
// Parameters:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
func (p *UserStoreClient) CheckVersion(ctx context.Context, clientName string, edamVersionMajor int16, edamVersionMinor int16) (_r bool, _err error) {
  var _args2 UserStoreCheckVersionArgs
  _args2.ClientName = clientName
  _args2.EdamVersionMajor = edamVersionMajor
  _args2.EdamVersionMinor = edamVersionMinor
  var _result4 UserStoreCheckVersionResult
  var _meta3 thrift.ResponseMeta
  _meta3, _err = p.Client_().Call(ctx, "checkVersion", &_args2, &_result4)
  p.SetLastResponseMeta_(_meta3)
  if _err != nil {
    return
  }
  return _result4.GetSuccess(), nil
}

// This provides bootstrap information to the client. Various bootstrap
// profiles and settings may be used by the client to configure itself.
// 
// @param locale
//   The client's current locale, expressed in language[_country]
//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
//   language and country codes.
// 
// @return
//   The bootstrap information suitable for this client.
// 
// Parameters:
//  - Locale
func (p *UserStoreClient) GetBootstrapInfo(ctx context.Context, locale string) (_r *BootstrapInfo, _err error) {
  var _args5 UserStoreGetBootstrapInfoArgs
  _args5.Locale = locale
  var _result7 UserStoreGetBootstrapInfoResult
  var _meta6 thrift.ResponseMeta
  _meta6, _err = p.Client_().Call(ctx, "getBootstrapInfo", &_args5, &_result7)
  p.SetLastResponseMeta_(_meta6)
  if _err != nil {
    return
  }
  if _ret8 := _result7.GetSuccess(); _ret8 != nil {
    return _ret8, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getBootstrapInfo failed: unknown result")
}

// This is used to check a username and password in order to create a
// long-lived authentication token that can be used for further actions.
// 
// This function is not available to most third party applications,
// which typically authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
// If you believe that your application requires permission to authenticate
// using username and password instead of OAuth, please contact Evernote
// developer support by visiting
// <a href="http://dev.evernote.com">dev.evernote.com</a>.
// 
// @param username
//   The username or registered email address of the account to
//   authenticate against.
// 
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (i.e. SSL).
// 
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
// 
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
// 
// @param deviceIdentifier
//   An optional string that uniquely identifies the device from which the
//   authentication is being performed. This string allows the service to return the
//   same authentication token when a given application requests authentication
//   repeatedly from the same device. This may happen when the user logs out of an
//   application and then logs back in, or when the application is uninstalled
//   and later reinstalled. If no reliable device identifier can be created,
//   this value should be omitted. If set, the device identifier must be between
//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
//   EDAM_DEVICE_ID_REGEX.
// 
// @param deviceDescription
//   A description of the device from which the authentication is being performed.
//   This field is displayed to the user in a list of authorized applications to
//   allow them to distinguish between multiple tokens issued to the same client
//   application on different devices. For example, the Evernote iOS client on
//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
//   "Bob's iPad". The device description must be between 1 and
//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
// 
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
// 
// @return
//   <p>The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by
//   calling application's API key.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> AUTH_EXPIRED "password" - user password is expired
// </ul>
// 
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
func (p *UserStoreClient) AuthenticateLongSession(ctx context.Context, username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (_r *AuthenticationResult_, _err error) {
  var _args9 UserStoreAuthenticateLongSessionArgs
  _args9.Username = username
  _args9.Password = password
  _args9.ConsumerKey = consumerKey
  _args9.ConsumerSecret = consumerSecret
  _args9.DeviceIdentifier = deviceIdentifier
  _args9.DeviceDescription = deviceDescription
  _args9.SupportsTwoFactor = supportsTwoFactor
  var _result11 UserStoreAuthenticateLongSessionResult
  var _meta10 thrift.ResponseMeta
  _meta10, _err = p.Client_().Call(ctx, "authenticateLongSession", &_args9, &_result11)
  p.SetLastResponseMeta_(_meta10)
  if _err != nil {
    return
  }
  switch {
  case _result11.UserException!= nil:
    return _r, _result11.UserException
  case _result11.SystemException!= nil:
    return _r, _result11.SystemException
  }

  if _ret12 := _result11.GetSuccess(); _ret12 != nil {
    return _ret12, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "authenticateLongSession failed: unknown result")
}

// Complete the authentication process when a second factor is required. This
// call is made after a successful call to authenticate or authenticateLongSession
// when the authenticating user has enabled two-factor authentication.
// 
// @param authenticationToken An authentication token returned by a previous
//   call to UserStore.authenticate or UserStore.authenticateLongSession that
//   could not be completed in a single call because a second factor was required.
// 
// @param oneTimeCode The one time code entered by the user. This value is delivered
//   out-of-band, typically via SMS or an authenticator application.
// 
// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
// 
// @param deviceDescription See the corresponding parameter in authenticateLongSession.
// 
// @return
//   The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by the
//   calling application's API key. If the initial authentication call was made to
//   authenticateLongSession, the AuthenticationResult will contain a long-lived
//   authentication token.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
//      two-factor authentication.</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
func (p *UserStoreClient) CompleteTwoFactorAuthentication(ctx context.Context, authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (_r *AuthenticationResult_, _err error) {
  var _args13 UserStoreCompleteTwoFactorAuthenticationArgs
  _args13.AuthenticationToken = authenticationToken
  _args13.OneTimeCode = oneTimeCode
  _args13.DeviceIdentifier = deviceIdentifier
  _args13.DeviceDescription = deviceDescription
  var _result15 UserStoreCompleteTwoFactorAuthenticationResult
  var _meta14 thrift.ResponseMeta
  _meta14, _err = p.Client_().Call(ctx, "completeTwoFactorAuthentication", &_args13, &_result15)
  p.SetLastResponseMeta_(_meta14)
  if _err != nil {
    return
  }
  switch {
  case _result15.UserException!= nil:
    return _r, _result15.UserException
  case _result15.SystemException!= nil:
    return _r, _result15.SystemException
  }

  if _ret16 := _result15.GetSuccess(); _ret16 != nil {
    return _ret16, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "completeTwoFactorAuthentication failed: unknown result")
}

// Revoke an existing long lived authentication token. This can be used to
// revoke OAuth tokens or tokens created by calling authenticateLongSession,
// and allows a user to effectively log out of Evernote from the perspective
// of the application that holds the token. The authentication token that is
// passed is immediately revoked and may not be used to call any authenticated
// EDAM function.
// 
// @param authenticationToken the authentication token to revoke.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
//     is already revoked.
// </ul>
// 
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RevokeLongSession(ctx context.Context, authenticationToken string) (_err error) {
  var _args17 UserStoreRevokeLongSessionArgs
  _args17.AuthenticationToken = authenticationToken
  var _result19 UserStoreRevokeLongSessionResult
  var _meta18 thrift.ResponseMeta
  _meta18, _err = p.Client_().Call(ctx, "revokeLongSession", &_args17, &_result19)
  p.SetLastResponseMeta_(_meta18)
  if _err != nil {
    return
  }
  switch {
  case _result19.UserException!= nil:
    return _result19.UserException
  case _result19.SystemException!= nil:
    return _result19.SystemException
  }

  return nil
}

// This is used to take an existing authentication token that grants access
// to an individual user account (returned from 'authenticate',
// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
// authentication token that may be used to access business notebooks if the user
// is a member of an Evernote Business account.
// 
// The resulting authentication token may be used to make NoteStore API calls
// against the business using the NoteStore URL returned in the result.
// 
// @param authenticationToken
//   The authentication token for the user. This may not be a shared authentication
//   token (returned by NoteStore.authenticateToSharedNotebook or
//   NoteStore.authenticateToSharedNote) or a business authentication token.
// 
// @return
//   The result of the authentication, with the token granting access to the
//   business in the result's 'authenticationToken' field. The URL that must
//   be used to access the business account NoteStore will be returned in the
//   result's 'noteStoreUrl' field.  The 'User' field will
//   not be set in the result.
// 
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
//        is a shared or business authentication token. </li>
//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
//        authentication token is not currently a member of a business. </li>
//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
//        member of is not currently in an active status. </li>
//   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
//        sign-on before authenticating to the business.
// </ul>
// 
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) AuthenticateToBusiness(ctx context.Context, authenticationToken string) (_r *AuthenticationResult_, _err error) {
  var _args20 UserStoreAuthenticateToBusinessArgs
  _args20.AuthenticationToken = authenticationToken
  var _result22 UserStoreAuthenticateToBusinessResult
  var _meta21 thrift.ResponseMeta
  _meta21, _err = p.Client_().Call(ctx, "authenticateToBusiness", &_args20, &_result22)
  p.SetLastResponseMeta_(_meta21)
  if _err != nil {
    return
  }
  switch {
  case _result22.UserException!= nil:
    return _r, _result22.UserException
  case _result22.SystemException!= nil:
    return _r, _result22.SystemException
  }

  if _ret23 := _result22.GetSuccess(); _ret23 != nil {
    return _ret23, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "authenticateToBusiness failed: unknown result")
}

// Returns the User corresponding to the provided authentication token,
// or throws an exception if this token is not valid.
// The level of detail provided in the returned User structure depends on
// the access level granted by the token, so a web service client may receive
// fewer fields than an integrated desktop client.
// 
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUser(ctx context.Context, authenticationToken string) (_r *User, _err error) {
  var _args24 UserStoreGetUserArgs
  _args24.AuthenticationToken = authenticationToken
  var _result26 UserStoreGetUserResult
  var _meta25 thrift.ResponseMeta
  _meta25, _err = p.Client_().Call(ctx, "getUser", &_args24, &_result26)
  p.SetLastResponseMeta_(_meta25)
  if _err != nil {
    return
  }
  switch {
  case _result26.UserException!= nil:
    return _r, _result26.UserException
  case _result26.SystemException!= nil:
    return _r, _result26.SystemException
  }

  if _ret27 := _result26.GetSuccess(); _ret27 != nil {
    return _ret27, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getUser failed: unknown result")
}

// Asks the UserStore about the publicly available location information for
// a particular username.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
// </ul>
// 
// Parameters:
//  - Username
func (p *UserStoreClient) GetPublicUserInfo(ctx context.Context, username string) (_r *PublicUserInfo, _err error) {
  var _args28 UserStoreGetPublicUserInfoArgs
  _args28.Username = username
  var _result30 UserStoreGetPublicUserInfoResult
  var _meta29 thrift.ResponseMeta
  _meta29, _err = p.Client_().Call(ctx, "getPublicUserInfo", &_args28, &_result30)
  p.SetLastResponseMeta_(_meta29)
  if _err != nil {
    return
  }
  switch {
  case _result30.NotFoundException!= nil:
    return _r, _result30.NotFoundException
  case _result30.SystemException!= nil:
    return _r, _result30.SystemException
  case _result30.UserException!= nil:
    return _r, _result30.UserException
  }

  if _ret31 := _result30.GetSuccess(); _ret31 != nil {
    return _ret31, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getPublicUserInfo failed: unknown result")
}

// <p>Returns the URLs that should be used when sending requests to the service on
// behalf of the account represented by the provided authenticationToken.</p>
// 
// <p>This method isn't needed by most clients, who can retreive the correct set of
// UserUrls from the AuthenticationResult returned from
// UserStore#authenticateLongSession(). This method is typically only needed to look up
// the correct URLs for an existing long-lived authentication token.</p>
// 
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUserUrls(ctx context.Context, authenticationToken string) (_r *UserUrls, _err error) {
  var _args32 UserStoreGetUserUrlsArgs
  _args32.AuthenticationToken = authenticationToken
  var _result34 UserStoreGetUserUrlsResult
  var _meta33 thrift.ResponseMeta
  _meta33, _err = p.Client_().Call(ctx, "getUserUrls", &_args32, &_result34)
  p.SetLastResponseMeta_(_meta33)
  if _err != nil {
    return
  }
  switch {
  case _result34.UserException!= nil:
    return _r, _result34.UserException
  case _result34.SystemException!= nil:
    return _r, _result34.SystemException
  }

  if _ret35 := _result34.GetSuccess(); _ret35 != nil {
    return _ret35, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getUserUrls failed: unknown result")
}

// Invite a user to join an Evernote Business account.
// 
// Behavior will depend on the auth token. <ol>
//   <li>
//     auth token with privileges to manage Evernote Business membership.
//       "External Provisioning" - The user will receive an email inviting
//       them to join the business. They do not need to have an existing Evernote
//       account. If the user has already been invited, a new invitation email
//       will be sent.
//   </li>
//   <li>
//     business auth token issued to an admin user. Only for first-party clients:
//       "Approve Invitation" - If there has been a request to invite the email,
//       approve it. Invited user will receive email with a link to join business.
//       "Invite User" - If no invitation for the email exists, create an approved
//       invitation for the email. An email will be sent to the emailAddress with
//       a link to join the caller's business.
//   </li>
//   </li>
//     business auth token:
//       "Request Invitation" - If no invitation exists, create a request to
//       invite the user to the business. These requests do not count towards a
//       business' max active user limit.
//   </li>
// </ol>
// 
// @param authenticationToken
//   the authentication token with sufficient privileges to manage Evernote Business
//   membership or a business auth token.
// 
// @param emailAddress
//   the email address of the user to invite to join the Evernote Business account.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
//   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
//   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
//     whose business email address matches the specified email address. </li>
//   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
//     user limit. </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - EmailAddress
func (p *UserStoreClient) InviteToBusiness(ctx context.Context, authenticationToken string, emailAddress string) (_err error) {
  var _args36 UserStoreInviteToBusinessArgs
  _args36.AuthenticationToken = authenticationToken
  _args36.EmailAddress = emailAddress
  var _result38 UserStoreInviteToBusinessResult
  var _meta37 thrift.ResponseMeta
  _meta37, _err = p.Client_().Call(ctx, "inviteToBusiness", &_args36, &_result38)
  p.SetLastResponseMeta_(_meta37)
  if _err != nil {
    return
  }
  switch {
  case _result38.UserException!= nil:
    return _result38.UserException
  case _result38.SystemException!= nil:
    return _result38.SystemException
  }

  return nil
}

// Remove a user from an Evernote Business account. Once removed, the user will no
// longer be able to access content within the Evernote Business account.
// 
// <p>The email address of the user to remove from the business must match the email
// address used to invite a user to join the business via UserStore.inviteToBusiness.
// This function will only remove users who were invited by external provisioning</p>
// 
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business
//   membership.
// 
// @param emailAddress
//   The email address of the user to remove from the Evernote Business account.
// 
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
//   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li> "email" - If there is no user with the specified email address in the
//     business or that user was not invited via external provisioning. </li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - EmailAddress
func (p *UserStoreClient) RemoveFromBusiness(ctx context.Context, authenticationToken string, emailAddress string) (_err error) {
  var _args39 UserStoreRemoveFromBusinessArgs
  _args39.AuthenticationToken = authenticationToken
  _args39.EmailAddress = emailAddress
  var _result41 UserStoreRemoveFromBusinessResult
  var _meta40 thrift.ResponseMeta
  _meta40, _err = p.Client_().Call(ctx, "removeFromBusiness", &_args39, &_result41)
  p.SetLastResponseMeta_(_meta40)
  if _err != nil {
    return
  }
  switch {
  case _result41.UserException!= nil:
    return _result41.UserException
  case _result41.SystemException!= nil:
    return _result41.SystemException
  case _result41.NotFoundException!= nil:
    return _result41.NotFoundException
  }

  return nil
}

// Update the email address used to uniquely identify an Evernote Business user.
// 
// This will update the identifier for a user who was previously invited using
// inviteToBusiness, ensuring that caller and the Evernote service maintain an
// agreed-upon identifier for a specific user.
// 
// For example, the following sequence of calls would invite a user to join
// a business, update their email address, and then remove the user
// from the business using the updated email address.
// 
// inviteToBusiness("foo@bar.com")
// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
// removeFromBusiness("baz@bar.com")
// 
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business
//   membership.
// 
// @param oldEmailAddress
//   The existing email address used to uniquely identify the user.
// 
// @param newEmailAddress
//   The new email address used to uniquely identify the user.
// 
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
//   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
//   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
//   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
//   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
//   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
//     the provided new email address.</li>
//   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
//     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
//     updated.</li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
//     in the business.</li>
// </ul>
// 
// Parameters:
//  - AuthenticationToken
//  - OldEmailAddress
//  - NewEmailAddress_
func (p *UserStoreClient) UpdateBusinessUserIdentifier(ctx context.Context, authenticationToken string, oldEmailAddress string, newEmailAddress string) (_err error) {
  var _args42 UserStoreUpdateBusinessUserIdentifierArgs
  _args42.AuthenticationToken = authenticationToken
  _args42.OldEmailAddress = oldEmailAddress
  _args42.NewEmailAddress_ = newEmailAddress
  var _result44 UserStoreUpdateBusinessUserIdentifierResult
  var _meta43 thrift.ResponseMeta
  _meta43, _err = p.Client_().Call(ctx, "updateBusinessUserIdentifier", &_args42, &_result44)
  p.SetLastResponseMeta_(_meta43)
  if _err != nil {
    return
  }
  switch {
  case _result44.UserException!= nil:
    return _result44.UserException
  case _result44.SystemException!= nil:
    return _result44.SystemException
  case _result44.NotFoundException!= nil:
    return _result44.NotFoundException
  }

  return nil
}

// Returns a list of active business users in a given business.
// 
// Clients are required to cache this information and re-fetch no more than once per day
// or when they encountered a user ID or username that was not known to them.
// 
// To avoid excessive look ups, clients should also track user IDs and usernames that belong
// to users who are not in the business, since they will not be included in the result.
// 
// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
// listBusinessUsers to find information about this user. If the user is not in the resulting
// list, the client should track that fact and not re-query the service the next time that it sees
// this user on a note.
// 
// @param authenticationToken
//   A business authentication token returned by authenticateToBusiness or with sufficient
//   privileges to manage Evernote Business membership.
// 
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) ListBusinessUsers(ctx context.Context, authenticationToken string) (_r []*UserProfile, _err error) {
  var _args45 UserStoreListBusinessUsersArgs
  _args45.AuthenticationToken = authenticationToken
  var _result47 UserStoreListBusinessUsersResult
  var _meta46 thrift.ResponseMeta
  _meta46, _err = p.Client_().Call(ctx, "listBusinessUsers", &_args45, &_result47)
  p.SetLastResponseMeta_(_meta46)
  if _err != nil {
    return
  }
  switch {
  case _result47.UserException!= nil:
    return _r, _result47.UserException
  case _result47.SystemException!= nil:
    return _r, _result47.SystemException
  }

  return _result47.GetSuccess(), nil
}

// Returns a list of outstanding invitations to join an Evernote Business account.
// 
// Only outstanding invitations are returned by this function. Users who have accepted an
// invitation and joined a business are listed using listBusinessUsers.
// 
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business membership.
// 
// @param includeRequestedInvitations
//   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
//   in the returned list. If false, only invitations with a status of
//   BusinessInvitationStatus.APPROVED will be included.
// 
// Parameters:
//  - AuthenticationToken
//  - IncludeRequestedInvitations
func (p *UserStoreClient) ListBusinessInvitations(ctx context.Context, authenticationToken string, includeRequestedInvitations bool) (_r []*BusinessInvitation, _err error) {
  var _args48 UserStoreListBusinessInvitationsArgs
  _args48.AuthenticationToken = authenticationToken
  _args48.IncludeRequestedInvitations = includeRequestedInvitations
  var _result50 UserStoreListBusinessInvitationsResult
  var _meta49 thrift.ResponseMeta
  _meta49, _err = p.Client_().Call(ctx, "listBusinessInvitations", &_args48, &_result50)
  p.SetLastResponseMeta_(_meta49)
  if _err != nil {
    return
  }
  switch {
  case _result50.UserException!= nil:
    return _r, _result50.UserException
  case _result50.SystemException!= nil:
    return _r, _result50.SystemException
  }

  return _result50.GetSuccess(), nil
}

// Retrieve the standard account limits for a given service level. This should only be
// called when necessary, e.g. to determine if a higher level is available should the
// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
// not expected to fluctuate frequently.
// 
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
// </ul>
// 
// Parameters:
//  - ServiceLevel
func (p *UserStoreClient) GetAccountLimits(ctx context.Context, serviceLevel ServiceLevel) (_r *AccountLimits, _err error) {
  var _args51 UserStoreGetAccountLimitsArgs
  _args51.ServiceLevel = serviceLevel
  var _result53 UserStoreGetAccountLimitsResult
  var _meta52 thrift.ResponseMeta
  _meta52, _err = p.Client_().Call(ctx, "getAccountLimits", &_args51, &_result53)
  p.SetLastResponseMeta_(_meta52)
  if _err != nil {
    return
  }
  switch {
  case _result53.UserException!= nil:
    return _r, _result53.UserException
  }

  if _ret54 := _result53.GetSuccess(); _ret54 != nil {
    return _ret54, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "getAccountLimits failed: unknown result")
}

type UserStoreProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler UserStore
}

func (p *UserStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *UserStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *UserStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewUserStoreProcessor(handler UserStore) *UserStoreProcessor {

  self55 := &UserStoreProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self55.processorMap["checkVersion"] = &userStoreProcessorCheckVersion{handler:handler}
  self55.processorMap["getBootstrapInfo"] = &userStoreProcessorGetBootstrapInfo{handler:handler}
  self55.processorMap["authenticateLongSession"] = &userStoreProcessorAuthenticateLongSession{handler:handler}
  self55.processorMap["completeTwoFactorAuthentication"] = &userStoreProcessorCompleteTwoFactorAuthentication{handler:handler}
  self55.processorMap["revokeLongSession"] = &userStoreProcessorRevokeLongSession{handler:handler}
  self55.processorMap["authenticateToBusiness"] = &userStoreProcessorAuthenticateToBusiness{handler:handler}
  self55.processorMap["getUser"] = &userStoreProcessorGetUser{handler:handler}
  self55.processorMap["getPublicUserInfo"] = &userStoreProcessorGetPublicUserInfo{handler:handler}
  self55.processorMap["getUserUrls"] = &userStoreProcessorGetUserUrls{handler:handler}
  self55.processorMap["inviteToBusiness"] = &userStoreProcessorInviteToBusiness{handler:handler}
  self55.processorMap["removeFromBusiness"] = &userStoreProcessorRemoveFromBusiness{handler:handler}
  self55.processorMap["updateBusinessUserIdentifier"] = &userStoreProcessorUpdateBusinessUserIdentifier{handler:handler}
  self55.processorMap["listBusinessUsers"] = &userStoreProcessorListBusinessUsers{handler:handler}
  self55.processorMap["listBusinessInvitations"] = &userStoreProcessorListBusinessInvitations{handler:handler}
  self55.processorMap["getAccountLimits"] = &userStoreProcessorGetAccountLimits{handler:handler}
return self55
}

func (p *UserStoreProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x56 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x56.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x56

}

type userStoreProcessorCheckVersion struct {
  handler UserStore
}

func (p *userStoreProcessorCheckVersion) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreCheckVersionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "checkVersion", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreCheckVersionResult{}
  var retval bool
  if retval, err2 = p.handler.CheckVersion(ctx, args.ClientName, args.EdamVersionMajor, args.EdamVersionMinor); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkVersion: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "checkVersion", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "checkVersion", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorGetBootstrapInfo struct {
  handler UserStore
}

func (p *userStoreProcessorGetBootstrapInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreGetBootstrapInfoArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getBootstrapInfo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreGetBootstrapInfoResult{}
  var retval *BootstrapInfo
  if retval, err2 = p.handler.GetBootstrapInfo(ctx, args.Locale); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getBootstrapInfo: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getBootstrapInfo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getBootstrapInfo", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorAuthenticateLongSession struct {
  handler UserStore
}

func (p *userStoreProcessorAuthenticateLongSession) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreAuthenticateLongSessionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateLongSession", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreAuthenticateLongSessionResult{}
  var retval *AuthenticationResult_
  if retval, err2 = p.handler.AuthenticateLongSession(ctx, args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.DeviceIdentifier, args.DeviceDescription, args.SupportsTwoFactor); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateLongSession: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateLongSession", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "authenticateLongSession", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorCompleteTwoFactorAuthentication struct {
  handler UserStore
}

func (p *userStoreProcessorCompleteTwoFactorAuthentication) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreCompleteTwoFactorAuthenticationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreCompleteTwoFactorAuthenticationResult{}
  var retval *AuthenticationResult_
  if retval, err2 = p.handler.CompleteTwoFactorAuthentication(ctx, args.AuthenticationToken, args.OneTimeCode, args.DeviceIdentifier, args.DeviceDescription); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing completeTwoFactorAuthentication: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "completeTwoFactorAuthentication", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorRevokeLongSession struct {
  handler UserStore
}

func (p *userStoreProcessorRevokeLongSession) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreRevokeLongSessionArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "revokeLongSession", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreRevokeLongSessionResult{}
  if err2 = p.handler.RevokeLongSession(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing revokeLongSession: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "revokeLongSession", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "revokeLongSession", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorAuthenticateToBusiness struct {
  handler UserStore
}

func (p *userStoreProcessorAuthenticateToBusiness) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreAuthenticateToBusinessArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateToBusiness", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreAuthenticateToBusinessResult{}
  var retval *AuthenticationResult_
  if retval, err2 = p.handler.AuthenticateToBusiness(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToBusiness: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "authenticateToBusiness", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "authenticateToBusiness", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorGetUser struct {
  handler UserStore
}

func (p *userStoreProcessorGetUser) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreGetUserArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getUser", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreGetUserResult{}
  var retval *User
  if retval, err2 = p.handler.GetUser(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUser: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getUser", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getUser", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorGetPublicUserInfo struct {
  handler UserStore
}

func (p *userStoreProcessorGetPublicUserInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreGetPublicUserInfoArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPublicUserInfo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreGetPublicUserInfoResult{}
  var retval *PublicUserInfo
  if retval, err2 = p.handler.GetPublicUserInfo(ctx, args.Username); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMNotFoundException:
  result.NotFoundException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMUserException:
  result.UserException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicUserInfo: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPublicUserInfo", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPublicUserInfo", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorGetUserUrls struct {
  handler UserStore
}

func (p *userStoreProcessorGetUserUrls) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreGetUserUrlsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getUserUrls", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreGetUserUrlsResult{}
  var retval *UserUrls
  if retval, err2 = p.handler.GetUserUrls(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUserUrls: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getUserUrls", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getUserUrls", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorInviteToBusiness struct {
  handler UserStore
}

func (p *userStoreProcessorInviteToBusiness) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreInviteToBusinessArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "inviteToBusiness", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreInviteToBusinessResult{}
  if err2 = p.handler.InviteToBusiness(ctx, args.AuthenticationToken, args.EmailAddress); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing inviteToBusiness: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "inviteToBusiness", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "inviteToBusiness", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorRemoveFromBusiness struct {
  handler UserStore
}

func (p *userStoreProcessorRemoveFromBusiness) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreRemoveFromBusinessArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "removeFromBusiness", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreRemoveFromBusinessResult{}
  if err2 = p.handler.RemoveFromBusiness(ctx, args.AuthenticationToken, args.EmailAddress); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing removeFromBusiness: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "removeFromBusiness", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "removeFromBusiness", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorUpdateBusinessUserIdentifier struct {
  handler UserStore
}

func (p *userStoreProcessorUpdateBusinessUserIdentifier) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreUpdateBusinessUserIdentifierArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updateBusinessUserIdentifier", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreUpdateBusinessUserIdentifierResult{}
  if err2 = p.handler.UpdateBusinessUserIdentifier(ctx, args.AuthenticationToken, args.OldEmailAddress, args.NewEmailAddress_); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    case *EDAMNotFoundException:
  result.NotFoundException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateBusinessUserIdentifier: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "updateBusinessUserIdentifier", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "updateBusinessUserIdentifier", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorListBusinessUsers struct {
  handler UserStore
}

func (p *userStoreProcessorListBusinessUsers) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreListBusinessUsersArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listBusinessUsers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreListBusinessUsersResult{}
  var retval []*UserProfile
  if retval, err2 = p.handler.ListBusinessUsers(ctx, args.AuthenticationToken); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBusinessUsers: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listBusinessUsers", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listBusinessUsers", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorListBusinessInvitations struct {
  handler UserStore
}

func (p *userStoreProcessorListBusinessInvitations) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreListBusinessInvitationsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listBusinessInvitations", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreListBusinessInvitationsResult{}
  var retval []*BusinessInvitation
  if retval, err2 = p.handler.ListBusinessInvitations(ctx, args.AuthenticationToken, args.IncludeRequestedInvitations); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    case *EDAMSystemException:
  result.SystemException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBusinessInvitations: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listBusinessInvitations", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listBusinessInvitations", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type userStoreProcessorGetAccountLimits struct {
  handler UserStore
}

func (p *userStoreProcessorGetAccountLimits) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := UserStoreGetAccountLimitsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getAccountLimits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := UserStoreGetAccountLimitsResult{}
  var retval *AccountLimits
  if retval, err2 = p.handler.GetAccountLimits(ctx, args.ServiceLevel); err2 != nil {
    tickerCancel()
  switch v := err2.(type) {
    case *EDAMUserException:
  result.UserException = v
    default:
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAccountLimits: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getAccountLimits", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getAccountLimits", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
type UserStoreCheckVersionArgs struct {
  ClientName string `thrift:"clientName,1" db:"clientName" json:"clientName"`
  EdamVersionMajor int16 `thrift:"edamVersionMajor,2" db:"edamVersionMajor" json:"edamVersionMajor"`
  EdamVersionMinor int16 `thrift:"edamVersionMinor,3" db:"edamVersionMinor" json:"edamVersionMinor"`
}

func NewUserStoreCheckVersionArgs() *UserStoreCheckVersionArgs {
  return &UserStoreCheckVersionArgs{
EdamVersionMajor: 1,

EdamVersionMinor: 28,
}
}


func (p *UserStoreCheckVersionArgs) GetClientName() string {
  return p.ClientName
}

func (p *UserStoreCheckVersionArgs) GetEdamVersionMajor() int16 {
  return p.EdamVersionMajor
}

func (p *UserStoreCheckVersionArgs) GetEdamVersionMinor() int16 {
  return p.EdamVersionMinor
}
func (p *UserStoreCheckVersionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I16 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I16 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreCheckVersionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClientName = v
}
  return nil
}

func (p *UserStoreCheckVersionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI16(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EdamVersionMajor = v
}
  return nil
}

func (p *UserStoreCheckVersionArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI16(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.EdamVersionMinor = v
}
  return nil
}

func (p *UserStoreCheckVersionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkVersion_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreCheckVersionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clientName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clientName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClientName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clientName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clientName: ", p), err) }
  return err
}

func (p *UserStoreCheckVersionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "edamVersionMajor", thrift.I16, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:edamVersionMajor: ", p), err) }
  if err := oprot.WriteI16(ctx, int16(p.EdamVersionMajor)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.edamVersionMajor (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:edamVersionMajor: ", p), err) }
  return err
}

func (p *UserStoreCheckVersionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "edamVersionMinor", thrift.I16, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:edamVersionMinor: ", p), err) }
  if err := oprot.WriteI16(ctx, int16(p.EdamVersionMinor)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.edamVersionMinor (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:edamVersionMinor: ", p), err) }
  return err
}

func (p *UserStoreCheckVersionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreCheckVersionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type UserStoreCheckVersionResult struct {
  Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewUserStoreCheckVersionResult() *UserStoreCheckVersionResult {
  return &UserStoreCheckVersionResult{}
}

var UserStoreCheckVersionResult_Success_DEFAULT bool
func (p *UserStoreCheckVersionResult) GetSuccess() bool {
  if !p.IsSetSuccess() {
    return UserStoreCheckVersionResult_Success_DEFAULT
  }
return *p.Success
}
func (p *UserStoreCheckVersionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreCheckVersionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreCheckVersionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *UserStoreCheckVersionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "checkVersion_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreCheckVersionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreCheckVersionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreCheckVersionResult(%+v)", *p)
}

// Attributes:
//  - Locale
type UserStoreGetBootstrapInfoArgs struct {
  Locale string `thrift:"locale,1" db:"locale" json:"locale"`
}

func NewUserStoreGetBootstrapInfoArgs() *UserStoreGetBootstrapInfoArgs {
  return &UserStoreGetBootstrapInfoArgs{}
}


func (p *UserStoreGetBootstrapInfoArgs) GetLocale() string {
  return p.Locale
}
func (p *UserStoreGetBootstrapInfoArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetBootstrapInfoArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Locale = v
}
  return nil
}

func (p *UserStoreGetBootstrapInfoArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getBootstrapInfo_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetBootstrapInfoArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "locale", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:locale: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Locale)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.locale (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:locale: ", p), err) }
  return err
}

func (p *UserStoreGetBootstrapInfoArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetBootstrapInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
type UserStoreGetBootstrapInfoResult struct {
  Success *BootstrapInfo `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewUserStoreGetBootstrapInfoResult() *UserStoreGetBootstrapInfoResult {
  return &UserStoreGetBootstrapInfoResult{}
}

var UserStoreGetBootstrapInfoResult_Success_DEFAULT *BootstrapInfo
func (p *UserStoreGetBootstrapInfoResult) GetSuccess() *BootstrapInfo {
  if !p.IsSetSuccess() {
    return UserStoreGetBootstrapInfoResult_Success_DEFAULT
  }
return p.Success
}
func (p *UserStoreGetBootstrapInfoResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreGetBootstrapInfoResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetBootstrapInfoResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &BootstrapInfo{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreGetBootstrapInfoResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getBootstrapInfo_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetBootstrapInfoResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreGetBootstrapInfoResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetBootstrapInfoResult(%+v)", *p)
}

// Attributes:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
type UserStoreAuthenticateLongSessionArgs struct {
  Username string `thrift:"username,1" db:"username" json:"username"`
  Password string `thrift:"password,2" db:"password" json:"password"`
  ConsumerKey string `thrift:"consumerKey,3" db:"consumerKey" json:"consumerKey"`
  ConsumerSecret string `thrift:"consumerSecret,4" db:"consumerSecret" json:"consumerSecret"`
  DeviceIdentifier string `thrift:"deviceIdentifier,5" db:"deviceIdentifier" json:"deviceIdentifier"`
  DeviceDescription string `thrift:"deviceDescription,6" db:"deviceDescription" json:"deviceDescription"`
  SupportsTwoFactor bool `thrift:"supportsTwoFactor,7" db:"supportsTwoFactor" json:"supportsTwoFactor"`
}

func NewUserStoreAuthenticateLongSessionArgs() *UserStoreAuthenticateLongSessionArgs {
  return &UserStoreAuthenticateLongSessionArgs{}
}


func (p *UserStoreAuthenticateLongSessionArgs) GetUsername() string {
  return p.Username
}

func (p *UserStoreAuthenticateLongSessionArgs) GetPassword() string {
  return p.Password
}

func (p *UserStoreAuthenticateLongSessionArgs) GetConsumerKey() string {
  return p.ConsumerKey
}

func (p *UserStoreAuthenticateLongSessionArgs) GetConsumerSecret() string {
  return p.ConsumerSecret
}

func (p *UserStoreAuthenticateLongSessionArgs) GetDeviceIdentifier() string {
  return p.DeviceIdentifier
}

func (p *UserStoreAuthenticateLongSessionArgs) GetDeviceDescription() string {
  return p.DeviceDescription
}

func (p *UserStoreAuthenticateLongSessionArgs) GetSupportsTwoFactor() bool {
  return p.SupportsTwoFactor
}
func (p *UserStoreAuthenticateLongSessionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Username = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Password = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.ConsumerKey = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.ConsumerSecret = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.DeviceIdentifier = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.DeviceDescription = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.SupportsTwoFactor = v
}
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateLongSession_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "username", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Username)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "password", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:password: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Password)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.password (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:password: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "consumerKey", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consumerKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ConsumerKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consumerKey (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consumerKey: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "consumerSecret", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consumerSecret: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ConsumerSecret)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.consumerSecret (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consumerSecret: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "deviceIdentifier", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:deviceIdentifier: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.DeviceIdentifier)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.deviceIdentifier (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:deviceIdentifier: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "deviceDescription", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:deviceDescription: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.DeviceDescription)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.deviceDescription (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:deviceDescription: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "supportsTwoFactor", thrift.BOOL, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:supportsTwoFactor: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.SupportsTwoFactor)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.supportsTwoFactor (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:supportsTwoFactor: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateLongSessionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreAuthenticateLongSessionArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateLongSessionResult struct {
  Success *AuthenticationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateLongSessionResult() *UserStoreAuthenticateLongSessionResult {
  return &UserStoreAuthenticateLongSessionResult{}
}

var UserStoreAuthenticateLongSessionResult_Success_DEFAULT *AuthenticationResult_
func (p *UserStoreAuthenticateLongSessionResult) GetSuccess() *AuthenticationResult_ {
  if !p.IsSetSuccess() {
    return UserStoreAuthenticateLongSessionResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreAuthenticateLongSessionResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreAuthenticateLongSessionResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreAuthenticateLongSessionResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreAuthenticateLongSessionResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreAuthenticateLongSessionResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreAuthenticateLongSessionResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreAuthenticateLongSessionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreAuthenticateLongSessionResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreAuthenticateLongSessionResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreAuthenticateLongSessionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreAuthenticateLongSessionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &AuthenticationResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreAuthenticateLongSessionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreAuthenticateLongSessionResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreAuthenticateLongSessionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateLongSession_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreAuthenticateLongSessionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreAuthenticateLongSessionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreAuthenticateLongSessionResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreAuthenticateLongSessionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreAuthenticateLongSessionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
type UserStoreCompleteTwoFactorAuthenticationArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  OneTimeCode string `thrift:"oneTimeCode,2" db:"oneTimeCode" json:"oneTimeCode"`
  DeviceIdentifier string `thrift:"deviceIdentifier,3" db:"deviceIdentifier" json:"deviceIdentifier"`
  DeviceDescription string `thrift:"deviceDescription,4" db:"deviceDescription" json:"deviceDescription"`
}

func NewUserStoreCompleteTwoFactorAuthenticationArgs() *UserStoreCompleteTwoFactorAuthenticationArgs {
  return &UserStoreCompleteTwoFactorAuthenticationArgs{}
}


func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetOneTimeCode() string {
  return p.OneTimeCode
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetDeviceIdentifier() string {
  return p.DeviceIdentifier
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetDeviceDescription() string {
  return p.DeviceDescription
}
func (p *UserStoreCompleteTwoFactorAuthenticationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.OneTimeCode = v
}
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.DeviceIdentifier = v
}
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.DeviceDescription = v
}
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "completeTwoFactorAuthentication_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "oneTimeCode", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:oneTimeCode: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.OneTimeCode)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.oneTimeCode (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:oneTimeCode: ", p), err) }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "deviceIdentifier", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:deviceIdentifier: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.DeviceIdentifier)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.deviceIdentifier (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:deviceIdentifier: ", p), err) }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "deviceDescription", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:deviceDescription: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.DeviceDescription)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.deviceDescription (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:deviceDescription: ", p), err) }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreCompleteTwoFactorAuthenticationArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreCompleteTwoFactorAuthenticationResult struct {
  Success *AuthenticationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreCompleteTwoFactorAuthenticationResult() *UserStoreCompleteTwoFactorAuthenticationResult {
  return &UserStoreCompleteTwoFactorAuthenticationResult{}
}

var UserStoreCompleteTwoFactorAuthenticationResult_Success_DEFAULT *AuthenticationResult_
func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetSuccess() *AuthenticationResult_ {
  if !p.IsSetSuccess() {
    return UserStoreCompleteTwoFactorAuthenticationResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreCompleteTwoFactorAuthenticationResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreCompleteTwoFactorAuthenticationResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreCompleteTwoFactorAuthenticationResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreCompleteTwoFactorAuthenticationResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &AuthenticationResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "completeTwoFactorAuthentication_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreCompleteTwoFactorAuthenticationResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreRevokeLongSessionArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewUserStoreRevokeLongSessionArgs() *UserStoreRevokeLongSessionArgs {
  return &UserStoreRevokeLongSessionArgs{}
}


func (p *UserStoreRevokeLongSessionArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *UserStoreRevokeLongSessionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreRevokeLongSessionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreRevokeLongSessionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "revokeLongSession_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreRevokeLongSessionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreRevokeLongSessionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreRevokeLongSessionArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
type UserStoreRevokeLongSessionResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreRevokeLongSessionResult() *UserStoreRevokeLongSessionResult {
  return &UserStoreRevokeLongSessionResult{}
}

var UserStoreRevokeLongSessionResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreRevokeLongSessionResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreRevokeLongSessionResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreRevokeLongSessionResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreRevokeLongSessionResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreRevokeLongSessionResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreRevokeLongSessionResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreRevokeLongSessionResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreRevokeLongSessionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreRevokeLongSessionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreRevokeLongSessionResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreRevokeLongSessionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "revokeLongSession_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreRevokeLongSessionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreRevokeLongSessionResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreRevokeLongSessionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreRevokeLongSessionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreAuthenticateToBusinessArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewUserStoreAuthenticateToBusinessArgs() *UserStoreAuthenticateToBusinessArgs {
  return &UserStoreAuthenticateToBusinessArgs{}
}


func (p *UserStoreAuthenticateToBusinessArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *UserStoreAuthenticateToBusinessArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreAuthenticateToBusinessArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateToBusiness_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreAuthenticateToBusinessArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreAuthenticateToBusinessArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateToBusinessResult struct {
  Success *AuthenticationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateToBusinessResult() *UserStoreAuthenticateToBusinessResult {
  return &UserStoreAuthenticateToBusinessResult{}
}

var UserStoreAuthenticateToBusinessResult_Success_DEFAULT *AuthenticationResult_
func (p *UserStoreAuthenticateToBusinessResult) GetSuccess() *AuthenticationResult_ {
  if !p.IsSetSuccess() {
    return UserStoreAuthenticateToBusinessResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreAuthenticateToBusinessResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreAuthenticateToBusinessResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreAuthenticateToBusinessResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreAuthenticateToBusinessResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreAuthenticateToBusinessResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreAuthenticateToBusinessResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreAuthenticateToBusinessResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreAuthenticateToBusinessResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreAuthenticateToBusinessResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreAuthenticateToBusinessResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreAuthenticateToBusinessResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &AuthenticationResult_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreAuthenticateToBusinessResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreAuthenticateToBusinessResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreAuthenticateToBusinessResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "authenticateToBusiness_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreAuthenticateToBusinessResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreAuthenticateToBusinessResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreAuthenticateToBusinessResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreAuthenticateToBusinessResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreAuthenticateToBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetUserArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewUserStoreGetUserArgs() *UserStoreGetUserArgs {
  return &UserStoreGetUserArgs{}
}


func (p *UserStoreGetUserArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *UserStoreGetUserArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetUserArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreGetUserArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getUser_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetUserArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreGetUserArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetUserArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetUserResult struct {
  Success *User `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreGetUserResult() *UserStoreGetUserResult {
  return &UserStoreGetUserResult{}
}

var UserStoreGetUserResult_Success_DEFAULT *User
func (p *UserStoreGetUserResult) GetSuccess() *User {
  if !p.IsSetSuccess() {
    return UserStoreGetUserResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreGetUserResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreGetUserResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreGetUserResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreGetUserResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreGetUserResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreGetUserResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreGetUserResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreGetUserResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreGetUserResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreGetUserResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetUserResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &User{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreGetUserResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreGetUserResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreGetUserResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getUser_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetUserResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreGetUserResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetUserResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetUserResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetUserResult(%+v)", *p)
}

// Attributes:
//  - Username
type UserStoreGetPublicUserInfoArgs struct {
  Username string `thrift:"username,1" db:"username" json:"username"`
}

func NewUserStoreGetPublicUserInfoArgs() *UserStoreGetPublicUserInfoArgs {
  return &UserStoreGetPublicUserInfoArgs{}
}


func (p *UserStoreGetPublicUserInfoArgs) GetUsername() string {
  return p.Username
}
func (p *UserStoreGetPublicUserInfoArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetPublicUserInfoArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Username = v
}
  return nil
}

func (p *UserStoreGetPublicUserInfoArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPublicUserInfo_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetPublicUserInfoArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "username", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Username)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err) }
  return err
}

func (p *UserStoreGetPublicUserInfoArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetPublicUserInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - NotFoundException
//  - SystemException
//  - UserException
type UserStoreGetPublicUserInfoResult struct {
  Success *PublicUserInfo `thrift:"success,0" db:"success" json:"success,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,1" db:"notFoundException" json:"notFoundException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  UserException *EDAMUserException `thrift:"userException,3" db:"userException" json:"userException,omitempty"`
}

func NewUserStoreGetPublicUserInfoResult() *UserStoreGetPublicUserInfoResult {
  return &UserStoreGetPublicUserInfoResult{}
}

var UserStoreGetPublicUserInfoResult_Success_DEFAULT *PublicUserInfo
func (p *UserStoreGetPublicUserInfoResult) GetSuccess() *PublicUserInfo {
  if !p.IsSetSuccess() {
    return UserStoreGetPublicUserInfoResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreGetPublicUserInfoResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *UserStoreGetPublicUserInfoResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return UserStoreGetPublicUserInfoResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
var UserStoreGetPublicUserInfoResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreGetPublicUserInfoResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreGetPublicUserInfoResult_SystemException_DEFAULT
  }
return p.SystemException
}
var UserStoreGetPublicUserInfoResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreGetPublicUserInfoResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreGetPublicUserInfoResult_UserException_DEFAULT
  }
return p.UserException
}
func (p *UserStoreGetPublicUserInfoResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreGetPublicUserInfoResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetPublicUserInfoResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &PublicUserInfo{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreGetPublicUserInfoResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *UserStoreGetPublicUserInfoResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreGetPublicUserInfoResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreGetPublicUserInfoResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPublicUserInfo_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetPublicUserInfoResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notFoundException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetPublicUserInfoResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetPublicUserInfoResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetUserUrlsArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewUserStoreGetUserUrlsArgs() *UserStoreGetUserUrlsArgs {
  return &UserStoreGetUserUrlsArgs{}
}


func (p *UserStoreGetUserUrlsArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *UserStoreGetUserUrlsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetUserUrlsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreGetUserUrlsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getUserUrls_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetUserUrlsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreGetUserUrlsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetUserUrlsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetUserUrlsResult struct {
  Success *UserUrls `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreGetUserUrlsResult() *UserStoreGetUserUrlsResult {
  return &UserStoreGetUserUrlsResult{}
}

var UserStoreGetUserUrlsResult_Success_DEFAULT *UserUrls
func (p *UserStoreGetUserUrlsResult) GetSuccess() *UserUrls {
  if !p.IsSetSuccess() {
    return UserStoreGetUserUrlsResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreGetUserUrlsResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreGetUserUrlsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreGetUserUrlsResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreGetUserUrlsResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreGetUserUrlsResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreGetUserUrlsResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreGetUserUrlsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreGetUserUrlsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreGetUserUrlsResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreGetUserUrlsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetUserUrlsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &UserUrls{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreGetUserUrlsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreGetUserUrlsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreGetUserUrlsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getUserUrls_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetUserUrlsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreGetUserUrlsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetUserUrlsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetUserUrlsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetUserUrlsResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - EmailAddress
type UserStoreInviteToBusinessArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  EmailAddress string `thrift:"emailAddress,2" db:"emailAddress" json:"emailAddress"`
}

func NewUserStoreInviteToBusinessArgs() *UserStoreInviteToBusinessArgs {
  return &UserStoreInviteToBusinessArgs{}
}


func (p *UserStoreInviteToBusinessArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *UserStoreInviteToBusinessArgs) GetEmailAddress() string {
  return p.EmailAddress
}
func (p *UserStoreInviteToBusinessArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreInviteToBusinessArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreInviteToBusinessArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EmailAddress = v
}
  return nil
}

func (p *UserStoreInviteToBusinessArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "inviteToBusiness_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreInviteToBusinessArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreInviteToBusinessArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "emailAddress", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:emailAddress: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.EmailAddress)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.emailAddress (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:emailAddress: ", p), err) }
  return err
}

func (p *UserStoreInviteToBusinessArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreInviteToBusinessArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
type UserStoreInviteToBusinessResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreInviteToBusinessResult() *UserStoreInviteToBusinessResult {
  return &UserStoreInviteToBusinessResult{}
}

var UserStoreInviteToBusinessResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreInviteToBusinessResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreInviteToBusinessResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreInviteToBusinessResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreInviteToBusinessResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreInviteToBusinessResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreInviteToBusinessResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreInviteToBusinessResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreInviteToBusinessResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreInviteToBusinessResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreInviteToBusinessResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreInviteToBusinessResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "inviteToBusiness_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreInviteToBusinessResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreInviteToBusinessResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreInviteToBusinessResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreInviteToBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - EmailAddress
type UserStoreRemoveFromBusinessArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  EmailAddress string `thrift:"emailAddress,2" db:"emailAddress" json:"emailAddress"`
}

func NewUserStoreRemoveFromBusinessArgs() *UserStoreRemoveFromBusinessArgs {
  return &UserStoreRemoveFromBusinessArgs{}
}


func (p *UserStoreRemoveFromBusinessArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *UserStoreRemoveFromBusinessArgs) GetEmailAddress() string {
  return p.EmailAddress
}
func (p *UserStoreRemoveFromBusinessArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreRemoveFromBusinessArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreRemoveFromBusinessArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.EmailAddress = v
}
  return nil
}

func (p *UserStoreRemoveFromBusinessArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "removeFromBusiness_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreRemoveFromBusinessArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreRemoveFromBusinessArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "emailAddress", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:emailAddress: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.EmailAddress)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.emailAddress (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:emailAddress: ", p), err) }
  return err
}

func (p *UserStoreRemoveFromBusinessArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreRemoveFromBusinessArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
//  - NotFoundException
type UserStoreRemoveFromBusinessResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewUserStoreRemoveFromBusinessResult() *UserStoreRemoveFromBusinessResult {
  return &UserStoreRemoveFromBusinessResult{}
}

var UserStoreRemoveFromBusinessResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreRemoveFromBusinessResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreRemoveFromBusinessResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreRemoveFromBusinessResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreRemoveFromBusinessResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreRemoveFromBusinessResult_SystemException_DEFAULT
  }
return p.SystemException
}
var UserStoreRemoveFromBusinessResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *UserStoreRemoveFromBusinessResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return UserStoreRemoveFromBusinessResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *UserStoreRemoveFromBusinessResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreRemoveFromBusinessResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreRemoveFromBusinessResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *UserStoreRemoveFromBusinessResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreRemoveFromBusinessResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreRemoveFromBusinessResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreRemoveFromBusinessResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *UserStoreRemoveFromBusinessResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "removeFromBusiness_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreRemoveFromBusinessResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreRemoveFromBusinessResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreRemoveFromBusinessResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *UserStoreRemoveFromBusinessResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreRemoveFromBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - OldEmailAddress
//  - NewEmailAddress_
type UserStoreUpdateBusinessUserIdentifierArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  OldEmailAddress string `thrift:"oldEmailAddress,2" db:"oldEmailAddress" json:"oldEmailAddress"`
  NewEmailAddress_ string `thrift:"newEmailAddress,3" db:"newEmailAddress" json:"newEmailAddress"`
}

func NewUserStoreUpdateBusinessUserIdentifierArgs() *UserStoreUpdateBusinessUserIdentifierArgs {
  return &UserStoreUpdateBusinessUserIdentifierArgs{}
}


func (p *UserStoreUpdateBusinessUserIdentifierArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) GetOldEmailAddress() string {
  return p.OldEmailAddress
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) GetNewEmailAddress_() string {
  return p.NewEmailAddress_
}
func (p *UserStoreUpdateBusinessUserIdentifierArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.OldEmailAddress = v
}
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NewEmailAddress_ = v
}
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateBusinessUserIdentifier_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "oldEmailAddress", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:oldEmailAddress: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.OldEmailAddress)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.oldEmailAddress (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:oldEmailAddress: ", p), err) }
  return err
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "newEmailAddress", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:newEmailAddress: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.NewEmailAddress_)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.newEmailAddress (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:newEmailAddress: ", p), err) }
  return err
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreUpdateBusinessUserIdentifierArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
//  - NotFoundException
type UserStoreUpdateBusinessUserIdentifierResult struct {
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
  NotFoundException *EDAMNotFoundException `thrift:"notFoundException,3" db:"notFoundException" json:"notFoundException,omitempty"`
}

func NewUserStoreUpdateBusinessUserIdentifierResult() *UserStoreUpdateBusinessUserIdentifierResult {
  return &UserStoreUpdateBusinessUserIdentifierResult{}
}

var UserStoreUpdateBusinessUserIdentifierResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreUpdateBusinessUserIdentifierResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreUpdateBusinessUserIdentifierResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreUpdateBusinessUserIdentifierResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreUpdateBusinessUserIdentifierResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreUpdateBusinessUserIdentifierResult_SystemException_DEFAULT
  }
return p.SystemException
}
var UserStoreUpdateBusinessUserIdentifierResult_NotFoundException_DEFAULT *EDAMNotFoundException
func (p *UserStoreUpdateBusinessUserIdentifierResult) GetNotFoundException() *EDAMNotFoundException {
  if !p.IsSetNotFoundException() {
    return UserStoreUpdateBusinessUserIdentifierResult_NotFoundException_DEFAULT
  }
return p.NotFoundException
}
func (p *UserStoreUpdateBusinessUserIdentifierResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) IsSetNotFoundException() bool {
  return p.NotFoundException != nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NotFoundException = &EDAMNotFoundException{}
  if err := p.NotFoundException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
  }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updateBusinessUserIdentifier_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNotFoundException() {
    if err := oprot.WriteFieldBegin(ctx, "notFoundException", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err) }
    if err := p.NotFoundException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err) }
  }
  return err
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreUpdateBusinessUserIdentifierResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreListBusinessUsersArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
}

func NewUserStoreListBusinessUsersArgs() *UserStoreListBusinessUsersArgs {
  return &UserStoreListBusinessUsersArgs{}
}


func (p *UserStoreListBusinessUsersArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}
func (p *UserStoreListBusinessUsersArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreListBusinessUsersArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreListBusinessUsersArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listBusinessUsers_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreListBusinessUsersArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreListBusinessUsersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreListBusinessUsersArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreListBusinessUsersResult struct {
  Success []*UserProfile `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreListBusinessUsersResult() *UserStoreListBusinessUsersResult {
  return &UserStoreListBusinessUsersResult{}
}

var UserStoreListBusinessUsersResult_Success_DEFAULT []*UserProfile

func (p *UserStoreListBusinessUsersResult) GetSuccess() []*UserProfile {
  return p.Success
}
var UserStoreListBusinessUsersResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreListBusinessUsersResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreListBusinessUsersResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreListBusinessUsersResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreListBusinessUsersResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreListBusinessUsersResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreListBusinessUsersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreListBusinessUsersResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreListBusinessUsersResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreListBusinessUsersResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreListBusinessUsersResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*UserProfile, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem57 := &UserProfile{}
    if err := _elem57.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem57), err)
    }
    p.Success = append(p.Success, _elem57)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UserStoreListBusinessUsersResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreListBusinessUsersResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreListBusinessUsersResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listBusinessUsers_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreListBusinessUsersResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreListBusinessUsersResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreListBusinessUsersResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreListBusinessUsersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreListBusinessUsersResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - IncludeRequestedInvitations
type UserStoreListBusinessInvitationsArgs struct {
  AuthenticationToken string `thrift:"authenticationToken,1" db:"authenticationToken" json:"authenticationToken"`
  IncludeRequestedInvitations bool `thrift:"includeRequestedInvitations,2" db:"includeRequestedInvitations" json:"includeRequestedInvitations"`
}

func NewUserStoreListBusinessInvitationsArgs() *UserStoreListBusinessInvitationsArgs {
  return &UserStoreListBusinessInvitationsArgs{}
}


func (p *UserStoreListBusinessInvitationsArgs) GetAuthenticationToken() string {
  return p.AuthenticationToken
}

func (p *UserStoreListBusinessInvitationsArgs) GetIncludeRequestedInvitations() bool {
  return p.IncludeRequestedInvitations
}
func (p *UserStoreListBusinessInvitationsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreListBusinessInvitationsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.AuthenticationToken = v
}
  return nil
}

func (p *UserStoreListBusinessInvitationsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.IncludeRequestedInvitations = v
}
  return nil
}

func (p *UserStoreListBusinessInvitationsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listBusinessInvitations_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreListBusinessInvitationsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "authenticationToken", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AuthenticationToken)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err) }
  return err
}

func (p *UserStoreListBusinessInvitationsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "includeRequestedInvitations", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeRequestedInvitations: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IncludeRequestedInvitations)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.includeRequestedInvitations (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeRequestedInvitations: ", p), err) }
  return err
}

func (p *UserStoreListBusinessInvitationsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreListBusinessInvitationsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreListBusinessInvitationsResult struct {
  Success []*BusinessInvitation `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
  SystemException *EDAMSystemException `thrift:"systemException,2" db:"systemException" json:"systemException,omitempty"`
}

func NewUserStoreListBusinessInvitationsResult() *UserStoreListBusinessInvitationsResult {
  return &UserStoreListBusinessInvitationsResult{}
}

var UserStoreListBusinessInvitationsResult_Success_DEFAULT []*BusinessInvitation

func (p *UserStoreListBusinessInvitationsResult) GetSuccess() []*BusinessInvitation {
  return p.Success
}
var UserStoreListBusinessInvitationsResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreListBusinessInvitationsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreListBusinessInvitationsResult_UserException_DEFAULT
  }
return p.UserException
}
var UserStoreListBusinessInvitationsResult_SystemException_DEFAULT *EDAMSystemException
func (p *UserStoreListBusinessInvitationsResult) GetSystemException() *EDAMSystemException {
  if !p.IsSetSystemException() {
    return UserStoreListBusinessInvitationsResult_SystemException_DEFAULT
  }
return p.SystemException
}
func (p *UserStoreListBusinessInvitationsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreListBusinessInvitationsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreListBusinessInvitationsResult) IsSetSystemException() bool {
  return p.SystemException != nil
}

func (p *UserStoreListBusinessInvitationsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreListBusinessInvitationsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*BusinessInvitation, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem58 := &BusinessInvitation{}
    if err := _elem58.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem58), err)
    }
    p.Success = append(p.Success, _elem58)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UserStoreListBusinessInvitationsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreListBusinessInvitationsResult)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SystemException = &EDAMSystemException{}
  if err := p.SystemException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
  }
  return nil
}

func (p *UserStoreListBusinessInvitationsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listBusinessInvitations_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreListBusinessInvitationsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreListBusinessInvitationsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreListBusinessInvitationsResult) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSystemException() {
    if err := oprot.WriteFieldBegin(ctx, "systemException", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err) }
    if err := p.SystemException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err) }
  }
  return err
}

func (p *UserStoreListBusinessInvitationsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreListBusinessInvitationsResult(%+v)", *p)
}

// Attributes:
//  - ServiceLevel
type UserStoreGetAccountLimitsArgs struct {
  ServiceLevel ServiceLevel `thrift:"serviceLevel,1" db:"serviceLevel" json:"serviceLevel"`
}

func NewUserStoreGetAccountLimitsArgs() *UserStoreGetAccountLimitsArgs {
  return &UserStoreGetAccountLimitsArgs{}
}


func (p *UserStoreGetAccountLimitsArgs) GetServiceLevel() ServiceLevel {
  return p.ServiceLevel
}
func (p *UserStoreGetAccountLimitsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetAccountLimitsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := ServiceLevel(v)
  p.ServiceLevel = temp
}
  return nil
}

func (p *UserStoreGetAccountLimitsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getAccountLimits_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetAccountLimitsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serviceLevel", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serviceLevel: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ServiceLevel)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.serviceLevel (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serviceLevel: ", p), err) }
  return err
}

func (p *UserStoreGetAccountLimitsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetAccountLimitsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
type UserStoreGetAccountLimitsResult struct {
  Success *AccountLimits `thrift:"success,0" db:"success" json:"success,omitempty"`
  UserException *EDAMUserException `thrift:"userException,1" db:"userException" json:"userException,omitempty"`
}

func NewUserStoreGetAccountLimitsResult() *UserStoreGetAccountLimitsResult {
  return &UserStoreGetAccountLimitsResult{}
}

var UserStoreGetAccountLimitsResult_Success_DEFAULT *AccountLimits
func (p *UserStoreGetAccountLimitsResult) GetSuccess() *AccountLimits {
  if !p.IsSetSuccess() {
    return UserStoreGetAccountLimitsResult_Success_DEFAULT
  }
return p.Success
}
var UserStoreGetAccountLimitsResult_UserException_DEFAULT *EDAMUserException
func (p *UserStoreGetAccountLimitsResult) GetUserException() *EDAMUserException {
  if !p.IsSetUserException() {
    return UserStoreGetAccountLimitsResult_UserException_DEFAULT
  }
return p.UserException
}
func (p *UserStoreGetAccountLimitsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *UserStoreGetAccountLimitsResult) IsSetUserException() bool {
  return p.UserException != nil
}

func (p *UserStoreGetAccountLimitsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UserStoreGetAccountLimitsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &AccountLimits{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *UserStoreGetAccountLimitsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.UserException = &EDAMUserException{}
  if err := p.UserException.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
  }
  return nil
}

func (p *UserStoreGetAccountLimitsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getAccountLimits_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UserStoreGetAccountLimitsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *UserStoreGetAccountLimitsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUserException() {
    if err := oprot.WriteFieldBegin(ctx, "userException", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err) }
    if err := p.UserException.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err) }
  }
  return err
}

func (p *UserStoreGetAccountLimitsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UserStoreGetAccountLimitsResult(%+v)", *p)
}


